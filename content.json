[{"title":"ArrayMap源码分析","date":"2017-07-24T07:54:42.000Z","path":"2017/07/24/ArrayMap源码分析/","text":"ArrayMap是Android提供的一种替换HashMap的数据结构，官方对它的介绍说ArrayMap是一种更有效率的Map结构，其原理是内部维护了两个数组，一个数组用来保存每一个key值得hash值，另一个数组用来保存key-value, 用来保存key-value的数组是保存hash值数组大小的两倍，下面这张图很好的展示了ArrayMap原理: 来源HashMap，ArrayMap，SparseArray源码分析及性能对比 成员变量1234567891011121314151617181920private static final int BASE_SIZE = 4; private static final int CACHE_SIZE = 10; static final int[] EMPTY_IMMUTABLE_INTS = new int[0]; public static final ArrayMap EMPTY = new ArrayMap&lt;&gt;(-1);//缓存相关 static Object[] mBaseCache; static int mBaseCacheSize; static Object[] mTwiceBaseCache; static int mTwiceBaseCacheSize; final boolean mIdentityHashCode; int[] mHashes; Object[] mArray; int mSize; //集合操作工具类 MapCollections&lt;K, V&gt; mCollections; mHashes用来存放key值相对应的hash值 mArray用来存放key-value, key值在2n处， value在2n+1处 ArrayMap还加入了缓存，mBaseCache用来缓存容量为BASE_SIZE的数组，mTwiceBaseCache用来缓存容量为2 * BASE_SIZE的数组 构造函数12345678910111213141516171819202122232425262728293031public ArrayMap() &#123; this(0, false); &#125; public ArrayMap(int capacity) &#123; this(capacity, false); &#125;/** &#123;@hide&#125; */ public ArrayMap(int capacity, boolean identityHashCode) &#123; mIdentityHashCode = identityHashCode; if (capacity &lt; 0) &#123; mHashes = EMPTY_IMMUTABLE_INTS; mArray = EmptyArray.OBJECT; &#125; else if (capacity == 0) &#123; mHashes = EmptyArray.INT; mArray = EmptyArray.OBJECT; &#125; else &#123; allocArrays(capacity); &#125; mSize = 0; &#125; public ArrayMap(ArrayMap&lt;K, V&gt; map) &#123; this(); if (map != null) &#123; putAll(map); &#125; &#125; 一般情况下，在开发中我们主要使用空参构造函数和一个参数的构造函数，不过这两个构造函数都是调用了第三个hide的构造函数, 这个构造函数中主要工作就是分配数组 allocArrays123456789101112131415161718192021222324252627282930313233343536373839private void allocArrays(final int size) &#123; if (mHashes == EMPTY_IMMUTABLE_INTS) &#123; throw new UnsupportedOperationException(\"ArrayMap is immutable\"); &#125; if (size == (BASE_SIZE*2)) &#123; synchronized (ArrayMap.class) &#123; if (mTwiceBaseCache != null) &#123; final Object[] array = mTwiceBaseCache; mArray = array; mTwiceBaseCache = (Object[])array[0]; mHashes = (int[])array[1]; array[0] = array[1] = null; mTwiceBaseCacheSize--; if (DEBUG) Log.d(TAG, \"Retrieving 2x cache \" + mHashes + \" now have \" + mTwiceBaseCacheSize + \" entries\"); return; &#125; &#125; &#125; else if (size == BASE_SIZE) &#123; synchronized (ArrayMap.class) &#123; if (mBaseCache != null) &#123; final Object[] array = mBaseCache; mArray = array; mBaseCache = (Object[])array[0]; mHashes = (int[])array[1]; //将缓存置为null array[0] = array[1] = null; //递减mBaseCacheSize mBaseCacheSize--; if (DEBUG) Log.d(TAG, \"Retrieving 1x cache \" + mHashes + \" now have \" + mBaseCacheSize + \" entries\"); return; &#125; &#125; &#125; mHashes = new int[size]; mArray = new Object[size&lt;&lt;1]; &#125; 从代码中可以看到，如果分配的size恰好等于4或者8, 则ArrayMap会优先在缓存中找，如果有缓存则直接使用缓存的数组，这样就避免了频繁的创建数组带来的内存消耗 方法1. put1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public V put(K key, V value) &#123; final int hash; int index; //查找key值对应的index,如果找到则为正数，否则为负数，代表了将要被插入的位置 if (key == null) &#123; hash = 0; //【1.1】 index = indexOfNull(); &#125; else &#123; hash = mIdentityHashCode ? System.identityHashCode(key) : key.hashCode(); index = indexOf(key, hash); &#125; //已存在key值，直接覆盖为新值 if (index &gt;= 0) &#123; index = (index&lt;&lt;1) + 1; final V old = (V)mArray[index]; mArray[index] = value; return old; &#125; //key值并不存在，则对index取反，获取将要被插入的index index = ~index; if (mSize &gt;= mHashes.length) &#123; //确定扩容的容量 final int n = mSize &gt;= (BASE_SIZE*2) ? (mSize+(mSize&gt;&gt;1)) : (mSize &gt;= BASE_SIZE ? (BASE_SIZE*2) : BASE_SIZE); if (DEBUG) Log.d(TAG, \"put: grow from \" + mHashes.length + \" to \" + n); final int[] ohashes = mHashes; final Object[] oarray = mArray; //重新分配数组，如果满足缓存条件，使用缓存 allocArrays(n); //迁移数组 if (mHashes.length &gt; 0) &#123; if (DEBUG) Log.d(TAG, \"put: copy 0-\" + mSize + \" to 0\"); System.arraycopy(ohashes, 0, mHashes, 0, ohashes.length); System.arraycopy(oarray, 0, mArray, 0, oarray.length); &#125; //释放之前的数组，如果之前的数组满足缓存条件，则将数组缓存起来, 【1.2】 freeArrays(ohashes, oarray, mSize); &#125; //插入数据 if (index &lt; mSize) &#123; if (DEBUG) Log.d(TAG, \"put: move \" + index + \"-\" + (mSize-index) + \" to \" + (index+1)); System.arraycopy(mHashes, index, mHashes, index + 1, mSize - index); System.arraycopy(mArray, index &lt;&lt; 1, mArray, (index + 1) &lt;&lt; 1, (mSize - index) &lt;&lt; 1); &#125; mHashes[index] = hash; mArray[index&lt;&lt;1] = key; mArray[(index&lt;&lt;1)+1] = value; mSize++; return null; &#125; 查找key值对应的index, 这里使用的也是二分搜索法，如果key值已存在则index为正数，否则为负数 如果key值已存在，直接覆盖为新值 如果key值不存在，对index取反 如果容量不够，进行扩容操作，生成新的数组，如果满足缓存条件，还会将就数组缓存起来避免频繁分配数组，之后前移现有数据到新数组 插入数据 1.1 indexOfNull1234567891011121314151617181920212223242526272829303132333435int indexOfNull() &#123; final int N = mSize; //如果数组为空，那么什么也不做 if (N == 0) &#123; return ~0; &#125; //二分搜索 int index = ContainerHelpers.binarySearch(mHashes, N, 0); //index &lt; 0 代表数组中并不存在key,直接返回 if (index &lt; 0) &#123; return index; &#125; //如果index处对应的key值恰好就是null, 则直接返回index if (null == mArray[index&lt;&lt;1]) &#123; return index; &#125; //从index后面找寻是否存在key为null int end; for (end = index + 1; end &lt; N &amp;&amp; mHashes[end] == 0; end++) &#123; if (null == mArray[end &lt;&lt; 1]) return end; &#125; //从index前面找寻是否存在key为null for (int i = index - 1; i &gt;= 0 &amp;&amp; mHashes[i] == 0; i--) &#123; if (null == mArray[i &lt;&lt; 1]) return i; &#125; //都没找到，返回将要被插入的索引位置的负数 return ~end;&#125; indexOf的实现与indexOfNull基本一样，只不过indexOfNull是判断key值是否等于null 1.2 freeArrays12345678910111213141516171819202122232425262728293031private static void freeArrays(final int[] hashes, final Object[] array, final int size) &#123; if (hashes.length == (BASE_SIZE*2)) &#123; synchronized (ArrayMap.class) &#123; if (mTwiceBaseCacheSize &lt; CACHE_SIZE) &#123; array[0] = mTwiceBaseCache; array[1] = hashes; for (int i=(size&lt;&lt;1)-1; i&gt;=2; i--) &#123; array[i] = null; &#125; mTwiceBaseCache = array; mTwiceBaseCacheSize++; if (DEBUG) Log.d(TAG, \"Storing 2x cache \" + array + \" now have \" + mTwiceBaseCacheSize + \" entries\"); &#125; &#125; &#125; else if (hashes.length == BASE_SIZE) &#123; synchronized (ArrayMap.class) &#123; if (mBaseCacheSize &lt; CACHE_SIZE) &#123; array[0] = mBaseCache; array[1] = hashes; for (int i=(size&lt;&lt;1)-1; i&gt;=2; i--) &#123; array[i] = null; &#125; mBaseCache = array; mBaseCacheSize++; if (DEBUG) Log.d(TAG, \"Storing 1x cache \" + array + \" now have \" + mBaseCacheSize + \" entries\"); &#125; &#125; &#125; &#125; CACHE_SIZE等于10，这意味着最多缓存十个数组，当旧的数组大小等于4或者8的时候，都会被缓存 2. get12345public V get(Object key) &#123; final int index = indexOfKey(key); return index &gt;= 0 ? (V)mArray[(index&lt;&lt;1)+1] : null;&#125; get方法非常简单，获取索引，根据索引返回对应值，就这么简单! 3. remove12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public V remove(Object key) &#123; final int index = indexOfKey(key); if (index &gt;= 0) &#123; return removeAt(index); &#125; return null; &#125; public V removeAt(int index) &#123; final Object old = mArray[(index &lt;&lt; 1) + 1]; if (mSize &lt;= 1) &#123; freeArrays(mHashes, mArray, mSize); mHashes = EmptyArray.INT; mArray = EmptyArray.OBJECT; mSize = 0; &#125; else &#123; //如果容量不到1/3降低ArrayMap容量 if (mHashes.length &gt; (BASE_SIZE*2) &amp;&amp; mSize &lt; mHashes.length/3) &#123; //保证容量不小于BASE_SIZE * 2 final int n = mSize &gt; (BASE_SIZE*2) ? (mSize + (mSize&gt;&gt;1)) : (BASE_SIZE*2); final int[] ohashes = mHashes; final Object[] oarray = mArray; allocArrays(n); mSize--; if (index &gt; 0) &#123; System.arraycopy(ohashes, 0, mHashes, 0, index); System.arraycopy(oarray, 0, mArray, 0, index &lt;&lt; 1); &#125; if (index &lt; mSize) &#123; System.arraycopy(ohashes, index + 1, mHashes, index, mSize - index); System.arraycopy(oarray, (index + 1) &lt;&lt; 1, mArray, index &lt;&lt; 1, (mSize - index) &lt;&lt; 1); &#125; &#125; else &#123; mSize--; if (index &lt; mSize) &#123; //把后面的数据往前前移一位 System.arraycopy(mHashes, index + 1, mHashes, index, mSize - index); System.arraycopy(mArray, (index + 1) &lt;&lt; 1, mArray, index &lt;&lt; 1, (mSize - index) &lt;&lt; 1); &#125; mArray[mSize &lt;&lt; 1] = null; mArray[(mSize &lt;&lt; 1) + 1] = null; &#125; &#125; return (V)old; &#125; remove首先获取索引值，然后直接调用removeAt来删除对应的值， 性能分析ArrayMap在确定index时，使用的也是二分查找法，其效率肯定会随着数据量的增大而受到影响，另外从代码中也可以看到，ArrayMap中比较频繁的出现了数组迁移，这就又会造成一些性能的损失，但是如果从内存角度来看，ArrayMap内部使用了缓存，且在删除元素后，会适当的缩小容量，减少内存占用，综合来看，如果数据量不大，且鲨如何删除操作不频繁时ArrayMap还是比较适用","tags":[{"name":"ArrayMap","slug":"ArrayMap","permalink":"https://wangyun137.github.io/tags/ArrayMap/"},{"name":"Java集合类源码分析","slug":"Java集合类源码分析","permalink":"https://wangyun137.github.io/tags/Java集合类源码分析/"}]},{"title":"SparseArray源码分析","date":"2017-07-24T07:53:18.000Z","path":"2017/07/24/SparseArray源码分析/","text":"SparseArray是Android官方推荐的一种高效率的Map类工具，如果key值是int值，最好使用SparseArray而不是HashMap SparseArray内部是使用基本类型int型数组来存放key值，这就意味着其内部省去了hash操作，只要比较int值是否相同即可判断是否是同一个对象，而HashMap虽然也可以用int类型来当key值，但是首先就会有一个自动装箱的过程，将int类型装箱成为Integer，先不论内部实现的效率，单就装箱这一点，其效率必然就会降低很多，再加上其内部会有hash等操作，效率上自然比不上SparseArray， 不过虽然SparseArray效率要高，但是SparseArray只能用于key是int的情形 下面就来看一下SparseArray的具体实现 成员变量1234567891011public class SparseArray&lt;E&gt; implements Cloneable &#123; private static final Object DELETED = new Object(); private boolean mGarbage = false; private int[] mKeys; private Object[] mValues; private int mSize; ... &#125; 可以看到SparseArray内部是用两个数组分别存放key和value，其中存放key的数组是int数组，这也省去了装箱操作，提升了效率 DELETED对象，从名字就可以看出其作用，它是占位对象，表示某索引位置的对象已被删除，用DELETED来占位, 方便后续的gc操作 构造函数12345678910111213141516public SparseArray() &#123; this(10);&#125;public SparseArray(int initialCapacity) &#123; if (initialCapacity == 0) &#123; //new int[0] mKeys = EmptyArray.INT; //new Object[0] mValues = EmptyArray.OBJECT; &#125; else &#123; mValues = ArrayUtils.newUnpaddedObjectArray(initialCapacity); mKeys = new int[mValues.length]; &#125; mSize = 0;&#125; 构造函数比较简单，主要就是根据初始容量初始化两个数组 方法1. put12345678910111213141516171819202122232425262728293031323334public void put(int key, E value) &#123; //通过二分搜索获取索引， i&gt;=0代表key值已存在， i&lt;0代表key值不存在，i取反下一个元素的插入位置, 【1.1】 int i = ContainerHelpers.binarySearch(mKeys, mSize, key); if (i &gt;= 0) &#123; //直接放入value mValues[i] = value; &#125; else &#123; //取反，获得对应的正数 i = ~i; if (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123; //如果索引处的value是DELETED, 直接替换为新的value即可 mKeys[i] = key; mValues[i] = value; return; &#125; if (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123; //如果容量不足，且有元素被删除, 进行gc操作 //此时数组中可能会有不连续的DELETED值存在，这种值是无效的，还占据空间，gc()的意义在于将所有 //有效的值按顺序连接在一起，替换所有DELETED值，节省空间, 【1.2】 gc(); //重新取得索引值 i = ~ContainerHelpers.binarySearch(mKeys, mSize, key); &#125; //如果容量够，直接插入，如果容量不够，先扩容，再插入, 【1.3】 mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key); mValues = GrowingArrayUtils.insert(mValues, mSize, i, value); mSize++; &#125; &#125; 首先通过二分搜索获取索引值, 返回的i如果是正数，代表key值已经存在， 如果是负数，代表key值不存在，对i取反后，就是即将要插入的索引位置 如果key值已经存在，直接覆盖旧的value 如果不存在，对i取反，获得正数的索引位置，如果索引处的值是被删除过的即values[i] = DELETED，直接替换为新的value后返回; 如果有元素被删除过mGarbage = true，且keys数组容量不足，进行gc操作，如果values数组中有DELETED元素存在，将有效地值前移替换这些废弃的值，从而节省空间, 进行完gc后，重新获取索引值 进行插入操作，如果容量够，直接插入，如果容量不够，先扩容，再插入 从使用二分搜索法，我们其实就可以知道， SparseArray存放的数据是按照key值得大小有序排列(升序or降序)，查看过ContainerHelpers.binarySearch后就可以知道，是按升序进行排列 1.1 ContainerHelpers.binarySearch123456789101112131415161718static int binarySearch(int[] array, int size, int value) &#123; int lo = 0; int hi = size - 1; while (lo &lt;= hi) &#123; final int mid = (lo + hi) &gt;&gt;&gt; 1;//无符号右移一位，等价于除以2 final int midVal = array[mid]; if (midVal &lt; value) &#123; lo = mid + 1; &#125; else if (midVal &gt; value) &#123; hi = mid - 1; &#125; else &#123; return mid; // value found &#125; &#125; return ~lo; // value not present &#125; &gt;&gt;&gt;1无符号右移一位等价于除以2但又比除法操作更高效，如果要查找的值已经存在，则返回相应的索引值，如果不存在，则返回一个负数，这个负数取反后，就是被查找的元素将要被插入的位置 1.2 gc1234567891011121314151617181920212223private void gc() &#123; int n = mSize; int o = 0; int[] keys = mKeys; Object[] values = mValues; for (int i = 0; i &lt; n; i++) &#123; Object val = values[i]; if (val != DELETED) &#123; if (i != o) &#123; keys[o] = keys[i]; values[o] = val; values[i] = null; &#125; o++; &#125; &#125; mGarbage = false; mSize = o;&#125; gc函数的主要功能就是遍历values数组，用有效的value前移替换DELETED无效的值，从而使有效的值连续排列在一起，节省空间 1.3 GrowingArrayUtils.insert123456789101112131415public static int[] insert(int[] array, int currentSize, int index, int element) &#123; assert currentSize &lt;= array.length; //容量够，直接插入 if (currentSize + 1 &lt;= array.length) &#123; System.arraycopy(array, index, array, index + 1, currentSize - index); array[index] = element; return array; &#125; //容量不够的话，先扩容，如果currentSize &lt;= 4, 扩容成8, 如果 &gt; 4，则扩容至原先容量的2倍 int[] newArray = ArrayUtils.newUnpaddedIntArray(growSize(currentSize)); System.arraycopy(array, 0, newArray, 0, index); newArray[index] = element; System.arraycopy(array, index, newArray, index + 1, array.length - index); return newArray; &#125; 如果容量够，则直接插入 容量不够的话，先扩容，扩容的size是由growSize函数决定，其原理是如果当前size小于等于4,则固定扩容后的容量是8,如果大于4,则扩容原先容量的两倍，之后拷贝原有数据至新的数组中，最后再根据索引值插入数据 2. get123456789101112131415public E get(int key) &#123; return get(key, null); &#125; public E get(int key, E valueIfKeyNotFound) &#123; //根据key获得索引值 int i = ContainerHelpers.binarySearch(mKeys, mSize, key); //i&lt;0代表没找到， value = DELETED代表这个值已作废，也表明没找到 if (i &lt; 0 || mValues[i] == DELETED) &#123; return valueIfKeyNotFound; &#125; else &#123; return (E) mValues[i]; &#125; &#125; 可以看到，get操作非常简单，首先获得索引值，之后直接从values数组中获取相应的值，不论是获取索引值还是获取value, 都是直接操作数组，所以效率非常高 3. delete1234567891011public void delete(int key) &#123; //获取索引值 int i = ContainerHelpers.binarySearch(mKeys, mSize, key); //将对应索引位置的value设为DELETED if (i &gt;= 0) &#123; if (mValues[i] != DELETED) &#123; mValues[i] = DELETED; mGarbage = true; &#125; &#125; &#125; 和get的操作类似，只不过是获取索引值后，将values数组中对应处的值覆盖为DELETED 性能分析SparseArray内部使用了二分搜索法，如果在数据量比较小的情况下，其查询效率应该是比较高的，但是随着数据量的增大，二分搜索的效率也会呈现性下降，而HashMap内部在获取对应的索引值时，使用的是先计算hash值再通过hash &amp; (length - 1)的形式获取索引值，当数据量较大时这种方式就比较具有优势，加上HashMap内部对hash算法进行了优化，尽可能的减少了hash碰撞，所以如果数据量很大时，HashMap的查询效率并不会比SparseArray差，甚至可能会优于SparseArray, 但是HashMap如果键值是整型时，不可避免的会进行装箱操作，这一点上SparseArray肯定优于HashMap, 综合来看，在一般的使用场景中，很少会用到非常大的数据量，如果键值是整型数据，应当首选SparseArray","tags":[{"name":"Java集合类源码分析","slug":"Java集合类源码分析","permalink":"https://wangyun137.github.io/tags/Java集合类源码分析/"},{"name":"SparseArray","slug":"SparseArray","permalink":"https://wangyun137.github.io/tags/SparseArray/"}]},{"title":"HashSet源码分析","date":"2017-07-24T07:51:52.000Z","path":"2017/07/24/HashSet源码分析/","text":"Set集合的最主要特性就是没有重复元素，HashSet是Set的一个字类，其内部基于HashMap实现 1. 成员变量123private transient HashMap&lt;E,Object&gt; map; private static final Object PRESENT = new Object(); 可以看到HashSet内部有一个HashMap, 但是PRESENT是干什么用的？HashMap是key-value形式的，但是Set是存储的是单一值，那么内部想要借由HashMap来实现的话，就必须有一个固定的value值，即HashSet中存放的每一个值在HashMap中作为key值，对应的value值都固定为PRESENT对象 2. 构造函数123456789101112131415161718192021public HashSet() &#123; map = new HashMap&lt;&gt;();&#125;public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c);&#125;public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;&gt;(initialCapacity, loadFactor);&#125;public HashSet(int initialCapacity) &#123; map = new HashMap&lt;&gt;(initialCapacity);&#125;HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);&#125; 一般起我们最常用的就是空参构造函数，在空参函数中会调用HashMap的空参构造函数， 由HashMap源码分析可以知道，空参构造函数的HashMap初始容量为4 3. 方法3.1 add123public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 在HashMap中，如果key值没有hash碰撞或者在冲突的链表上没有相同的key，HashMap.put会返回null, 否则会返回被替换的旧值，而由于HashSet中，所有key值对应的value都是PRESENT对象，这样就算在HashMap中有相等的key值，更新的也只是PRESENT,并没有在HashMap中插入新的key值，从而保证了HashSet中值的唯一性 3.2 remove123public boolean remove(Object o) &#123; return map.remove(o)==PRESENT;&#125; HashMap.remove如果删除成功，会返回对应的value，如果不存在对应的entry则返回null, 而HashSet中所有key值对应的value固定都是PRESENT 3.3 iterator123public Iterator&lt;E&gt; iterator() &#123; return map.keySet().iterator();&#125;","tags":[{"name":"Java集合类源码分析","slug":"Java集合类源码分析","permalink":"https://wangyun137.github.io/tags/Java集合类源码分析/"},{"name":"HashSet","slug":"HashSet","permalink":"https://wangyun137.github.io/tags/HashSet/"}]},{"title":"HashTable源码分析","date":"2017-07-24T07:49:35.000Z","path":"2017/07/24/HashTable源码分析/","text":"HashTable跟HashMap在功能上来基本类似，其解决hash冲突的方法也是基于链地址法， 唯一的不同点在HashTable的方法是同步的，多线程操作时，在外部无需使用同步机制 源码解读1. 成员变量1234567891011private transient HashtableEntry&lt;K,V&gt;[] table; private transient int count; private int threshold; private float loadFactor; private transient int modCount = 0; HashTable的成员变量跟HashMap的成员变量类似，同样都有loadFactor, modCount, threshold 2. put12345678910111213141516171819202122232425262728293031323334public synchronized V put(K key, V value) &#123; if (value == null) &#123; throw new NullPointerException(); &#125; HashtableEntry tab[] = table; //直接调用key.hashCode() int hash = hash(key); //计算索引值 int index = (hash &amp; 0x7FFFFFFF) % tab.length; //如果已经存在key值相等的entry，用新value替换旧value for (HashtableEntry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; V old = e.value; e.value = value; return old; &#125; &#125; modCount++; if (count &gt;= threshold) &#123; //扩容至之前容量的两倍 rehash(); tab = table; hash = hash(key); index = (hash &amp; 0x7FFFFFFF) % tab.length; &#125; // Creates the new entry. HashtableEntry&lt;K,V&gt; e = tab[index]; tab[index] = new HashtableEntry&lt;&gt;(hash, key, value, e); count++; return null; &#125; HashTable的put逻辑大体上与HashMap的一致，都可以总结为： 计算key值的hash 由hash得出索引 如果已经存在key值相等的entry，用新value替换旧value 递增modCount, 检查是否key-value键值对数量是否达到阈值，如果达到进行扩容操作，扩容至原先容量的两倍 创建Entry, 放入数组 但是HashTable中计算hash值和索引值这两步，跟HashMap有很大区别, HashTable是直接获取了key值得hashCode()返回值，然后用求模的方式计算索引，相比于HashMap来说，不仅效率略低，同时由于HashTable并没有硬性要求容量必须是2的n次方，从而会造成index冲突的几率加大，减慢了查询的效率 另外，可以看到HashTable的put方法增加了synchronized关键字，这就意味着put方法是一个同步方法，相对于HashMap的非同步put方法，其在单线程模型下效率肯定会略低 3. get1234567891011public synchronized V get(Object key) &#123; HashtableEntry tab[] = table; int hash = hash(key); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (HashtableEntry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; return e.value; &#125; &#125; return null; &#125; get方法也是被synchronized修饰 4. 遍历HashTable4.1 HashTable.entrySet12345public Set&lt;Entry&lt;K,V&gt;&gt; entrySet() &#123; if (entrySet==null) entrySet = Collections.synchronizedSet(new EntrySet(), this); return entrySet;&#125; 可以看到，获取entrySet时，调用Collections.synchronizedSet来保证Set是同步的 4.2 EntrySet.iterator1234567891011121314private static final int ENTRIES = 2;public Iterator&lt;Entry&lt;K,V&gt;&gt; iterator() &#123; return getIterator(ENTRIES);&#125;private &lt;T&gt; Iterator&lt;T&gt; getIterator(int type) &#123; if (count == 0) &#123; return Collections.emptyIterator(); &#125; else &#123; return new Enumerator&lt;&gt;(type, true); &#125;&#125; 4.3 Enumerator123456789101112131415161718192021222324252627282930private class Enumerator&lt;T&gt; implements Enumeration&lt;T&gt;, Iterator&lt;T&gt; &#123; HashtableEntry[] table = Hashtable.this.table; ... protected int expectedModCount = modCount; public T next() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); return nextElement(); &#125; public T nextElement() &#123; HashtableEntry&lt;K,V&gt; et = entry; int i = index; HashtableEntry[] t = table; /* Use locals for faster loop iteration */ while (et == null &amp;&amp; i &gt; 0) &#123; et = t[--i]; &#125; entry = et; index = i; if (et != null) &#123; HashtableEntry&lt;K,V&gt; e = lastReturned = entry; entry = e.next; //KEYS代表要获取key的集合， VALUES代表获取value的集合，ENTIRES代表获取entry的集合 return type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e); &#125; throw new NoSuchElementException(\"Hashtable Enumerator\"); &#125;&#125; 可以看到HashTable也同样采用Fast-Fail机制，当使用迭代器遍历时，不可以调用HashTable.remove来删除元素，而是应该用迭代器自身的remove方法","tags":[{"name":"Java集合类源码分析","slug":"Java集合类源码分析","permalink":"https://wangyun137.github.io/tags/Java集合类源码分析/"},{"name":"HashTable","slug":"HashTable","permalink":"https://wangyun137.github.io/tags/HashTable/"}]},{"title":"LinkedHashMap源码分析","date":"2017-07-24T07:48:11.000Z","path":"2017/07/24/LinkedHashMap源码分析/","text":"LinkedHashMap具有以下特性 LinkedHashMap继承自HashMap, 它可以保证迭代的顺序跟插入的顺序是一致的 不是同步的，如果多个线程同时访问，需要从外部保持同步 LinkedHashMap还可以按照访问顺序进行排序，如果是按照访问顺序，那么调用get以后，会将访问的元素移到链表末尾 LinkedHashMap的重要变量123456789101112/** * 双向链表的表头 */ private transient LinkedHashMapEntry&lt;K,V&gt; header; /** * true: 按照访问顺序; false: 按照插入顺序 * * @serial */ private final boolean accessOrder; LinkedHashMap是HashMap的子类，从而继承了HashMap中属性，另外LinkedHashMap自定义了两个变量，这两个变量也就是实现其排序的关键 1. initinit方法会在构造函数中调用，HashMap的init是一个空实现，LinkedHashMap重写了init方法12345@Override void init() &#123; header = new LinkedHashMapEntry&lt;&gt;(-1, null, null, null); header.before = header.after = header; &#125; init方法主要就是初始化了header变量，将header的beafore和after都指向header自身 2. putLinkedHashMap没有重写put方法, 完全还是HashMap.put的逻辑 12345678910111213141516171819202122public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; if (key == null) return putForNullKey(value); int hash = sun.misc.Hashing.singleWordWangJenkinsHash(key); int i = indexFor(hash, table.length); for (HashMapEntry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null; &#125; LinkedHashMap虽然没有重写put方法，但是其重写了两个关键方法recordAccess和addEntry, 其中recordAccess是用来记录访问顺序的方法，即更新当前entry的after,before 2.1 addEntry12345678910111213141516171819void addEntry(int hash, K key, V value, int bucketIndex) &#123; // removeEldestEntry(eldest)固定返回false.. LinkedHashMapEntry&lt;K,V&gt; eldest = header.after; if (eldest != header) &#123; boolean removeEldest; size++; try &#123; removeEldest = removeEldestEntry(eldest); &#125; finally &#123; size--; &#125; if (removeEldest) &#123; removeEntryForKey(eldest.key); &#125; &#125; super.addEntry(hash, key, value, bucketIndex); &#125; 虽然在super.addEntry之前有一段逻辑，但是由于removeEldestEntry方法固定返回false，所以这一段代码执行与否都没有什么影响…, super.addEntry主要是为了执行扩容操作，HashMap.addEntry在扩容后会执行createEntry方法，而LinkedHashMap重写了createEntry方法 2.2 createEntry12345678void createEntry(int hash, K key, V value, int bucketIndex) &#123; HashMapEntry&lt;K,V&gt; old = table[bucketIndex]; LinkedHashMapEntry&lt;K,V&gt; e = new LinkedHashMapEntry&lt;&gt;(hash, key, value, old); table[bucketIndex] = e; //更新链表指针, 【2.3】 e.addBefore(header); size++;&#125; 创建对应的Entry, 如果是要归属到同一个链表内的，将newEntry的next指针指向oldEntry, 将newEntry放置到相应的索引处 更新双向链表指针 2.3 LinkedHashMapEntry.addBefore123456private void addBefore(LinkedHashMapEntry&lt;K,V&gt; existingEntry) &#123; after = existingEntry; before = existingEntry.before; before.after = this; after.before = this;&#125; 下面这张图显示了执行两次put操作后(假设没有hash冲突)的链表指向 3. get1234567public V get(Object key) &#123; LinkedHashMapEntry&lt;K,V&gt; e = (LinkedHashMapEntry&lt;K,V&gt;)getEntry(key); if (e == null) return null; e.recordAccess(this); return e.value; &#125; 3.1 LinkedHashMapEntry.recordAccess123456789101112131415void recordAccess(java.util.HashMap&lt;K,V&gt; m) &#123; LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m; if (lm.accessOrder) &#123; lm.modCount++; //从双向链表中删除当前元素 remove(); //重新将元素添加到链表表头 addBefore(lm.header); &#125; &#125; private void remove() &#123; before.after = after; after.before = before; &#125; 如果是访问顺序进行排序,首先将当前entry从双向链表中删除，之后再重新添当前entry到表头 4.遍历LinkedHashMap的遍历需要注意的事项跟HashMap的一致，不能在使用迭代器遍历的时候调用LinkedHashMap.remove()删除元素，其原理不变，仍然是使用expectedModCount 4.1 LinkedHashIterator.nextEntry1234567891011121314LinkedHashMapEntry&lt;K,V&gt; nextEntry = header.after;LinkedHashMapEntry&lt;K,V&gt; lastReturned = null;Map.Entry&lt;K,V&gt; nextEntry() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); if (nextEntry == header) throw new NoSuchElementException(); LinkedHashMapEntry&lt;K,V&gt; e = lastReturned = nextEntry; nextEntry = e.after; return e;&#125; 可以看到，迭代器迭代时，LinkedHashMap会从双向链表的header处开始向后按顺序遍历","tags":[{"name":"Java集合类源码分析","slug":"Java集合类源码分析","permalink":"https://wangyun137.github.io/tags/Java集合类源码分析/"},{"name":"LinkedHashMap","slug":"LinkedHashMap","permalink":"https://wangyun137.github.io/tags/LinkedHashMap/"}]},{"title":"HashMap源码分析","date":"2017-07-24T07:44:46.000Z","path":"2017/07/24/HashMap源码分析/","text":"HashMap具有以下特点： Hashmap是基于Map的非同步实现，如果多线程修改，必须在外部保持同步 允许使用null值和null键 不保证映射顺序 Hashmap实际上是一个链表散列的数据结构，即数组和链表的结合体 Hashmap底层是一个数组，数组中每一项又是一个链表 默认容量 = 4(必须是2的n次方), 默认加载因子 = 0.75 只有对于HashMap中的Entry有新增或删除的操作，都会更新modCount 假定Hash函数将元素适当的分布在各桶之间，可为基本操作get和put提供稳定的性能，迭代collection视图所需的时间与HashMap实例的容量(桶的数量）及其大小(键值映射关系数)成比例，所以如果迭代性能很重要，则不要将出示容量设置的太高或将加载因子设置的太低 成员变量123456789101112131415161718//默认初始容量为4staic final int DEFAULT_INITIAL_CAPACITY = 4;static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;static final float DEFAULT_LOAD_FACTOR = 0.75f;static final HashMapEntry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;transient HashMapEntry&lt;K,V&gt;[] table = (HashMapEntry&lt;K,V&gt;[]) EMPTY_TABLE;transient int size;int threshold;final float loadFactor = DEFAULT_LOAD_FACTOR;transient int modCount; 构造函数1234567891011121314151617181920212223242526 public HashMap() &#123; //默认容量是4, 加载因子是0.75 this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR); &#125; public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125;public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) &#123; initialCapacity = MAXIMUM_CAPACITY; &#125; else if (initialCapacity &lt; DEFAULT_INITIAL_CAPACITY) &#123; initialCapacity = DEFAULT_INITIAL_CAPACITY; &#125; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); threshold = initialCapacity; init(); &#125; 一般情况下，我们使用HashMap时都会调用空参构造函数，可以看到，空参构造函数的初始容量默认为4 方法1. put1234567891011121314151617181920212223242526272829303132public V put(K key, V value) &#123; //如果table是空，重新初始化table,容量是threshold，如果是空构造函数，threshold就是4 if (table == EMPTY_TABLE) &#123; //【1.1】 inflateTable(threshold); &#125; //如果key是null, 更新相应的Entry, key = null， 则Entry放在table[0] if (key == null) //【1.2】 return putForNullKey(value); //计算hash值， 【1.3】 int hash = sun.misc.Hashing.singleWordWangJenkinsHash(key); //获取hash值对应的index位置， 【1.4】 int i = indexFor(hash, table.length); //如果对应的index位置已经有链表，证明hash冲突，遍历链表 for (HashMapEntry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; //如果链表中某一个entry的key值与传入的key值相等，更新entry对应的value值 if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; //如果没有hash冲突或者在hash冲突的链表中没有相等的key值，更新modCount modCount++; //添加新的Entry， 【1.5】 addEntry(hash, key, value, i); return null;&#125; key = null时，对应的Entry放置在索引0处 如果key值存在了，新的value会替换旧的value，put方法会返回旧value 计算对应的索引值的方法是, 获取key值hash值，然后用hash &amp; table.length - 1, table.length总是2的n次方 对于任意给定对象，只要其hashCode()返回值相同，那么HashMap计算出来的hash值也总相同 1.1 inflateTable12345678910111213141516171819202122232425private void inflateTable(int toSize) &#123; // 保证HashMap的容量是2的n次方 int capacity = roundUpToPowerOf2(toSize); //计算threshold值 float thresholdFloat = capacity * loadFactor; if (thresholdFloat &gt; MAXIMUM_CAPACITY + 1) &#123; thresholdFloat = MAXIMUM_CAPACITY + 1; &#125; threshold = (int) thresholdFloat; table = new HashMapEntry[capacity];&#125;private static int roundUpToPowerOf2(int number) &#123; // assert number &gt;= 0 : \"number must be non-negative\"; int rounded = number &gt;= MAXIMUM_CAPACITY ? MAXIMUM_CAPACITY : (rounded = Integer.highestOneBit(number)) != 0 //Integer.bitCount返回number的二进制补码中1的总数量 ? (Integer.bitCount(number) &gt; 1) ? rounded &lt;&lt; 1 : rounded : 1; return rounded;&#125; HashMap的容量会强制性的圆整到2的n次方，即使在初始化时传入的初始容量不是2的n次方，这样做是为了减少hash碰撞率从而提升空间利用效率 1.2 Hashing.singleWordWangJenkinsHash12345678910public static int singleWordWangJenkinsHash(Object k) &#123; int h = k.hashCode(); h += (h &lt;&lt; 15) ^ 0xffffcd7d; h ^= (h &gt;&gt;&gt; 10); //无符号右移6位 h += (h &lt;&lt; 3); h ^= (h &gt;&gt;&gt; 6);//无符号右移6位,空位以0补齐, 带符号右移是根据最左边的符号位来确定空位补什么，如果符号位是1，则空位补1,符号位是0，空位补0 h += (h &lt;&lt; 2) + (h &lt;&lt; 14); return h ^ (h &gt;&gt;&gt; 16); &#125; 1.3 putForNullKey1234567891011121314private V putForNullKey(V value) &#123; //如果null已经有对应的value,则替换旧value为新value for (HashMapEntry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(0, null, value, 0); return null;&#125; null可以做键值，但是null所对应的value每次只能存一个，如果已存在以null为键值的Entry, 会有新的value替换旧value 1.4 indexFor12345static int indexFor(int h, int length) &#123; //length总是2的n次方时， h &amp; (length - 1)等价于对length取模,h % length return h &amp; (length-1);&#125; 由于pow(2, n)是2的n次方，所以pow(2,n) - 1的二进制必然每一位都是1，这样用hash值同pow(2,n)-1进行位与操作，得到的值得低位与hash值得低位一致 1.5 addEntry1234567891011121314151617void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; //如果key-value键值对数量达到threshold且对应index处有Entry即存在链表, 扩容 resize(2 * table.length); //计算hash值，null键值的hash是0 hash = (null != key) ? sun.misc.Hashing.singleWordWangJenkinsHash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; //创建新的Entry,并放入对应的位置 createEntry(hash, key, value, bucketIndex); &#125; void createEntry(int hash, K key, V value, int bucketIndex) &#123; HashMapEntry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new HashMapEntry&lt;&gt;(hash, key, value, e); size++; &#125; 如果key-value键值对的总和达到threshold且对应的索引处存在链表，进行扩容 创建新的Entry,并放入table中 2. get12345678910 public V get(Object key) &#123; //如果key为null, 获取null对应的value if (key == null) //【2.1】 return getForNullKey();//【2.2】 Entry&lt;K,V&gt; entry = getEntry(key); return null == entry ? null : entry.getValue(); &#125; 2.1 getForNullKey12345678910private V getForNullKey() &#123; if (size == 0) &#123; return null; &#125; for (HashMapEntry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) return e.value; &#125; return null;&#125; 2.2 getEntry1234567891011121314final Entry&lt;K,V&gt; getEntry(Object key) &#123; if (size == 0) &#123; return null; &#125; int hash = (key == null) ? 0 : sun.misc.Hashing.singleWordWangJenkinsHash(key); for (HashMapEntry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null; &#125; 这里吐槽一下：曾经遇到一个面试官问我如果哈希冲突的时候HashMap是通过什么方式获取value的，我很确定的说会遍历链表，然后判断entry的哈希值是否跟key值计算出来的hash值相等同时会判断entry的key值和传入的key是否会相等，然后那个面试官告诉我不对!!!弄得我一脸懵逼，我说就是这样的啊，结果他可能觉得我知错不改，脸色不太好的告诉我回去再好好看看。。。好吧，我现在再一次好好看了，依然不知道我哪里说错了，也许这位大哥可能有自己独特的理解 3. remove123456789101112131415161718192021222324252627282930313233public V remove(Object key) &#123; Entry&lt;K,V&gt; e = removeEntryForKey(key); return (e == null ? null : e.getValue());&#125;final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123; if (size == 0) &#123; return null; &#125; int hash = (key == null) ? 0 : sun.misc.Hashing.singleWordWangJenkinsHash(key); int i = indexFor(hash, table.length); HashMapEntry&lt;K,V&gt; prev = table[i]; HashMapEntry&lt;K,V&gt; e = prev; while (e != null) &#123; HashMapEntry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; modCount++; size--; if (prev == e) table[i] = next; else prev.next = next; e.recordRemoval(this); return e; &#125; prev = e; e = next; &#125; return e;&#125; 删除元素其实也是首先计算has值，之后会根据hash值回去元素的索引值，之后遍历索引位置处的链表，之后再进行entry的比对，如果想等，就会删除这个元素，这里要注意的是之前提到过的一旦HashMap中的元素发生删除或增加的改变时，会增加modCount 4. 遍历HashMap一般遍历HashMap都是通过迭代器来遍历: 1234567 Iterator iter = map.entrySet().iterator(); while (iter.hasNext()) &#123; Map.Entry entry = (Map.Entry) iter.next(); Object key = entry.getKey(); Object val = entry.getValue();&#125; 用迭代器来遍历Hashmap时，不可以调用put或remove这样会更改HashMap中Entry数量的操作，如果调用了，会抛出ConcurrentModificationException，这是因为fast-fail机制，至于具体原因，从下面的代码分析中可以知道 4.1 entrySet12345678public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; return entrySet0();&#125;private Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() &#123; Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet; return es != null ? es : (entrySet = new EntrySet());&#125; 调用entrySet()以后会返回一个EntrySet对象 4.2 EntrySet.iterator1234567public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return newEntryIterator();&#125; Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator() &#123; return new EntryIterator();&#125; EntryIterator继承自HashIterator, EntryIterator.next实际调用的是其父类HashIterator.nextEntry() 4.3 HashIterator构造函数1234567891011121314151617private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123; HashMapEntry&lt;K,V&gt; next; // next entry to return int expectedModCount; // For fast-fail int index; // current slot HashMapEntry&lt;K,V&gt; current; // current entry HashIterator() &#123; expectedModCount = modCount; if (size &gt; 0) &#123; // advance to first entry HashMapEntry[] t = table; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125; &#125; ... &#125; 在HashIterator中有一个很重要的变量expectedModCount, 可以看到在构造函数中将它的值摄为了HashMap.modCount，这就意味着HashIterator对象一旦创建，expectedModCount值就是固定的，如果在用迭代器遍历HashMap时进行put或remove，那么modCount值必然会和expectedModCount不相等，一旦不相等，就会抛出ConcurrentModificationException 4.4 HashIterator.nextEntry12345678910111213141516final Entry&lt;K,V&gt; nextEntry() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); HashMapEntry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); if ((next = e.next) == null) &#123; HashMapEntry[] t = table; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125; current = e; return e; &#125; 可以看到，正如之前所说，当expectedModCount != modCount时，会抛出ConcurrentModificationException, 那如果想在遍历的时候也可以进行删除操作，应该通过什么方法呢？答案是通过Iterator.remove 4.5 HashIterator.remove123456789101112public void remove() &#123; if (current == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); Object k = current.key; current = null; HashMap.this.removeEntryForKey(k); expectedModCount = modCount; &#125; 由于HashIterator是HashMap的内部类，所以可以调用HashMap的内部方法removeEntryForKey，当删除完entry后，会更新expectedModCount,这样在进行下一次的next()调用时， expectedModCount就会与modCount保持一致 5. 遍历key和遍历value如果通过迭代器遍历key和遍历value时的注意事项跟用迭代器遍历HashMap的注意事项一样，也是不可以在遍历时调用remove方法，原理也是一样的，内部有一个expectedModCount，如果要删除要掉用迭代器的remove方法 6. Java8新特性在Java8中新增了forEach方法，接收一个BiConsumere&lt;? super K, ? super V&gt;参数，这个参数是一个函数式接口，所谓函数式接口是指接口只有一个待实现的方法(Java8中，接口可以有默认的实现), 函数式接口可以用lambda表达式来代替, BiConsumer&lt;K, V&gt;的lambda表达式原型是(K, V) - Void, 即传入K,V, 返回Void 参考HashMap的实现原理","tags":[{"name":"Java集合类源码分析","slug":"Java集合类源码分析","permalink":"https://wangyun137.github.io/tags/Java集合类源码分析/"},{"name":"HashMap","slug":"HashMap","permalink":"https://wangyun137.github.io/tags/HashMap/"}]},{"title":"Retrofit学习(三)","date":"2017-07-24T07:41:55.000Z","path":"2017/07/24/Retrofit学习-三/","text":"目前比较流行的使用Retrofit的方法是Retrofit + RxJava + Gson, 之前的Retrofit学习(二)已经分析过Retrofit是如何结合RxJava，这一篇主要看一下同Gson的结合 要想在Retrofit中使用Gson, 需要添加Gson对应的Converter:12345678OkHttpclient client = new OkHttpClient.Builder().build();Retrofit retrofit = new Retrofit.Builder() .client(client) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) //添加Gson .addConverterFactory(GsonConverterFactory.create()) .baseUrl(\"http://localhost:4567/\") .build(); GsonConverterFactory12345678910111213141516171819202122232425262728293031public final class GsonConverterFactory extends Converter.Factory &#123; public static GsonConverterFactory create() &#123; return create(new Gson()); &#125; public static GsonConverterFactory create(Gson gson) &#123; return new GsonConverterFactory(gson); &#125; private final Gson gson; private GsonConverterFactory(Gson gson) &#123; if (gson == null) throw new NullPointerException(\"gson == null\"); this.gson = gson; &#125; @Override public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123; TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type)); return new GsonResponseBodyConverter&lt;&gt;(gson, adapter); &#125; @Override public Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123; TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type)); return new GsonRequestBodyConverter&lt;&gt;(gson, adapter); &#125;&#125; 从之前的Retrofit学习(一)中我们可以知道，每次调用接口方法时都会通过ServiceMethod.Builder.build()创建一个ServiceMethod对象, ServiceMethod.Builder.build()会初始化responseConverter, 经过一系列调用最终会调用Converter.Factory.responseBodyConverter，如果在初始化Retrofit时添加了GsonConverterFactory，则会相应地调用GsonConverterFactory.responseBodyConverter GsonConverterFactory.responseBodyConverter1234public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations,Retrofit retrofit) &#123; TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type)); return new GsonResponseBodyConverter&lt;&gt;(gson, adapter); &#125; 从之前的Retrofit学习(一)和Retrofit学习(二)可以知道，最终的步骤都会是OkHttpCall.execute或OkHttpCall.enqueue，不论是enqueue还是execute,都会调用OkHttpCall.parseResponse方法，该方法最主要的作用是从okhttp3.Response中得到okhttp3.ResponseBody，之后调用ServiceMethod.toResponse ServiceMethod.toResponse123R toResponse(ResponseBody body) throws IOException &#123; return responseConverter.convert(body);&#125; 调用Converter.convert转换结果，这里的Convert就是GsonResponseBodyConverter GsonResponseBodyConverter.convert12345678public T convert(ResponseBody value) throws IOException &#123; JsonReader jsonReader = gson.newJsonReader(value.charStream()); try &#123; return adapter.read(jsonReader); &#125; finally &#123; value.close(); &#125; &#125;","tags":[{"name":"Retrofit","slug":"Retrofit","permalink":"https://wangyun137.github.io/tags/Retrofit/"},{"name":"开源项目学习","slug":"开源项目学习","permalink":"https://wangyun137.github.io/tags/开源项目学习/"}]},{"title":"Retrofit学习(二)","date":"2017-07-24T07:22:11.000Z","path":"2017/07/24/Retrofit学习-二/","text":"之前的Retrofit学习(一)了解了一下Retrofit的最基本使用，不过目前最流行的Retrofit使用方式是Retrofit + RxJava + Gson, 如果要使用RxJava, 需要在创建Retrofit时配置RxJava对应的CallAdapter: 123456OkHttpclient client = new OkHttpClient.Builder().build();Retrofit retrofit = new Retrofit.Builder() .client(client) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .baseUrl(\"http://localhost:4567/\") .build(); 下面就主要分析一下RxJava2CallAdapterFactory是如何工作的 RxJava2CallAdapterFactory1234567891011121314151617181920public static RxJava2CallAdapterFactory create() &#123; return new RxJava2CallAdapterFactory(null, false);&#125;public static RxJava2CallAdapterFactory createAsync() &#123; return new RxJava2CallAdapterFactory(null, true);&#125;public static RxJava2CallAdapterFactory createWithScheduler(Scheduler scheduler) &#123; if (scheduler == null) throw new NullPointerException(\"scheduler == null\"); return new RxJava2CallAdapterFactory(scheduler, false);&#125;private final Scheduler scheduler;private final boolean isAsync;private RxJava2CallAdapterFactory(Scheduler scheduler, boolean isAsync) &#123; this.scheduler = scheduler; this.isAsync = isAsync;&#125; RxJava2CallAdapterFactory提供了三个create系列方法，一般情况下，最常使用的是第一个没有参数的create方法，即不指定Scheduler，isAsync = false, isAsync指明是调用Call.execute还是Call.enqueue RxJava2CallAdapterFactory.get123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123; Class&lt;?&gt; rawType = getRawType(returnType); if (rawType == Completable.class) &#123; return new RxJava2CallAdapter(Void.class, scheduler, isAsync, false, true, false, false, false, true); &#125; boolean isFlowable = rawType == Flowable.class; boolean isSingle = rawType == Single.class; boolean isMaybe = rawType == Maybe.class; //确保返回值是Observable, Flowable, Single, Maybe if (rawType != Observable.class &amp;&amp; !isFlowable &amp;&amp; !isSingle &amp;&amp; !isMaybe) &#123; return null; &#125; boolean isResult = false; boolean isBody = false; Type responseType; //ParameterizedType指泛型类型，如List&lt;T&gt; if (!(returnType instanceof ParameterizedType)) &#123; String name = isFlowable ? \"Flowable\" : isSingle ? \"Single\" : isMaybe ? \"Maybe\" : \"Observable\"; throw new IllegalStateException(...); &#125; //获取返回值的泛型参数 Type observableType = getParameterUpperBound(0, (ParameterizedType) returnType); Class&lt;?&gt; rawObservableType = getRawType(observableType); if (rawObservableType == Response.class) &#123; //如果泛型参数是Response, 且Response没有泛型参数,抛出异常，Response必须是以泛型形式使用 if (!(observableType instanceof ParameterizedType)) &#123; throw new IllegalStateException(...); &#125; //获取Response&lt;T&gt;中的T responseType = getParameterUpperBound(0, (ParameterizedType) observableType); &#125; else if (rawObservableType == Result.class) &#123; //如果泛型参数是Result, 且Result没有泛型参数， 抛出异常，Result必须是以泛型形式使用 if (!(observableType instanceof ParameterizedType)) &#123; throw new IllegalStateException(...); &#125; //获取Result&lt;T&gt;中的T responseType = getParameterUpperBound(0, (ParameterizedType) observableType); isResult = true; &#125; else &#123; responseType = observableType; isBody = true; &#125; return new RxJava2CallAdapter(responseType, scheduler, isAsync, isResult, isBody, isFlowable, isSingle, isMaybe, false);&#125;`` 如果返回值类型是Completable， 直接返回一个RxJava2CallAdapter指定其中的isBody = true, isCompletable = true 确保方法的返回值Observable, Flowable, Single, Maybe, 否则返回null, 如果是null, 则根据之前的分析，如果CallAdapter.Factory.get()返回null, 在Retrofit.nextCallAdapter中会抛出异常(Retrofit默认有一个ExecutorCallAdapterFactory, 但如果方法返回值不是Call类型，其get()方法会直接返回null) 如果返回值不是泛型，抛出异常 获取返回值中的泛型参数的类型，假设返回值类型Observable&lt;Bean&gt;, 这里获取到的泛型参数类型就是Bean 如果泛型参数的类型是retrofit2.Response或retrofit2.Result，确保Response和Result也是以泛型的形式声明的，即返回值类型是Observable&lt;Response&lt;T&gt;&gt;或Observable&lt;Result&lt;T&gt;&gt;；Retrofit + RxJava2最常见的的用法是Observable&lt;Bean&gt; getName(...), 一般都会直接使用自定义的Bean类， 所以一般情况下， isBody = true 返回RxJava2CallAdapter RxJava2CallAdapter.adapt1234567891011121314151617181920212223242526272829303132333435public Object adapt(Call&lt;R&gt; call) &#123; //call是OkHttpCall, 将R转换为Response&lt;R&gt; Observable&lt;Response&lt;R&gt;&gt; responseObservable = isAsync ? new CallEnqueueObservable&lt;&gt;(call) : new CallExecuteObservable&lt;&gt;(call); Observable&lt;?&gt; observable; if (isResult) &#123; observable = new ResultObservable&lt;&gt;(responseObservable); &#125; else if (isBody) &#123; //将Response&lt;T&gt;转换为T observable = new BodyObservable&lt;&gt;(responseObservable); &#125; else &#123; observable = responseObservable; &#125; if (scheduler != null) &#123; observable = observable.subscribeOn(scheduler); &#125; if (isFlowable) &#123; return observable.toFlowable(BackpressureStrategy.LATEST); &#125; if (isSingle) &#123; return observable.singleOrError(); &#125; if (isMaybe) &#123; return observable.singleElement(); &#125; if (isCompletable) &#123; return observable.ignoreElements(); &#125; return observable;&#125; 首先生成一个Obsersavle&lt;Response&lt;R&gt;&gt;, 这里会根据isAsync是否为tru,来确定是生成CallEnqueueObservable还是CallExecuteObservable，这两者的区别在于前者最终实际是调用OkHttpCall.enqueue方法，后者实际调用了OkHttpCall.execute方法， 前者异步执行，后者同步执行 Retrofit + RxJava2最常见的的用法是Observable&lt;Bean&gt; getName(...), 一般都会直接使用自定义的Bean类， 根据之前的分析可以知道，一般情况下，由于开发者都直接使用自己的Bean, 所以isBody = true， 会创建一个BodyObservable 之后会根据方法返回值是否是Flowable, Single, Maybe, Completable其中一种来做出具体的转换 BodyObservable1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253final class BodyObservable&lt;T&gt; extends Observable&lt;T&gt; &#123; private final Observable&lt;Response&lt;T&gt;&gt; upstream; BodyObservable(Observable&lt;Response&lt;T&gt;&gt; upstream) &#123; this.upstream = upstream; &#125; @Override protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; //upstream是CallExecuteObservable或CallEnqueueObservable, BodyObserver是一个代理 //作用就是把Response&lt;T&gt;转换为T upstream.subscribe(new BodyObserver&lt;T&gt;(observer)); &#125; private static class BodyObserver&lt;R&gt; implements Observer&lt;Response&lt;R&gt;&gt; &#123; private final Observer&lt;? super R&gt; observer; private boolean terminated; BodyObserver(Observer&lt;? super R&gt; observer) &#123; this.observer = observer; &#125; @Override public void onSubscribe(Disposable disposable) &#123; observer.onSubscribe(disposable); &#125; @Override public void onNext(Response&lt;R&gt; response) &#123; if (response.isSuccessful()) &#123; observer.onNext(response.body()); &#125; else &#123; ... &#125; &#125; &#125; @Override public void onComplete() &#123; if (!terminated) &#123; observer.onComplete(); &#125; &#125; @Override public void onError(Throwable throwable) &#123; if (!terminated) &#123; observer.onError(throwable); &#125; else &#123; ... &#125; &#125; &#125;&#125; 这里upstream是CallExecutorObservable或CallEnqueueObservable，一般情况下，这里会是CallExecutorObservable；在subscribeActual中可以看到，在传入的observer外又包装了一个BodyObserver, 传入的observer就是开发者传入的自定义Observer CallExecutorObservable12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849final class CallExecuteObservable&lt;T&gt; extends Observable&lt;Response&lt;T&gt;&gt; &#123; private final Call&lt;T&gt; originalCall; CallExecuteObservable(Call&lt;T&gt; originalCall) &#123; this.originalCall = originalCall; &#125; @Override protected void subscribeActual(Observer&lt;? super Response&lt;T&gt;&gt; observer) &#123; //originalCall是OkHttpCall Call&lt;T&gt; call = originalCall.clone(); observer.onSubscribe(new CallDisposable(call)); boolean terminated = false; try &#123; //call.execute会调用OkHttpCall.execute(), 从而得到okhttp3.Response //再从okhttp3.Response中得到okhttp3.ResponseBody, 然后调用 Converter.convert转换结果，最后将接过封装为retrofit.Response Response&lt;T&gt; response = call.execute(); if (!call.isCanceled()) &#123; //BodyObserver.onNext -&gt; 自定义Onserver.onNext observer.onNext(response); &#125; if (!call.isCanceled()) &#123; terminated = true; observer.onComplete(); &#125; &#125; catch (Throwable t) &#123; ... &#125; &#125; private static final class CallDisposable implements Disposable &#123; private final Call&lt;?&gt; call; CallDisposable(Call&lt;?&gt; call) &#123; this.call = call; &#125; @Override public void dispose() &#123; call.cancel(); &#125; @Override public boolean isDisposed() &#123; return call.isCanceled(); &#125; &#125;&#125; originalCall是OkHttpCall, 可以看到在subscribeActual中会调用call.execute即调用OkHttpCall.execute来从而得到okhttp3.Response, 再从okhttp3.Response中得到okhttp3.ResponseBody, 然后调用 Converter.convert转换结果，最后将结果封装为retrofit.Response, subscribeActual的参数observer是BodyObserver, 而从之前的分析中可以看到BodyObserver的各方法会再调用开发人员自定义的Observer的响应方法 这里看似比较抽象的一系列操作，是为了获得一个统一的结果， 一般开发人员在定义请求方法时,都会使用Observable&lt;Bean&gt;这种方式，即直接将Observable&lt;T&gt;中的T设为自定义Bean, 但不同场景下肯定会定义不同的类型Bean, Retrofit不可能预先知道开发人员会定义那些Bean, 为了得到一个统一的结果，先将Bean转换为Reponse&lt;T&gt;,这样无论T是哪种类型，都可以得到一个统一的结果，之后再通过Response.body()将Response转换为自定义Bean","tags":[{"name":"Retrofit","slug":"Retrofit","permalink":"https://wangyun137.github.io/tags/Retrofit/"},{"name":"开源项目学习","slug":"开源项目学习","permalink":"https://wangyun137.github.io/tags/开源项目学习/"}]},{"title":"Retrofit学习(一)","date":"2017-07-24T07:18:55.000Z","path":"2017/07/24/Retrofit学习-一/","text":"一. 使用用例123456789101112131415161718//步骤【1】OkHttpclient client = new OkHttpClient.Builder().build();Retrofit retrofit = new Retrofit.Builder() .client(client) .baseUrl(\"http://localhost:4567/\") .build(); @GET(\"/getName\") Call&lt;ResponseBody&gt; request(@Query(\"name\") String name); //步骤【2】 IService service = retrofit.create(IService.class); Call&lt;ResponseBody&gt; call = service.request(\"test\"); //步骤【3】 call.enqueue(new Callable() &#123; ... ) 二. 源码解析1. Retrofit.Build1234567891011121314151617181920212223242526272829303132333435363738 //一般情况下，Platform是Android public Builder() &#123; this(Platform.get()); &#125; Builder(Platform platform) &#123; this.platform = platform; converterFactories.add(new BuiltInConverters()); &#125; public Retrofit build() &#123; if (baseUrl == null) &#123; throw new IllegalStateException(\"Base URL required.\"); &#125; okhttp3.Call.Factory callFactory = this.callFactory; if (callFactory == null) &#123; callFactory = new OkHttpClient(); &#125; Executor callbackExecutor = this.callbackExecutor; //如果是Android平台，则Executor的实际逻辑就是在当前主线程中runnable if (callbackExecutor == null) &#123; callbackExecutor = platform.defaultCallbackExecutor(); &#125; List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories); //如果是Android平台，defaultCallAdapterFactory是ExecutorCallAdapterFactory adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor)); //如果没设置，默认没有convert List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(this.converterFactories); //validateEagerly默认为false return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories, callbackExecutor, validateEagerly);&#125; 如果没有设置CallAdapter,对于Android平台，默认使用ExecutorCallAdapterFactory 如果没有设置ConvertFactory, 默认使用BuiltInConverters 2. Retrofit.create123456789101112131415161718192021222324252627282930public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; //校验传入的Class是不是Interface,且定义了至少一个方法 Utils.validateServiceInterface(service); if (validateEagerly) &#123; //如果是Android平台，isDefaultMethod = false, 将service中所有method都生成对应的 //ServiceMethod类，并放入缓存(核心调用为【2.1】loadServiceMethod) eagerlyValidateMethods(service); &#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[]&#123;service&#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; //Android平台isDefaultMethod = false if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;); &#125; 首先校验传入的Class是不是一个接口 因为默认的validateEagly = false, 所以不执行eagerlyValidateMethods方法，该方法实质上根据接口中的所有方法生成每个方法相应的ServiceMethod，并放入缓存 创建动态代理(核心步骤)，以后每次调用接口的方法都会调用InvocationHandler.invoke(…)方法 2.1 Retrofit.loadServiceMethod123456789101112131415ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) &#123; ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method); if (result != null) return result; synchronized (serviceMethodCache) &#123; result = serviceMethodCache.get(method); if (result == null) &#123; //【2.2】 result = new ServiceMethod.Builder&lt;&gt;(this, method).build(); serviceMethodCache.put(method, result); &#125; &#125; return result;&#125; 创建相应的ServiceMethod类，并放入缓存 2.2 ServiceMethod.Builder12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576Builder(Retrofit retrofit, Method method) &#123; this.retrofit = retrofit; this.method = method; this.methodAnnotations = method.getAnnotations(); this.parameterTypes = method.getGenericParameterTypes(); this.parameterAnnotationsArray = method.getParameterAnnotations();&#125;public ServiceMethod build() &#123; //获取CallAdapter, 【2.2.1】 callAdapter = createCallAdapter(); //获取Call&lt;T&gt;中T的具体类型 responseType = callAdapter.responseType(); //确保T并不是retrofit2.Response或者okhttp3.Response if (responseType == Response.class||responseType == okhttp3.Response.class) &#123; ... &#125; //如果没有设置Converter,默认的Converter是BuiltInConverter, 通过 //BuiltInConvert.responseBodyConverter返回Convert, //如果Annotation中Streaming, 则返回StreamingResponseBodyConverter， //否则返回BufferingResponseBodyConverter //【2.2.2】 responseConverter = createResponseConverter(); //处理方法的注释, 【2.2.3】 for (Annotation annotation : methodAnnotations) &#123; parseMethodAnnotation(annotation); &#125; if (httpMethod == null) &#123; throw methodError(...); &#125; //对于GET，HEAD等没有body的请求，不允许出现@FormEncodedUrl或@MultiPart等注释 if (!hasBody) &#123; if (isMultipart) &#123; throw methodError(..); &#125; if (isFormEncoded) &#123; throw methodError(...); &#125; &#125; //处理参数的注解, 【2.2.4】 int parameterCount = parameterAnnotationsArray.length; parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount]; for (int p = 0; p &lt; parameterCount; p++) &#123; Type parameterType = parameterTypes[p]; if (Utils.hasUnresolvableType(parameterType)) &#123; throw parameterError(...); &#125; Annotation[] parameterAnnotations = parameterAnnotationsArray[p]; if (parameterAnnotations == null) &#123; throw parameterError(...); &#125; parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations); &#125; if (relativeUrl == null &amp;&amp; !gotUrl) &#123; throw methodError(...); &#125; //GET, DELETE等方法不可以有@Body if (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) &#123; throw methodError(...); &#125; //有@FormUrlEncoded注释则参数中至少有一个@Field注释 if (isFormEncoded &amp;&amp; !gotField) &#123; throw methodError(...); &#125; //有@Multipart注释，参数中至少有一个@Part注释 if (isMultipart &amp;&amp; !gotPart) &#123; throw methodError(...); &#125; return new ServiceMethod&lt;&gt;(this); &#125; 获取CallAdapter 获取Call中T的具体类型，并确保T并不是retrofit2.Reponse或okhttp3.Response 获取Converter 处理方法注释 注释参数注释 2.2.1 ServiceMethod.createCallAdapter1234567891011121314151617private CallAdapter&lt;T, R&gt; createCallAdapter() &#123; Type returnType = method.getGenericReturnType(); //返回值不能是TypeVariable和WildcardType if (Utils.hasUnresolvableType(returnType)) &#123; throw methodError(...); &#125; //确保返回值不能是void if (returnType == void.class) &#123; throw methodError(...); &#125; Annotation[] annotations = method.getAnnotations(); try &#123; return (CallAdapter&lt;T, R&gt;) retrofit.callAdapter(returnType, annotations); &#125; catch (RuntimeException e) &#123; throw methodError(...); &#125;&#125; 2.2.1.1 Retrofit.callAdapter12345678910111213141516171819202122public CallAdapter&lt;?, ?&gt; callAdapter(Type returnType, Annotation[] annotations) &#123; return nextCallAdapter(null, returnType, annotations);&#125;public CallAdapter&lt;?, ?&gt; nextCallAdapter(CallAdapter.Factory skipPast, Type returnType, Annotation[] annotations) &#123; checkNotNull(returnType, \"returnType == null\"); checkNotNull(annotations, \"annotations == null\"); int start = adapterFactories.indexOf(skipPast) + 1; for (int i = start, count = adapterFactories.size(); i &lt; count; i++) &#123; //如果没有显示的设置，Android平台的默认只有一个CallAdapter.Factory -&gt; ExecutorCallAdapterFactory CallAdapter&lt;?, ?&gt; adapter = adapterFactories.get(i).get(returnType, annotations, this); if (adapter != null) &#123; return adapter; &#125; &#125; ... throw new IllegalArgumentException(...);&#125; 2.2.1.2 ExecutorCallAdapterFactory.get()123456789101112131415161718192021@Overridepublic CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123; //确保返回值类型是Call if (getRawType(returnType) != Call.class) &#123; return null; &#125; //返回Call&lt;T&gt;的具体所指的类型 final Type responseType = Utils.getCallResponseType(returnType); return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123; @Override public Type responseType() &#123; return responseType; &#125; @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123; return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call); &#125; &#125;;&#125; 2.2.2 ServiceMethod.createResponseConverter()123456789private Converter&lt;ResponseBody, T&gt; createResponseConverter() &#123; Annotation[] annotations = method.getAnnotations(); try &#123; return retrofit.responseBodyConverter(responseType, annotations); &#125; catch (RuntimeException e) &#123; throw methodError(...); &#125; &#125; 2.2.2.1 Retrofit.responseBodyConverter1234567891011121314151617181920212223public &lt;T&gt; Converter&lt;ResponseBody, T&gt; responseBodyConverter(Type type, Annotation[] annotations) &#123; return nextResponseBodyConverter(null, type, annotations); &#125; public &lt;T&gt; Converter&lt;ResponseBody, T&gt; nextResponseBodyConverter(Converter.Factory skipPast,Type type, Annotation[] annotations) &#123; checkNotNull(type, \"type == null\"); checkNotNull(annotations, \"annotations == null\"); int start = converterFactories.indexOf(skipPast) + 1; for (int i = start, count = converterFactories.size(); i &lt; count; i++) &#123; //如果没有显示设置， convertFactories里面只有BuiltInConverters Converter&lt;ResponseBody, ?&gt; converter = converterFactories.get(i).responseBodyConverter(type, annotations, this); if (converter != null) &#123; return (Converter&lt;ResponseBody, T&gt;) converter; &#125; &#125; ... throw new IllegalArgumentException(...); &#125; 2.2.2.2 BuiltInConverters.responseBodyConverter1234567891011121314@Override public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123; if (type == ResponseBody.class) &#123; return Utils.isAnnotationPresent(annotations, Streaming.class) ? StreamingResponseBodyConverter.INSTANCE : BufferingResponseBodyConverter.INSTANCE; &#125; if (type == Void.class) &#123; return VoidResponseBodyConverter.INSTANCE; &#125; return null; &#125; 2.2.3 ServiceMethod.parseMethodAnnotation1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void parseMethodAnnotation(Annotation annotation) &#123; if (annotation instanceof DELETE) &#123; parseHttpMethodAndPath(\"DELETE\", ((DELETE) annotation).value(), false); &#125; else if (annotation instanceof GET) &#123; parseHttpMethodAndPath(\"GET\", ((GET) annotation).value(), false); &#125; else if (annotation instanceof HEAD) &#123; parseHttpMethodAndPath(\"HEAD\", ((HEAD) annotation).value(), false); if (!Void.class.equals(responseType)) &#123; throw methodError(\"HEAD method must use Void as response type.\"); &#125; &#125; else if (annotation instanceof PATCH) &#123; parseHttpMethodAndPath(\"PATCH\", ((PATCH) annotation).value(), true); &#125; else if (annotation instanceof POST) &#123; parseHttpMethodAndPath(\"POST\", ((POST) annotation).value(), true); &#125; else if (annotation instanceof PUT) &#123; parseHttpMethodAndPath(\"PUT\", ((PUT) annotation).value(), true); &#125; else if (annotation instanceof OPTIONS) &#123; parseHttpMethodAndPath(\"OPTIONS\", ((OPTIONS) annotation).value(), false); &#125; else if (annotation instanceof HTTP) &#123; HTTP http = (HTTP) annotation; parseHttpMethodAndPath(http.method(), http.path(), http.hasBody()); &#125; else if (annotation instanceof retrofit2.http.Headers) &#123; String[] headersToParse = ((retrofit2.http.Headers) annotation).value(); if (headersToParse.length == 0) &#123; throw methodError(\"@Headers annotation is empty.\"); &#125; headers = parseHeaders(headersToParse); &#125; else if (annotation instanceof Multipart) &#123; if (isFormEncoded) &#123; throw methodError(\"Only one encoding annotation is allowed.\"); &#125; isMultipart = true; &#125; else if (annotation instanceof FormUrlEncoded) &#123; if (isMultipart) &#123; throw methodError(\"Only one encoding annotation is allowed.\"); &#125; isFormEncoded = true; &#125; &#125; parseMethodAnnotation方法主要就是用过parseHttpMethodAndPath方法设置ServiceMethhod的请求方法，相对Url, 是否有body等选项 2.2.4 ServiceMethod.parseParameter1234567891011121314151617181920private ParameterHandler&lt;?&gt; parseParameter(int p, Type parameterType, Annotation[] annotations) &#123; ParameterHandler&lt;?&gt; result = null; for (Annotation annotation : annotations) &#123; //核心调用 ParameterHandler&lt;?&gt; annotationAction = parseParameterAnnotation( p, parameterType, annotations, annotation); if (annotationAction == null) &#123; continue; &#125; if (result != null) &#123; throw parameterError(...); &#125; result = annotationAction; &#125; if (result == null) &#123; throw parameterError(p, \"No Retrofit annotation found.\"); &#125; return result;&#125; 该方法中的核心调用parseParameterAnnotation,这个方法的主要作用是根据参数的注解进行不同的处理，参数的注解可以是以下几种: @Url @Path @Query @QueryName @QueryMap @Header @HeaderMap @Field @FieldMap @Part @PartMap @Body 2.3 ServiceMethod.callAdapter.adapterServiceMethod.callAdapter是通过ExcecutorAdapterFactory.get()创建的一个匿名CallAdapter, 其实现为: 123456789101112131415161718new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123; @Override public Type responseType() &#123; return responseType; &#125; @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123; return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call); &#125; &#125;; static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123; final Executor callbackExecutor; final Call&lt;T&gt; delegate; .... &#125; 由此可以看出，最终真正返回的是ExecutorCallbackCall, 其中delagate是OkHttpCall 3. ExecutorCallbackCall.enqueue123456789101112131415161718192021222324252627282930@Override public void enqueue(final Callback&lt;T&gt; callback) &#123; if (callback == null) throw new NullPointerException(\"callback == null\"); //实际是调用OkHttpCall.enqueue delegate.enqueue(new Callback&lt;T&gt;() &#123; @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123; callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; if (delegate.isCanceled()) &#123; callback.onFailure(ExecutorCallbackCall.this, new IOException(\"Canceled\")); &#125; else &#123; callback.onResponse(ExecutorCallbackCall.this, response); &#125; &#125; &#125;); &#125; @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123; callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; callback.onFailure(ExecutorCallbackCall.this, t); &#125; &#125;); &#125; &#125;); &#125; 可以看到实际调用的是OkHttpCall.enqueue 3.1 OkHttpCall.enqueue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374@Override public void enqueue(final Callback&lt;T&gt; callback) &#123; if (callback == null) throw new NullPointerException(\"callback == null\"); okhttp3.Call call; Throwable failure; synchronized (this) &#123; if (executed) throw new IllegalStateException(\"Already executed.\"); executed = true; call = rawCall; failure = creationFailure; if (call == null &amp;&amp; failure == null) &#123; try &#123; //【3.1.1】 call = rawCall = createRawCall(); &#125; catch (Throwable t) &#123; failure = creationFailure = t; &#125; &#125; &#125; if (failure != null) &#123; callback.onFailure(this, failure); return; &#125; if (canceled) &#123; call.cancel(); &#125; //调用okhttp3.Call.enqueue,后续走的就是okhttp请求的流程 call.enqueue(new okhttp3.Callback() &#123; @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) throws IOException &#123; Response&lt;T&gt; response; try &#123; //【3.1.2】 response = parseResponse(rawResponse); &#125; catch (Throwable e) &#123; callFailure(e); return; &#125; callSuccess(response); &#125; @Override public void onFailure(okhttp3.Call call, IOException e) &#123; try &#123; callback.onFailure(OkHttpCall.this, e); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; private void callFailure(Throwable e) &#123; try &#123; callback.onFailure(OkHttpCall.this, e); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; private void callSuccess(Response&lt;T&gt; response) &#123; try &#123; callback.onResponse(OkHttpCall.this, response); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; &#125;); &#125; 3.1.1 OkHttpCall.createNewCall12345678910private okhttp3.Call createRawCall() throws IOException &#123; //这里的args就是被动态代理的方法的参数, 【3.1.2.1】 Request request = serviceMethod.toRequest(args); //callFactory是OkHttpClient okhttp3.Call call = serviceMethod.callFactory.newCall(request); if (call == null) &#123; throw new NullPointerException(\"Call.Factory returned null.\"); &#125; return call;&#125; OkHttpClient同样实现了okhttp3.Call.Factory接口， 而通过步骤【1】和【2.2】的代码可以看出, 这里的callFactory就是OkHttpClient,所以调用的是OkhttpClient.newCall(实际返回一个okhttp3.RealCall) 3.1.1.1 ServiceMethod.toRequest1234567891011121314151617181920Request toRequest(Object... args) throws IOException &#123; RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers, contentType, hasBody, isFormEncoded, isMultipart); ParameterHandler&lt;Object&gt;[] handlers = (ParameterHandler&lt;Object&gt;[]) parameterHandlers; int argumentCount = args != null ? args.length : 0; if (argumentCount != handlers.length) &#123; throw new IllegalArgumentException(\"Argument count (\" + argumentCount + \") doesn't match expected count (\" + handlers.length + \")\"); &#125; for (int p = 0; p &lt; argumentCount; p++) &#123; //不同参数的注释有对应不同的handler, 以Query为例，其handler是Query&lt;T&gt; handlers[p].apply(requestBuilder, args[p]); &#125; return requestBuilder.build(); &#125; 这个方法的核心调用在于handlers[p].apply,不同的参数注释，对应这不同的ParameterHandler,以@Query为例，它所对应的ParammeterHandler是Query&lt;T&gt;, Query&lt;T&gt;.apply的作用是将@Query所修饰的参数转为String类型并添加到要请求的url的query string中 3.1.2 OkHttpCall.parseResponse12345678910111213141516171819202122232425262728293031323334353637Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123; ResponseBody rawBody = rawResponse.body(); // Remove the body's source (the only stateful object) so we can pass the response along. rawResponse = rawResponse.newBuilder() .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength())) .build(); int code = rawResponse.code(); if (code &lt; 200 || code &gt;= 300) &#123; try &#123; // Buffer the entire body to avoid future I/O. ResponseBody bufferedBody = Utils.buffer(rawBody); return Response.error(bufferedBody, rawResponse); &#125; finally &#123; rawBody.close(); &#125; &#125; if (code == 204 || code == 205) &#123; rawBody.close(); return Response.success(null, rawResponse); &#125; ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody); try &#123; T body = serviceMethod.toResponse(catchingBody); return Response.success(body, rawResponse); &#125; catch (RuntimeException e) &#123; // If the underlying source threw an exception, propagate that rather than indicating it was // a runtime exception. catchingBody.throwIfCaught(); throw e; &#125; &#125;` 3.1.3 ServiceMethod.toResponse123R toResponse(ResponseBody body) throws IOException &#123; return responseConverter.convert(body);&#125; 在之前【2.2.2】中可以得知， 如果没有设置Converter，则使用默认的BuiltInConverter来获取对应的response convert, 如果方法中有@Streaming注释，则responseConverter是StreamingResponseBodyConverter, 否则是BufferingResponseBodyConverter, 一般情况下不会有@Streaming注释 3.1.4 Converter.convert3.1.4.1 StreamingResponseBodyConverter123456789static final class StreamingResponseBodyConverter implements Converter&lt;ResponseBody, ResponseBody&gt; &#123; static final StreamingResponseBodyConverter INSTANCE = new StreamingResponseBodyConverter(); @Override public ResponseBody convert(ResponseBody value) throws IOException &#123; return value; &#125;&#125; 3.1.4.2 BufferingResponseBodyConverter123456789101112131415161718192021static final class BufferingResponseBodyConverter implements Converter&lt;ResponseBody, ResponseBody&gt; &#123; static final BufferingResponseBodyConverter INSTANCE = new BufferingResponseBodyConverter(); @Override public ResponseBody convert(ResponseBody value) throws IOException &#123; try &#123; // Buffer the entire body to avoid future I/O. return Utils.buffer(value); &#125; finally &#123; value.close(); &#125; &#125;&#125; //Utils.buffer static ResponseBody buffer(final ResponseBody body) throws IOException &#123; Buffer buffer = new Buffer(); body.source().readAll(buffer); return ResponseBody.create(body.contentType(), body.contentLength(), buffer);&#125;","tags":[{"name":"Retrofit","slug":"Retrofit","permalink":"https://wangyun137.github.io/tags/Retrofit/"},{"name":"开源项目学习","slug":"开源项目学习","permalink":"https://wangyun137.github.io/tags/开源项目学习/"}]},{"title":"DiskLruCache学习","date":"2017-07-24T07:15:26.000Z","path":"2017/07/24/DiskLruCache学习/","text":"一. 用法DiskLruCache是Google官方推荐的磁盘缓存方案，很多优秀的App都在使用这一方案，在Android DiskLruCache完全解析， 硬盘缓存的最佳方案这篇博客中，很详细的介绍了如何使用DiskLruCache，通过这篇博文可以将DiskLruCache的用法总结为以下几个步骤: 1.1 写缓存 确定缓存目录， 获取App版本号， 调用DiskaLruCache.open创建DiskLruCache对象 通过DiskLruCache.editor()获取DiskLruCache.Editor对象 通过Editor.newOutputStream()获取输出流，之后利用该输出流将缓存文件写入磁盘 调用Editor.commit(),DiskLruCache.flush()刷新日志文件 1.2 读缓存 通过DiskLruCache.get()获取Snapshot对象 通过Snapshot.getInputStream()获取输入流，利用该输入流读取缓存文件 1.3 日志文件DiskLruCache主要通过日志文件来记录和管理缓存文件，在DiskLruCache的源码中有一段注释详细陈述了日志文件的格式: 12345678910111213libcore.io.DiskLruCache11002CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054DIRTY 335c4c6028171cfddfbaae1a9c313c52CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342REMOVE 335c4c6028171cfddfbaae1a9c313c52DIRTY 1ab96a171faeeee38496d8b330771a7aCLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234READ 335c4c6028171cfddfbaae1a9c313c52READ 3400330d1dfc7f3f7f4b8d4d803dfcf6 前五行是日志文件的头部信息，其意义分别是 第一行的libcore.io.DiskLruCache是文件的MAGIC, 用来标识该文件是DiskLruCache的日志文件 第二行是DiskLruCache自身的版本号 第三行是App的版本号，通过DiskLruCache.open的第二个参数设置 第四行是DiskLruCache.open的第三个参数，代表一个key值可以缓存多少个Entry 第五行是一个空行 从第六行开始记录了缓存文件的相应操作: 每次调用DiskLruCache.edit()时，都会向日志文件写入一条DIRTY数据，表示当前正在准备写入一条缓存数据, DIRTY后面各一个空格写入缓存的key值 当调用Editor.commit()将缓存写入成功之后，会在DIRTY数据下一行写入一条key值相同的CLEAN数据， CLEAN后面隔一个空格写入相同的key值，key值后隔一个空格写入以字节为单位的该缓存文件的大小，如果在DiskLruCache.open中第三个参数valueCount传大于1的值，那么每一个key值可以对应多个缓存文件，相应的一条CLEAN数据后面就会记录多个缓存文件的大小，其数目等于valueCount；如果调用Editor.abort()，那么会在DIRTY数据下一行下入一条REMOVE记录。也就是说， 每一条DIRTY数据下一行都有条CLEAN数据或REMOVE数据，DIRTY数据不可以单独存在，否则这条数据就会被删除掉; 当调用DiskLruCache.get()时都会想日志文件写如一条READ数据，表示正在读取缓存文件 二.源码分析下面就根据这几个步骤结合源码来看一下DiskLruCache的具体实现 2.1 重要变量和类2.1.1 变量 journalWriter: Writer 用于向日志文件写入内容 lruEntries: LinkedHashMap 每一个缓存文件都有一个对应的Entry对象，lruEntries用来存放key值对应的Entry对象 redundantOpCount:记录操作缓存的次数，如果该值达到2000，DiskLruCache就会重新构建日志文件，将其中一些冗余的数据删除 size: 记录总有缓存文件总大小 maxSize: 所有缓存文件大小的总和的上限值，如果超过该值，那么就会删除一些缓存文件 cleanupCallable: Callable 当缓存文件总大小超过上限时会触发该任务，用于清除一些缓存文件，从而减少缓存文件总和 2.1.2 类 Snapshot: 调用DiskLruCache.get()会获取一个Snapshot对象，通过Snapshot可以获取缓存文件的输入流 Editor: 编辑器，对于缓存文件的操作以及日志文件的更新都是通过这个类完成 Entry: 每一个缓存文件都有一个对应的Entry对象， DiskLruCache通过操作Entry对象来完成对缓存文件的操作 StrictLineReader: 封装了输入流，提供可以每次读取一行内容的方法 2.2 DiskLruCache.open1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static final String JOURNAL_FILE = \"journal\";static final String JOURNAL_FILE_BACKUP = \"journal.bkp\";public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize) throws IOException &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException(\"maxSize &lt;= 0\"); &#125; if (valueCount &lt;= 0) &#123; throw new IllegalArgumentException(\"valueCount &lt;= 0\"); &#125; //如果备份文件存在则使用备份文件 File backupFile = new File(directory, JOURNAL_FILE_BACKUP); if (backupFile.exists()) &#123; File journalFile = new File(directory, JOURNAL_FILE); //如果日志文件存在，删除备份文件 if (journalFile.exists()) &#123; backupFile.delete(); &#125; else &#123; //将备份文件重命名为日志文件 renameTo(backupFile, journalFile, false); &#125; &#125; // Prefer to pick up where we left off. DiskLruCache cache = new DiskLruCache(directory, appVersion, valueCount, maxSize); //如果日志文件存在的话，读取日志文件并处理，填充lruEntries, 然后直接返回DiskLruCache对象 if (cache.journalFile.exists()) &#123; try &#123; //读取journal文件, 【2.2.1】 cache.readJournal(); //处理读取的journal文件内容, 【2.2.2】 cache.processJournal(); return cache; &#125; catch (IOException journalIsCorrupt) &#123; ... cache.delete(); &#125; &#125; //如果没有已有的日志文件，创建对应的缓存目录， 并初始化日志文件 directory.mkdirs(); cache = new DiskLruCache(directory, appVersion, valueCount, maxSize); //新建日志文件,【2.2.3】 cache.rebuildJournal(); return cache; &#125; 首先检查备份文件是否存在，之后再确定日志文件是否存在， 如果日志文件存在，则删除备份文件，如果日志文件不存在但备份文件村咋，将备份文件重命名为日志文件 创建DiskLruCache对象，构造函数中几个参数的意义分别是:directory - 缓存目录; appVersion - 应用版本号; valueCount - 一个可以可以缓存几个Entry, 一般都传1; maxSize - 所有缓存文件大小的总和占据的最大存储空间 如果日志文件已存在，读取日志文件并根据日志文件进行一些必要的操作，如删除以DIRTY开头的文件 如果日志文件不存在，创建缓存目录,并新建日志文件 2.2.1 DiskLruCache.readJournal1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private void readJournal() throws IOException &#123; StrictLineReader reader = new StrictLineReader(new FileInputStream(journalFile), Util.US_ASCII); try &#123; //读取第一行魔数 String magic = reader.readLine(); //读取第二行version String version = reader.readLine(); //读取第三行appVersion String appVersionString = reader.readLine(); //读取第四行valueCount String valueCountString = reader.readLine(); //读取第五行空行 String blank = reader.readLine(); //确保头部信息正确 if (!MAGIC.equals(magic) || !VERSION_1.equals(version) || !Integer.toString(appVersion).equals(appVersionString) || !Integer.toString(valueCount).equals(valueCountString) || !\"\".equals(blank)) &#123; throw new IOException(...); &#125; int lineCount = 0; while (true) &#123; try &#123; //处理这一行内容,【2.2.1.1】 readJournalLine(reader.readLine()); lineCount++; &#125; catch (EOFException endOfJournal) &#123; break; &#125; &#125; //处理了多少行 - lruEntries.size() redundantOpCount = lineCount - lruEntries.size(); // 如果遇到IO异常， 重新构建日志文件 if (reader.hasUnterminatedLine()) &#123; rebuildJournal(); &#125; else &#123; journalWriter = new BufferedWriter(new OutputStreamWriter( new FileOutputStream(journalFile, true), Util.US_ASCII)); &#125; &#125; finally &#123; Util.closeQuietly(reader); &#125; &#125; 从代码中可以看到，读取日志文件每一行内容主要使用了StrictLineReader这个类， 这个类实际上封装了InputStream, 内部有一个缓存数组，每次缓存8192个字节，从而提高了读取的效率，当遇到换行符时即判定为一行内容 首先读取前五行，校验是否是正确的头部信息 c处理完前五行之后，依次读取每一行内容并根据内容进行操作 如果遇到IO异常，重新构建日志文件；否则一切正常的话， 初始化journalWriter(用来写入日志文件) 2.2.1.1 DiskLruCache.readJournalLine1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void readJournalLine(String line) throws IOException &#123; //获取第一个空格的位置 int firstSpace = line.indexOf(' '); if (firstSpace == -1) &#123; throw new IOException(\"unexpected journal line: \" + line); &#125; //第一个空格后面是key的起始位置 int keyBegin = firstSpace + 1; //获取第二个空格的位置， 一般如果是CLEAN的话会有第二个空格 int secondSpace = line.indexOf(' ', keyBegin); final String key; if (secondSpace == -1) &#123; key = line.substring(keyBegin); //如果这一行的开头是REMOVE, 从lruEntries中删除key if (firstSpace == REMOVE.length() &amp;&amp; line.startsWith(REMOVE)) &#123; lruEntries.remove(key); return; &#125; &#125; else &#123; key = line.substring(keyBegin, secondSpace); &#125; //从lruEntries中获取key值对应的Entry, 如果lruEntries中没有对应的Entry，生成一个新的Entry并放入lruEntries Entry entry = lruEntries.get(key); if (entry == null) &#123; entry = new Entry(key); lruEntries.put(key, entry); &#125; //如果这一行是以CLEAN开头, 获取第二个空格之后内容 if (secondSpace != -1 &amp;&amp; firstSpace == CLEAN.length() &amp;&amp; line.startsWith(CLEAN)) &#123; String[] parts = line.substring(secondSpace + 1).split(\" \"); entry.readable = true; entry.currentEditor = null; entry.setLengths(parts); &#125; //如果这一行是以DIRTY开头，将currentEditor指向一个新的Editor else if (secondSpace == -1 &amp;&amp; firstSpace == DIRTY.length() &amp;&amp; line.startsWith(DIRTY)) &#123; entry.currentEditor = new Editor(entry); &#125; //如果这一行以READ开头，啥也不干 else if (secondSpace == -1 &amp;&amp; firstSpace == READ.length() &amp;&amp; line.startsWith(READ)) &#123; // This work was already done by calling lruEntries.get(). &#125; else &#123; throw new IOException(\"unexpected journal line: \" + line); &#125; &#125; 根据空格依次获得每一行的开头标识(DIRTY, CLEAN, REMOVE)以及对应的key值 如果这一行是以REMOVE开头，从lruEntries中删除key对应的Entry并返回 从lruEntries中获取key值对应的Entry，如果没有则生成一个新的Entry对象并放入lruEntries,这个操作的目的是为了保持日志文件和内存中lruEntries的数据的一致性 如果这一行是以CLEAN开头，获取key值以后的内容(记录一个或多个对象缓存文件的大小)，同时标记entry.readable = true, entry.currentEditor = null，即表示该缓存文件为可读的 如果这一行是以DIRTY开头的，将entry.currentEditor指向一个新创建的Editor对象 2.2.2 DiskLruCache.processJournal1234567891011121314151617181920212223private void processJournal() throws IOException &#123; //删除journal.tmp文件 deleteIfExists(journalFileTmp); //遍历lruEntries for (Iterator&lt;Entry&gt; i = lruEntries.values().iterator(); i.hasNext(); ) &#123; Entry entry = i.next(); if (entry.currentEditor == null) &#123; //如果currentEditor为null, 代表该entry是CLEAN的，增加size for (int t = 0; t &lt; valueCount; t++) &#123; size += entry.lengths[t]; &#125; &#125; else &#123; //如果currentEditor不为null， 代表该entry是DIRTY的，删除对应的缓存文件和临时文件 //并从lruEntries中删除该entry entry.currentEditor = null; for (int t = 0; t &lt; valueCount; t++) &#123; deleteIfExists(entry.getCleanFile(t)); deleteIfExists(entry.getDirtyFile(t)); &#125; i.remove(); &#125; &#125; &#125; 如果临时日志文件存在，删除临时文件 遍历lruEntries, 如果entry.currentEditor == null代表这一个entry是CLEAN的，将entry对应的文件大小统计到所有缓存文件大小总和中；相反，则代表entry是DIRTY的，删除对应的缓存文件，并从lruEntries中删除(NOTE:这里其实针对的是只有DIRTY记录的缓存文件，因为正常情况下，每一条DIRTY数据后都会紧跟一条CLEAN或者REMOVE数据，如果有CLEAN或REMOVE数据，在之前的【2.2.1.1】readJournalLine中都已经经过了处理，其所对应的entry的currentEditor肯定为null或不在lruEntries中了) 2.2.3 DiskLruCache.rebuildJournal123456789101112131415161718192021222324252627282930313233343536373839404142private synchronized void rebuildJournal() throws IOException &#123; if (journalWriter != null) &#123; journalWriter.close(); &#125; //先写入journal.tmp文件 Writer writer = new BufferedWriter( new OutputStreamWriter(new FileOutputStream(journalFileTmp), Util.US_ASCII)); try &#123; //写入头部信息 writer.write(MAGIC); writer.write(\"\\n\"); writer.write(VERSION_1); writer.write(\"\\n\"); writer.write(Integer.toString(appVersion)); writer.write(\"\\n\"); writer.write(Integer.toString(valueCount)); writer.write(\"\\n\"); writer.write(\"\\n\"); for (Entry entry : lruEntries.values()) &#123; if (entry.currentEditor != null) &#123; //如果currentEditor不为null, 则写入DIRTY开头的行 writer.write(DIRTY + ' ' + entry.key + '\\n'); &#125; else &#123; //写入以CLEAN开头的行 writer.write(CLEAN + ' ' + entry.key + entry.getLengths() + '\\n'); &#125; &#125; &#125; finally &#123; writer.close(); &#125; if (journalFile.exists()) &#123; renameTo(journalFile, journalFileBackup, true); &#125; renameTo(journalFileTmp, journalFile, false); journalFileBackup.delete(); journalWriter = new BufferedWriter( new OutputStreamWriter(new FileOutputStream(journalFile, true), Util.US_ASCII)); &#125; 首先写入固定头部 遍历lruEntries,根据entry.currentEditor是否等于null，写入DIRTY或者CLEAN记录 2.3 DiskLruCache.edit12345678910111213141516171819202122232425262728293031public Editor edit(String key) throws IOException &#123; return edit(key, ANY_SEQUENCE_NUMBER); &#125; private synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException &#123; //如果journalWritter == null， 抛出异常 checkNotClosed(); //校验key是否合法 validateKey(key); //从lruEntries中获取Entry Entry entry = lruEntries.get(key); if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER &amp;&amp; (entry == null || entry.sequenceNumber != expectedSequenceNumber)) &#123; return null; // Snapshot is stale. &#125; if (entry == null) &#123; entry = new Entry(key); lruEntries.put(key, entry); &#125; else if (entry.currentEditor != null) &#123; return null; // Another edit is in progress. &#125; Editor editor = new Editor(entry); entry.currentEditor = editor; // 先写入DIRTY行 journalWriter.write(DIRTY + ' ' + key + '\\n'); journalWriter.flush(); return editor; &#125; 检查journal是否为null, 如果是抛出异常 检查key值是否符合[a-z0-9_-]{1,120}规则 根据key获取对应的Entry 新建一个Editor对象，将entry.currentEditor指向新建的Editor对象 向日志文件写入DIRTY数据 每当调用editor()时都会先在日志文件中写入一条DIRTY数据,表示正在准备操作缓存文件 2.4 Editor.newOutputStream12345678910111213141516171819202122232425262728293031public OutputStream newOutputStream(int index) throws IOException &#123; if (index &lt; 0 || index &gt;= valueCount) &#123; throw new IllegalArgumentException(...); &#125; synchronized (DiskLruCache.this) &#123; if (entry.currentEditor != this) &#123; throw new IllegalStateException(); &#125; if (!entry.readable) &#123; written[index] = true; &#125; //先在临时文件中写入 File dirtyFile = entry.getDirtyFile(index); FileOutputStream outputStream; try &#123; outputStream = new FileOutputStream(dirtyFile); &#125; catch (FileNotFoundException e) &#123; // Attempt to recreate the cache directory. directory.mkdirs(); try &#123; outputStream = new FileOutputStream(dirtyFile); &#125; catch (FileNotFoundException e2) &#123; // We are unable to recover. Silently eat the writes. return NULL_OUTPUT_STREAM; &#125; &#125; //FaultHidingOutputStream是一个代理类，实际还是调用outputStream的方法 //只不过异常发生时会不会抛出异常 return new FaultHidingOutputStream(outputStream); &#125; &#125; 获取的是临时文件的输出流 2.5 Editor.commit12345678910public void commit() throws IOException &#123; if (hasErrors) &#123; //如果有错误，删除缓存文件, 【2.5.1】 completeEdit(this, false); remove(entry.key); // The previous entry is stale. &#125; else &#123; completeEdit(this, true); &#125; committed = true;&#125; 如果IO输出过程有错误发生，从lruEntries中删除相应entry,同时删除对应的缓存文件; 无论是否错误，都会调用DiskLruCache.compleEdit方法, 区别在于错误时传入的第二个参数为false, 正常时为true hasError是在FaultHidingOutputStream中当出现IO异常时设为true 2.5.1 DiskLruCache.completeEdit12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758private synchronized void completeEdit(Editor editor, boolean success) throws IOException &#123; Entry entry = editor.entry; if (entry.currentEditor != editor) &#123; throw new IllegalStateException(); &#125; if (success &amp;&amp; !entry.readable) &#123; for (int i = 0; i &lt; valueCount; i++) &#123; if (!editor.written[i]) &#123; editor.abort(); throw new IllegalStateException(...); &#125; //确保临时文件存在 if (!entry.getDirtyFile(i).exists()) &#123; editor.abort(); return; &#125; &#125; &#125; for (int i = 0; i &lt; valueCount; i++) &#123; File dirty = entry.getDirtyFile(i); if (success) &#123; if (dirty.exists()) &#123; File clean = entry.getCleanFile(i); dirty.renameTo(clean); long oldLength = entry.lengths[i]; long newLength = clean.length(); entry.lengths[i] = newLength; size = size - oldLength + newLength; &#125; &#125; else &#123; deleteIfExists(dirty); &#125; &#125; redundantOpCount++; entry.currentEditor = null; if (entry.readable | success) &#123; entry.readable = true; //向日志文件写入CLEAN行 journalWriter.write(CLEAN + ' ' + entry.key + entry.getLengths() + '\\n'); if (success) &#123; entry.sequenceNumber = nextSequenceNumber++; &#125; &#125; else &#123; //从lruEntries中删除，并向日志文件写入REMOVE行 lruEntries.remove(entry.key); journalWriter.write(REMOVE + ' ' + entry.key + '\\n'); &#125; journalWriter.flush(); if (size &gt; maxSize || journalRebuildRequired()) &#123; executorService.submit(cleanupCallable); &#125; &#125; 确保临时的缓存文件存在，不存在则调用Editor.abort 如果传入的success = true即代表IO输出成功，则将临时缓存文件重命名为正式的缓存文件，同时更新缓存文件大小总和；如果sucess = false代表出现错误，则删除临时缓存文件 递增redundantOpCount 如果IO输出成功，想日志文件写入CLEAN行数据，否则从lruEntries中删除对应的entry,并向日志文件写入REMOVE行内容 如果缓存文件总大小超出上限或者redundantOpCount大于等于2000时，在线程池中执行cleanupCallable任务 2.5.1.1 DiskLruCache.cleanupCallable123456789101112131415161718192021222324252627282930private final Callable&lt;Void&gt; cleanupCallable = new Callable&lt;Void&gt;() &#123; public Void call() throws Exception &#123; synchronized (DiskLruCache.this) &#123; if (journalWriter == null) &#123; return null; // Closed. &#125; trimToSize(); if (journalRebuildRequired()) &#123; //【2.2.3】 rebuildJournal(); redundantOpCount = 0; &#125; &#125; return null; &#125;&#125;;private void trimToSize() throws IOException &#123; //如果缓存的文件总大小超过了maxSize, 删除缓存文件直到小于上限，并更新日志文件 while (size &gt; maxSize) &#123; Map.Entry&lt;String, Entry&gt; toEvict = lruEntries.entrySet().iterator().next(); remove(toEvict.getKey()); &#125;&#125;private boolean journalRebuildRequired() &#123; final int redundantOpCompactThreshold = 2000; return redundantOpCount &gt;= redundantOpCompactThreshold // &amp;&amp; redundantOpCount &gt;= lruEntries.size();&#125; 2.6 DiskLruCache.flush1234567public synchronized void flush() throws IOException &#123; //确保journalWriter不等于null checkNotClosed(); //【2.5.1.1】, 删除缓存文件，直到总大小小于上限 trimToSize(); journalWriter.flush(); &#125; 2.7 DiskLruCache.get1234567891011121314151617181920212223242526272829303132333435363738394041public synchronized Snapshot get(String key) throws IOException &#123; //确保journalWriter不为null checkNotClosed(); //验证key值符合规则 validateKey(key); Entry entry = lruEntries.get(key); if (entry == null) &#123; return null; &#125; if (!entry.readable) &#123; return null; &#125; //创建缓存文件输入流 InputStream[] ins = new InputStream[valueCount]; try &#123; for (int i = 0; i &lt; valueCount; i++) &#123; ins[i] = new FileInputStream(entry.getCleanFile(i)); &#125; &#125; catch (FileNotFoundException e) &#123; // A file must have been deleted manually! for (int i = 0; i &lt; valueCount; i++) &#123; if (ins[i] != null) &#123; Util.closeQuietly(ins[i]); &#125; else &#123; break; &#125; &#125; return null; &#125; redundantOpCount++; //更新日志文件，添加READ行 journalWriter.append(READ + ' ' + key + '\\n'); if (journalRebuildRequired()) &#123; executorService.submit(cleanupCallable); &#125; return new Snapshot(key, entry.sequenceNumber, ins, entry.lengths); &#125; 确保journalWriter不等于null, key值符合规则 创建缓存文件输入流 向日志文件中写入READ行 返回Snapshot对象 2.8 DiskLruCache.close12345678910111213public synchronized void close() throws IOException &#123; if (journalWriter == null) &#123; return; // Already closed. &#125; for (Entry entry : new ArrayList&lt;Entry&gt;(lruEntries.values())) &#123; if (entry.currentEditor != null) &#123; entry.currentEditor.abort(); &#125; &#125; trimToSize(); journalWriter.close(); journalWriter = null;&#125; 遍历lruEntries,如果entry.currentEditor != null, 调用Editor.abort(abort方法实际调用DiakLruache.completeEdit【2.5.1】, 第二个参数传入false) 检查缓存总大小是否超出上限，如果超出，删除一些缓存文件直到小于上限 关闭journalWrite","tags":[{"name":"DiskLruCache","slug":"DiskLruCache","permalink":"https://wangyun137.github.io/tags/DiskLruCache/"},{"name":"开源项目分析","slug":"开源项目分析","permalink":"https://wangyun137.github.io/tags/开源项目分析/"}]},{"title":"开源项目学习之Volley(二)","date":"2017-07-24T07:07:19.000Z","path":"2017/07/24/开源项目学习之Volley-二/","text":"Volley不仅可以进行普通的网络请求，还提供了一个简单的图片加载框架，下面这段代码展示了最普遍的使用Volley加载图片的方法 12345678910111213141516RequestQueue queue = Volley.newRequestQueue(context);ImageLoader loader = new ImageLoader(queue, new ImageCache() &#123; @Override public void putBitmap(String url, Bitmap bitmap) &#123; &#125; @Override public Bitmap getBitmap(String url) &#123; &#125;&#125;);ImageListener listener = ImageLoader.getImageListener(imageView, R.drwable.ic_default_icon, R.drawable.ic_error_icon);loader.get(\"xxx.jpeg\", listener, 200, 200); 除了这种用法外，另一种比较常用的是NetworkImageView，它的用法更为简单是: 在布局文件中声明一个NetworkImageView控件 获取控件实例 1234networkImageView.setDefaultImageResId(R.drawable.ic_default_icon); networkImageView.setErrorImageResId(R.drawable.ic_error_icon); networkImageView.setImageUrl(&quot;xxx.png&quot;, imageLoader); NetworkImageView内部的实现其实仍然是使用了ImageLoader，所以我们主要看一下ImageLoader相关的代码 代码分析1. ImageLoader.getImageListener12345678910111213141516171819202122public static ImageListener getImageListener(final ImageView view, final int defaultImageResId, final int errorImageResId) &#123; return new ImageListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; if (errorImageResId != 0) &#123; view.setImageResource(errorImageResId); &#125; &#125; @Override public void onResponse(ImageContainer response, boolean isImmediate) &#123; if (response.getBitmap() != null) &#123; view.setImageBitmap(response.getBitmap()); &#125; else if (defaultImageResId != 0) &#123; view.setImageResource(defaultImageResId); &#125; &#125; &#125;; &#125; defaultImageResId是占位图，errorImageResId是当出现错误时显示的占位图 也可以自定义一个ImgeListener 2. ImageLoader.get1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public ImageContainer get(String requestUrl, final ImageListener listener) &#123; return get(requestUrl, listener, 0, 0);&#125;public ImageContainer get(String requestUrl, ImageListener imageListener, int maxWidth, int maxHeight) &#123; return get(requestUrl, imageListener, maxWidth, maxHeight, ScaleType.CENTER_INSIDE);&#125;public ImageContainer get(String requestUrl, ImageListener imageListener, int maxWidth, int maxHeight, ScaleType scaleType) &#123; //确定是在主线程 throwIfNotOnMainThread(); //生成缓存key final String cacheKey = getCacheKey(requestUrl, maxWidth, maxHeight, scaleType); //从缓存中查找Bitmap Bitmap cachedBitmap = mCache.getBitmap(cacheKey); if (cachedBitmap != null) &#123; // 如果从缓存中找到，则直接回调onResponse ImageContainer container = new ImageContainer(cachedBitmap, requestUrl, null, null); imageListener.onResponse(container, true); return container; &#125; // 生成一个bitmap = null的ImageContainer, 回调onResponse, 这样做的目的是显示占位图 ImageContainer imageContainer = new ImageContainer(null, requestUrl, cacheKey, imageListener); imageListener.onResponse(imageContainer, true); // 从InFlightRequest中查找是否有正在请求的Request BatchedImageRequest request = mInFlightRequests.get(cacheKey); if (request != null) &#123; // If it is, add this request to the list of listeners. request.addContainer(imageContainer); return imageContainer; &#125; //创建一个新的请求，用于请求图片 Request&lt;Bitmap&gt; newRequest = makeImageRequest(requestUrl, maxWidth, maxHeight, scaleType, cacheKey); mRequestQueue.add(newRequest); mInFlightRequests.put(cacheKey, new BatchedImageRequest(newRequest, imageContainer)); return imageContainer;&#125; 确定当前是在主线程 生成缓存key, key的规则是“url + #W${maxWidth} + #H${maxHeight} + #S${scaleType.ordinal}” 从缓存中查找Bitmap1,如果找到则回调ImageListener.onResponse,并返回 如果缓存中没有找到，则先生成一个bitmap = null的ImageContainer,然后回调ImageListener.onResponse, 这样做的目的在于可以先让ImageView显示占位图 从inFlightRequests中查找是否存在key对应的正在请求的Request 创建一个新的请求，添加到队列 2.1 ImageLoader.makeImageRequest1234567891011121314protected Request&lt;Bitmap&gt; makeImageRequest(String requestUrl, int maxWidth, int maxHeight,ScaleType scaleType, final String cacheKey) &#123; return new ImageRequest(requestUrl, new Listener&lt;Bitmap&gt;() &#123; @Override public void onResponse(Bitmap response) &#123; onGetImageSuccess(cacheKey, response); &#125; &#125;, maxWidth, maxHeight, scaleType, Config.RGB_565, new ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; onGetImageError(cacheKey, error); &#125; &#125;);&#125; 可以看到，实际就是构建了一个ImageRequest 2.1.1 ImageRequest123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class ImageRequest extends Request&lt;Bitmap&gt; &#123; ... @Override protected Response&lt;Bitmap&gt; parseNetworkResponse(NetworkResponse response) &#123; synchronized (sDecodeLock) &#123; try &#123; return doParse(response); &#125; catch (OutOfMemoryError e) &#123; return Response.error(new ParseError(e)); &#125; &#125; &#125; private Response&lt;Bitmap&gt; doParse(NetworkResponse response) &#123; byte[] data = response.data; BitmapFactory.Options decodeOptions = new BitmapFactory.Options(); Bitmap bitmap = null; if (mMaxWidth == 0 &amp;&amp; mMaxHeight == 0) &#123; decodeOptions.inPreferredConfig = mDecodeConfig; bitmap = BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions); &#125; else &#123; // If we have to resize this image, first get the natural bounds. decodeOptions.inJustDecodeBounds = true; BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions); int actualWidth = decodeOptions.outWidth; int actualHeight = decodeOptions.outHeight; // 计算出合适的width和height int desiredWidth = getResizedDimension(mMaxWidth, mMaxHeight, actualWidth, actualHeight, mScaleType); int desiredHeight = getResizedDimension(mMaxHeight, mMaxWidth, actualHeight, actualWidth, mScaleType); decodeOptions.inJustDecodeBounds = false; // decodeOptions.inPreferQualityOverSpeed = PREFER_QUALITY_OVER_SPEED; //计算出合适的imSampleSize decodeOptions.inSampleSize = findBestSampleSize(actualWidth, actualHeight, desiredWidth, desiredHeight); Bitmap tempBitmap = BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions); // If necessary, scale down to the maximal acceptable size. if (tempBitmap != null &amp;&amp; (tempBitmap.getWidth() &gt; desiredWidth || tempBitmap.getHeight() &gt; desiredHeight)) &#123; bitmap = Bitmap.createScaledBitmap(tempBitmap, desiredWidth, desiredHeight, true); tempBitmap.recycle(); &#125; else &#123; bitmap = tempBitmap; &#125; &#125; if (bitmap == null) &#123; return Response.error(new ParseError(response)); &#125; else &#123; return Response.success(bitmap, HttpHeaderParser.parseCacheHeaders(response)); &#125; &#125; &#125; 从之前的开源项目学习之Volley(一)可以知道，Request最重要的方法就是performNetworkResponse,ImageRequest的performNetworkResponse直接调用的私有方法doParse, 从doParse的代码中可以看出其逻辑主要就是解析出合适的Bitmap 2.1.2 ImageLoader.onGetImageSuccessonGetImageSuccess会再调用batchResponse, 这两个方法的逻辑总结起来就是： 将请求到的Bitmap放入缓存，之后获取到之前传入的ImageListener，回调onResponse","tags":[{"name":"开源项目学习","slug":"开源项目学习","permalink":"https://wangyun137.github.io/tags/开源项目学习/"},{"name":"Volley","slug":"Volley","permalink":"https://wangyun137.github.io/tags/Volley/"}]},{"title":"开源项目学习之Volley(一)","date":"2017-07-24T07:04:37.000Z","path":"2017/07/24/开源项目学习之Volley-一/","text":"一. 重要的类1.1 RequestQueue重要变量1234567891011121314151617181920212223242526272829//请求等待集合，队列中的请求是重复的，之前已经有一个相同的请求正在执行 private final Map&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests = new HashMap&lt;&gt;(); private final Set&lt;Request&lt;?&gt;&gt; mCurrentRequests = new HashSet&lt;Request&lt;?&gt;&gt;(); //缓存队列 private final PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue = new PriorityBlockingQueue&lt;&gt;(); //网络请求队列 private final PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue = new PriorityBlockingQueue&lt;&gt;(); //默认使用的是DiskBasedCache private final Cache mCache; /** 默认使用BasicNetwork */ private final Network mNetwork; /** 默认使用ExecutorDelivery */ private final ResponseDelivery mDelivery; //网络请求线程数组 private final NetworkDispatcher[] mDispatchers; //缓存线程 private CacheDispatcher mCacheDispatcher; 重要方法 add(), 可以将请求放入队列中 start(), RequestQueue还负责启动cache线程和network线程 stop(), 停止缓存线程和网络线程 finish(), 请求结束后的回调 1.2 Request抽象了Http请求， Request本身是一个抽象类，继承它的子类必须要实现两个抽象方法: abstract protected Response parseNetworkResponse(NetworkResponse response) - 将http请求返回的响应解析成合适的类型 abstract protected void deliverResponse(T response) - 将解析好的响应传递给监听器 每一个Request的缓存key就是它的Url, 如果要创建POST或者PUT请求， 也可以重写以下两个方法: public byte[] getBody() throws AuthFailureError {} public Map&lt;String, String&gt; getParams() throws AuthFailureError getBody()方法默认也是通过getParams方法来创建Body内容，而getParams方法默认实现是直接返回null，所以一般构建POST或PUT请求应当重写这两个方法中的一个, 一般直接重写getParams即可 子类 StringRequest, 返回值为String类型 JsonRequest, 代表了Body为json的请求, 本身也是一个抽象类 JsonObjectRequest, 继承了JsonRequest， 将返回值解析为JSONObject JsonArrayRequest, 继承了JsonRequest, 将返回值解析为JsonArrayRequest ImageRequest, 图片请求，将返回值解析成为Bitmap 1.3 HttpStackHttpStack是一个接口，就定义了一个执行方网络请求的方法performRequest, 它有两个实现类HurlStack和HttpClientStack HurlStackHurlStack的performRequest主要是用HttpUrlConnection来实现网络请求，这也是Android官方目前推荐使用的方式 HttpClientStackHttpClientStack是使用Apache的HttpClient来进行网络请求，这一方式目前目前不被Android官方推荐，HttpClient也已从Android源码中移除 1.4 BasicNetworkBasicNetwork实现了Network接口，其内部含有HttpStack引用，其performRequest主要工作是解析请求的Header，调用HttpStack.performRequest来真正执行网络请求， 之后判断http响应码(主要是判断304，跟缓存相关)，生成NetworkResponse 1.5 DiskBasedCache磁盘缓存类，实现了Cache接口 重要方法 public synchronized void initialize(),初始化缓存，扫面缓存目录(默认为/data/data/pkg_name/files/cache/volley)得到缓存数据生成缓存header并放入内存 public synchronized Entry get(String key), 从缓存中获取缓存header,然后读取缓存文件 public synchronized void put(String key, Entry entry), 先检查如果给当前Entry分配空间以后， 缓存是否会满，如果会满则遍历并逐个删除缓存，直到如果为当前Entry分配空间以后，缓存量小于最大缓存量的0.9， 然后再新建缓存文件 二. 基本流程2.1 Volley.newRequestQueue1234567891011121314151617181920212223public static RequestQueue newRequestQueue(Context context, HttpStack stack) &#123; //创建缓存目录，默认在/data/data/pkg_name/files/cache/volley File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR); if (stack == null) &#123; if (Build.VERSION.SDK_INT &gt;= 9) &#123; //使用HttpUrlConnection的方式进行网络请求 stack = new HurlStack(); &#125; else &#123; //使用HttpClient进行http请求 ... &#125; &#125; //使用默认的BasicNetwork Network network = new BasicNetwork(stack); //创建请求队列, 默认使用ExecutorDelivery RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network); //启动CacheDispatcher和NetworkDispatcher线程,开始接收请求，[2] queue.start(); return queue; &#125; 创建缓存目录, 默认为/data/data/pkg_name/files/cache/volley 创建对应的HttpStack 创建BasciNetwork 创建DiskBasedCache 创建RequestQueue, 并启动 2.2 RequestQueue.start123456789101112131415public void start() &#123; //停止所有缓存线程和网络请求线程, stop(); //创建缓存线程，并启动线程. [3] mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery); mCacheDispatcher.start(); //创建网络请求线程数组中所有的网络请求线程，并启动, [4] for (int i = 0; i &lt; mDispatchers.length; i++) &#123; NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork, mCache, mDelivery); mDispatchers[i] = networkDispatcher; networkDispatcher.start(); &#125; &#125; mCacheQueue是PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;类型 mNetworkQueue也是PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;类型 CacheDispatcher和NetworkDispatcher都是继承自Thread即一个线程类 2.3 CacheDispatcher.run123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475@Override public void run() &#123; //设置缓存线程的优先级 Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); // 初始化DiskBasedCache, [2.3.1] mCache.initialize(); while (true) &#123; try &#123; /* 从缓存队列中读取Request, 如果队列中没有请求，则线程阻塞*/ final Request&lt;?&gt; request = mCacheQueue.take(); request.addMarker(\"cache-queue-take\"); /* 如果请求已经被取消，则直接结束当前请求, 从当前请求集合以及等待请求列表中删除*/ if (request.isCanceled()) &#123; request.finish(\"cache-discard-canceled\"); continue; &#125; /* 判断当前请求有没有缓存， request的cacheKey就是url*/ Cache.Entry entry = mCache.get(request.getCacheKey()); /* 没有缓存结果，则直接交友网络请求线程*/ if (entry == null) &#123; request.addMarker(\"cache-miss\"); mNetworkQueue.put(request); continue; &#125; /* 如果有缓存结果，但缓存结果已经失效，同样交由网络线程*/ if (entry.isExpired()) &#123; request.addMarker(\"cache-hit-expired\"); request.setCacheEntry(entry); mNetworkQueue.put(request); continue; &#125; request.addMarker(\"cache-hit\"); /* 缓存命中，则调用Request的parseNetworkResponse获取相应的Response*/ Response&lt;?&gt; response = request.parseNetworkResponse( new NetworkResponse(entry.data, entry.responseHeaders)); request.addMarker(\"cache-hit-parsed\"); if (!entry.refreshNeeded()) &#123; /* 如果缓存不需要刷新，则直接传递结果*/ mDelivery.postResponse(request, response); &#125; else &#123; /* 如果缓存还需要刷新，传递响应结果，将将请求交由网络线程进行新鲜度验证*/ request.addMarker(\"cache-hit-refresh-needed\"); request.setCacheEntry(entry); response.intermediate = true; /* 向网络请求队列中添加请求*/ mDelivery.postResponse(request, response, new Runnable() &#123; @Override public void run() &#123; try &#123; mNetworkQueue.put(request); &#125; catch (InterruptedException e) &#123; // Not much we can do about this. &#125; &#125; &#125;); &#125; &#125; catch (InterruptedException e) &#123; // We may have been interrupted because it was time to quit. if (mQuit) &#123; return; &#125; &#125; &#125; &#125; 初始化缓存，获取缓存内容 开启无限循环，从PriorityBlockingQueue中取出请求，查看请求是否有缓存(请求的key就是url)，如果队列中没有请求，则线程阻塞 如果没有缓存命中，则将请求放入网络队列，去执行网络请求 如果有缓存命中，检查缓存是否失效，如果失效也放入网络队列，去执行网络请求 如果缓存命中且有效，调用Request.parseNetworkResponse获取相应的Response 判断缓存需不要刷新，如果不需要刷新，则直接调用ExceutorDelivery.postResponse传递Response;如果缓存还需要刷新，则还是将请求放入网络请求队列，去执行网络请求获取最新结果 2.3.1 DiskBasedCache.initialize1234567891011121314151617181920212223242526272829303132333435363738@Override public synchronized void initialize() &#123; /* 如果缓存目录不存在，则创建缓存目录 */ if (!mRootDirectory.exists()) &#123; if (!mRootDirectory.mkdirs()) &#123; VolleyLog.e(\"Unable to create cache dir %s\", mRootDirectory.getAbsolutePath()); &#125; return; &#125; /* 获取缓存目录下所有文件*/ File[] files = mRootDirectory.listFiles(); if (files == null) &#123; return; &#125; /* 遍历多有缓存文件，如果能够正常读取，则为每个缓存文件生成一个CacheHeader * 并放入集合中*/ for (File file : files) &#123; BufferedInputStream fis = null; try &#123; fis = new BufferedInputStream(new FileInputStream(file)); CacheHeader entry = CacheHeader.readHeader(fis); entry.size = file.length(); putEntry(entry.key, entry); &#125; catch (IOException e) &#123; /* 如果发生异常，证明该文件不符合Volley的缓存格式 * 删除该文件*/ if (file != null) &#123; file.delete(); &#125; &#125; finally &#123; try &#123; if (fis != null) &#123; fis.close(); &#125; &#125; catch (IOException ignored) &#123; &#125; &#125; &#125; &#125; 2.4 NetworkDispatcher.run123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Override public void run() &#123; //设置该网络线程的优先级 Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); while (true) &#123; long startTimeMs = SystemClock.elapsedRealtime(); Request&lt;?&gt; request; try &#123; // 从网络请求队列中获取请求 request = mQueue.take(); &#125; catch (InterruptedException e) &#123; ... continue; &#125; try &#123; ... /* 如果请求已经被取消，则直接结束当前请求, 从当前请求集合以及等待请求列表中删除*/ if (request.isCanceled()) &#123; request.finish(\"network-discard-cancelled\"); continue; &#125; /* 设置网络流量标识*/ addTrafficStatsTag(request); /* 执行网络请求, 并获取对应的Response [2.4.1]*/ NetworkResponse networkResponse = mNetwork.performRequest(request); request.addMarker(\"network-http-complete\"); /* 如果服务端返回304同时我们已经传输了Response, 则结束该Request避免重复传输Response*/ if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123; request.finish(\"not-modified\"); continue; &#125; /* 调用Request的parseNetworkResponse解析结果*/ Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse); request.addMarker(\"network-parse-complete\"); /* 如果Request允许缓存且缓存实体不为空，则调用DiskBasedCache进行缓存 */ if (request.shouldCache() &amp;&amp; response.cacheEntry != null) &#123; mCache.put(request.getCacheKey(), response.cacheEntry); request.addMarker(\"network-cache-written\"); &#125; /* 标记Request已传输结果 */ request.markDelivered(); /* ExecutorDelivery 传输结果 */ mDelivery.postResponse(request, response); &#125; catch (VolleyError volleyError) &#123; ... //分发VolleyError &#125; catch (Exception e) &#123; ... //分发VolleyError &#125; &#125; &#125; 从网络请求队列中取出请求，如果没有请求则线程会一直阻塞 调用BasicNetwork.performRequest执行网络请求，并获取相应的Response 如果Request允许缓存且缓存实体不为空，则将Request放入缓存 调用ExecutorDelivery.postResponse传输结果 2.4.1 BasicNetwork.performRequest1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@Override public NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError &#123; long requestStart = SystemClock.elapsedRealtime(); while (true) &#123; HttpResponse httpResponse = null; byte[] responseContents = null; Map&lt;String, String&gt; responseHeaders = Collections.emptyMap(); try &#123; // Gather headers. Map&lt;String, String&gt; headers = new HashMap&lt;&gt;(); //如果请求中包含缓存字段，存储进headers addCacheHeaders(headers, request.getCacheEntry()); //调用HttpStack.performRequest, 一般情况下，HttpStack都会是HurlStack //[2.4.2] httpResponse = mHttpStack.performRequest(request, headers); StatusLine statusLine = httpResponse.getStatusLine(); int statusCode = statusLine.getStatusCode(); //解析Header responseHeaders = convertHeaders(httpResponse.getAllHeaders()); // 返回码是304 if (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123; Entry entry = request.getCacheEntry(); if (entry == null) &#123; return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, null, responseHeaders, true, SystemClock.elapsedRealtime() - requestStart); &#125; entry.responseHeaders.putAll(responseHeaders); return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, entry.data, entry.responseHeaders, true, SystemClock.elapsedRealtime() - requestStart); &#125; // Some responses such as 204s do not have content. We must check. if (httpResponse.getEntity() != null) &#123; responseContents = entityToBytes(httpResponse.getEntity()); &#125; else &#123; // Add 0 byte response as a way of honestly representing a // no-content request. responseContents = new byte[0]; &#125; ... if (statusCode &lt; 200 || statusCode &gt; 299) &#123; throw new IOException(); &#125; return new NetworkResponse(statusCode, responseContents, responseHeaders, false,SystemClock.elapsedRealtime() - requestStart); &#125; catch (SocketTimeoutException e) &#123; //[2.4.3] attempRetryonExcption(\"socket\", request, new TimeoutError()); &#125; catch .... &#123;//其他excption .... //基本都是attempRetryonExcption &#125; &#125; &#125; 2.4.2 HurlStack.performRequest由于目前Android平台基本都是使用HttpUrlConnection, 所以这里就默认使用HurlStack, 不考虑HttpClientStack 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Override public HttpResponse performRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders) throws IOException, AuthFailureError &#123; //设置Header String url = request.getUrl(); HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.putAll(request.getHeaders()); //additionalHeader一般都是用来缓存的Header map.putAll(additionalHeaders); if (mUrlRewriter != null) &#123; String rewritten = mUrlRewriter.rewriteUrl(url); if (rewritten == null) &#123; throw new IOException(\"URL blocked by rewriter: \" + url); &#125; url = rewritten; &#125; URL parsedUrl = new URL(url); //建立Http连接[2.4.2.1] HttpURLConnection connection = openConnection(parsedUrl, request); //设置请求头 for (String headerName : map.keySet()) &#123; connection.addRequestProperty(headerName, map.get(headerName)); &#125; //设置请求方法，请求参数等 setConnectionParametersForRequest(connection, request); // Initialize HttpResponse with data from the HttpURLConnection. ProtocolVersion protocolVersion = new ProtocolVersion(\"HTTP\", 1, 1); int responseCode = connection.getResponseCode(); if (responseCode == -1) &#123; ... &#125; StatusLine responseStatus = new BasicStatusLine(protocolVersion, connection.getResponseCode(), connection.getResponseMessage()); BasicHttpResponse response = new BasicHttpResponse(responseStatus); if (hasResponseBody(request.getMethod(), responseStatus.getStatusCode())) &#123; response.setEntity(entityFromConnection(connection)); &#125; for (Entry&lt;String, List&lt;String&gt;&gt; header : connection.getHeaderFields().entrySet()) &#123; if (header.getKey() != null) &#123; Header h = new BasicHeader(header.getKey(), header.getValue().get(0)); response.addHeader(h); &#125; &#125; return response; &#125; 2.4.2.1 HurlStack.openConnection123456789101112131415161718private HttpURLConnection openConnection(URL url, Request&lt;?&gt; request) throws IOException &#123; HttpURLConnection connection = createConnection(url); int timeoutMs = request.getTimeoutMs(); connection.setConnectTimeout(timeoutMs); connection.setReadTimeout(timeoutMs); connection.setUseCaches(false); connection.setDoInput(true); // use caller-provided custom SslSocketFactory, if any, for HTTPS // 如果scheme是https，设置SSLSocketFactory if (\"https\".equals(url.getProtocol()) &amp;&amp; mSslSocketFactory != null) &#123; ((HttpsURLConnection)connection).setSSLSocketFactory(mSslSocketFactory); &#125; return connection; &#125; 2.4.3 BasicNetwork.attemptRetryOnException1234567891011121314151617private static void attemptRetryOnException(String logPrefix, Request&lt;?&gt; request, VolleyError exception) throws VolleyError &#123; //默认是DefaultRetryPolicy RetryPolicy retryPolicy = request.getRetryPolicy(); int oldTimeout = request.getTimeoutMs(); try &#123; //DefaultRetryPolicy中的retry主要就是判断重试次数是否已经到达上限 retryPolicy.retry(exception); &#125; catch (VolleyError e) &#123; request.addMarker( String.format(\"%s-timeout-giveup [timeout=%s]\", logPrefix, oldTimeout)); throw e; &#125; request.addMarker(String.format(\"%s-retry [timeout=%s]\", logPrefix, oldTimeout)); &#125; 2.5. ExecutorDelivery.postResponse12345678 @Override public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable) &#123; request.markDelivered(); request.addMarker(\"post-response\"); //向线程池中提交任务//[2.5.1] mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable)); &#125; 2.5.1 ResponseDeliveryRunnable.run()123456789101112131415161718192021222324252627282930@Override public void run() &#123; if (mRequest.isCanceled()) &#123; mRequest.finish(\"canceled-at-delivery\"); return; &#125; // Deliver a normal response or error, depending. if (mResponse.isSuccess()) &#123; //如果成功会回调Response.Listener的onResponse mRequest.deliverResponse(mResponse.result); &#125; else &#123; //如果失败会回调Response.ErrorListener的onErrorResponse mRequest.deliverError(mResponse.error); &#125; if (mResponse.intermediate) &#123; //如果这是一个intermediate Response，添加Marker mRequest.addMarker(\"intermediate-response\"); &#125; else &#123; //结束当前请求 mRequest.finish(\"done\"); &#125; // If we have been provided a post-delivery runnable, run it. if (mRunnable != null) &#123; mRunnable.run(); &#125; &#125;","tags":[{"name":"开源项目学习","slug":"开源项目学习","permalink":"https://wangyun137.github.io/tags/开源项目学习/"},{"name":"Volley","slug":"Volley","permalink":"https://wangyun137.github.io/tags/Volley/"}]},{"title":"ART Runtime创建(三)--Heap的创建","date":"2017-07-24T07:00:13.000Z","path":"2017/07/24/ART-Runtime创建-三-Heap的创建/","text":"Heap的创建位于/art/runtime/runtime.cc的Runtime::Init方法中1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465bool Runtime::Init(RuntimeArgumentMap&amp;&amp; runtime_options_in) &#123; ... //-Xgc XGcOption xgc_option = runtime_options.GetOrDefault(Opt::GcOption); heap_ = new gc::Heap(runtime_options.GetOrDefault(Opt::MemoryInitialSize),//-Xms:8m //-XX:HeapGrowthLimit:256m runtime_options.GetOrDefault(Opt::HeapGrowthLimit), //-XX:HeapMinFree:512k runtime_options.GetOrDefault(Opt::HeapMinFree), //-XX:HeapMaxFree:8m runtime_options.GetOrDefault(Opt::HeapMaxFree), //-XX:HeapTargetUtilization:0.75 runtime_options.GetOrDefault(Opt::HeapTargetUtilization), //-XX:ForegroundHeapGrowthMultiplier runtime_options.GetOrDefault(Opt::ForegroundHeapGrowthMultiplier), //-Xmx:512m runtime_options.GetOrDefault(Opt::MemoryMaximumSize), //-XX:NonMovingSpaceCapacity runtime_options.GetOrDefault(Opt::NonMovingSpaceCapacity), //-Ximage:/system/framework/boot.art runtime_options.GetOrDefault(Opt::Image), //imgaeinstructionset,是一个extra_info,用来hook: null runtime_options.GetOrDefault(Opt::ImageInstructionSet), //-Xgc:kuseReadBarrier ? gc::kCollectorTypeCC : gc::kCollectorTypeDefault xgc_option.collector_type_, //-XX:BackgroundGC runtime_options.GetOrDefault(Opt::BackgroundGc), //-XX:LargeObjectSpace runtime_options.GetOrDefault(Opt::LargeObjectSpace), //-XX:LargeObjectThreshold runtime_options.GetOrDefault(Opt::LargeObjectThreshold), //-XX:ParallelGCThreads:0u runtime_options.GetOrDefault(Opt::ParallelGCThreads), //-XX:ConcGCThreads runtime_options.GetOrDefault(Opt::ConcGCThreads), //-XX:LowMemoryMode:false runtime_options.Exists(Opt::LowMemoryMode), //-XX:LongPauseLogThreshold runtime_options.GetOrDefault(Opt::LongPauseLogThreshold), //-XX:LongGCLogThreshold runtime_options.GetOrDefault(Opt::LongGCLogThreshold), //-XX:IgnoreMaxFootprint runtime_options.Exists(Opt::IgnoreMaxFootprint), //-XX:UseTLAB runtime_options.GetOrDefault(Opt::UseTLAB), //default false xgc_option.verify_pre_gc_heap_, //default kIsDebugBuild xgc_option.verify_pre_sweeping_heap_, //default false xgc_option.verify_post_gc_heap_, //default kIsDebugBuild xgc_option.verify_pre_gc_rosalloc_, // default false xgc_option.verify_pre_sweeping_rosalloc_, //default false xgc_option.verify_post_gc_rosalloc_, //default false xgc_option.gcstress_, //-XX:EnableHSpaceCompactForOOM runtime_options.GetOrDefault(Opt::EnableHSpaceCompactForOOM), //-XX:HspaceCompactForOOMMinIntervalMs runtime_options.GetOrDefault(Opt::HSpaceCompactForOOMMinIntervalsMs)); ...&#125; 一. 相关知识预热1.1 Garbage Collection Type垃圾回收的算法有多种，如MarkSweep-标记清楚算法,MarkCompact-标记整理算法,Copying-复制算法等等，之前的Dalvik一直使用的是MarkSweep算法，ART则在MarkSweep的基础上添加了对其他垃圾回收算法的支持，具体的算法可以通过-Xgc指定，如果没有特别指定，则使用默认指定的：123456// /art/smdline/cmdline_types.hgc::CollectorType collector_type_ = kUseReadBarrier ? // If RB is enabled (currently a build-time decision), // use CC as the default GC. gc::kCollectorTypeCC : gc::kCollectorTypeDefault; kUseReadBarrier定义在/art/runtime/globals.h 123456789101112131415161718192021#ifdef USE_BAKER_READ_BARRIERstatic constexpr bool kUseBakerReadBarrier = true;#elsestatic constexpr bool kUseBakerReadBarrier = false;#endif#ifdef USE_BROOKS_READ_BARRIERstatic constexpr bool kUseBrooksReadBarrier = true;#elsestatic constexpr bool kUseBrooksReadBarrier = false;#endif#ifdef USE_TABLE_LOOKUP_READ_BARRIERstatic constexpr bool kUseTableLookupReadBarrier = true;#elsestatic constexpr bool kUseTableLookupReadBarrier = false;#endifstatic constexpr bool kUseBakerOrBrooksReadBarrier = kUseBakerReadBarrier || kUseBrooksReadBarrier;static constexpr bool kUseReadBarrier = kUseBakerReadBarrier || kUseBrooksReadBarrier || kUseTableLookupReadBarrier; kUseReadBarrier根据三个编译宏决定true或false,只要这个三个编译宏中有一个存在，则kUseReadBarrier=true gc::kCollectorTypeCC和gc::kCollectorTypeDefault定义在/art/runtime/gc/collector_type.h 123456789101112131415161718192021222324252627282930313233343536373839enum CollectorType &#123; // No collector selected. kCollectorTypeNone, //普通Mark-Sweep kCollectorTypeMS, // 并发Mark-Sweep. kCollectorTypeCMS, // Semi-space和Mark-Sweep的混合 kCollectorTypeSS, // Generational Semi-space kCollectorTypeGSS, // Mark compact kCollectorTypeMC, // Heap trimming collector, doesn't do any actual collecting. kCollectorTypeHeapTrim, // A (mostly) concurrent copying collector. kCollectorTypeCC, // Instrumentation critical section fake collector. kCollectorTypeInstrumentation, // Fake collector for adding or removing application image spaces. kCollectorTypeAddRemoveAppImageSpace, // A homogeneous space compaction collector used in background transition // when both foreground and background collector are CMS. kCollectorTypeHomogeneousSpaceCompact, // Class linker fake collector. kCollectorTypeClassLinker,&#125;;static constexpr CollectorType kCollectorTypeDefault =#if ART_DEFAULT_GC_TYPE_IS_CMS kCollectorTypeCMS#elif ART_DEFAULT_GC_TYPE_IS_SS kCollectorTypeSS#elif ART_DEFAULT_GC_TYPE_IS_GSS kCollectorTypeGSS#else kCollectorTypeCMS#error \"ART default GC type must be set\"#endif 从代码中的定义可以看到，如果kUseReadBarrier＝true，则垃圾回收算法使用Concurrent-Copying,否则默认算法，默认算法根据编译宏选择，没有特别指定的情况下使用Concurrent Mark-Sweep 二. Heap::Heap()2.1 构造函数声明123456789101112131415161718192021222324252627282930Heap(size_t initial_size,//堆的初始大小 size_t growth_limit,//堆的增长上限 size_t min_free,//堆的最小空闲值 size_t max_free,//堆的最大空闲值 double target_utilization,//堆的目标利用率 double foreground_heap_growth_multiplier,//前台堆增长因子(乘数) size_t capacity,//堆的容量 size_t non_moving_space_capacity,//存储不可移动对象的space的容量 const std::string&amp; original_image_file_name,//image文件路径 InstructionSet image_instruction_set,//指令集 CollectorType foreground_collector_type,//前台回收器类型 CollectorType background_collector_type,//后台回收器类型 space::LargeObjectSpaceType large_object_space_type,//存储大对象的space类型 size_t large_object_threshold,//大对象数量的阈值 size_t parallel_gc_threads,//GC暂停阶段用于同时执行GC任务的线程数 size_t conc_gc_threads,//并行GC的线程数 bool low_memory_mode,//是否是low memory mode size_t long_pause_threshold,//GC造成应用程序暂停的时间阀值,超过则输出log size_t long_gc_threshold,//GC时间阀值,超过则输出log bool ignore_max_footprint,//不对堆的增长进行限制,堆可以增长到它的最大容量 bool use_tlab,//是否开启TLAB选项 bool verify_pre_gc_heap,//是否在开始GC前验证堆 bool verify_pre_sweeping_heap,//是否在GC执行清扫前验证堆 bool verify_post_gc_heap,//是否在GC完成清扫后验证堆 bool verify_pre_gc_rosalloc,//是否在开始GC前验证RosAllocSpace bool verify_pre_sweeping_rosalloc,//是否在GC执行清扫前验证RosAllocSpace bool verify_post_gc_rosalloc,//是否在GC完成清扫后验证RosAllocSpace bool gc_stress_mode, bool use_homogeneous_space_compaction,//是否使用homogeneous space compaction来避免OOM uint64_t min_interval_homogeneous_space_compaction_by_oom);//两次OOM引起homogeneous space compaction时间间隔 2.2 构造函数实现2.2.1 字段初始化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164Heap::Heap(...) : //space::MallocSpace*,存放不可移动对象 non_moving_space_(nullptr), //kAllocatorTypeROSAlloc space rosalloc_space_(nullptr), //kAllocatorTypeDlMalloc space dlmalloc_space_(nullptr), //GC操作的主要space,这个space不是dlmalloc_space_就是rosalloc_space_ main_space_(nullptr), //回收器类型 collector_type_(kCollectorTypeNone), //前台回收器类型 foreground_collector_type_(foreground_collector_type), //后台回收器类型 background_collector_type_(background_collector_type), //希望的回收器类型,如果它!=collector_type_, heap trimming daemon会transitions堆 desired_collector_type_(foreground_collector_type_), //Mutex* pending_task_lock_(nullptr), //GC暂停阶段用于同时执行GC任务的线程数 parallel_gc_threads_(parallel_gc_threads), //concurrent gc线程数 conc_gc_threads_(conc_gc_threads), //是否是低内存模式 low_memory_mode_(low_memory_mode), //GC造成应用程序暂停的时间阀值,超过则输出log long_pause_log_threshold_(long_pause_log_threshold), //GC时间阀值,超过则输出log long_gc_log_threshold_(long_gc_log_threshold), //是否对堆的增长不限制 ignore_max_footprint_(ignore_max_footprint), //zygote space创建时的锁, Mutex zygote_creation_lock_(\"zygote creation lock\", kZygoteCreationLock), //space::ZygoteSpace 在zygote space创建之前不会包含大对象 zygote_space_(nullptr), //大对象数量的阈值 large_object_threshold_(large_object_threshold), //跟踪在JNI critical section中有多少个线程 disable_thread_flip_count_(0), thread_flip_running_(false), //正在运行的回收器类型 collector_type_running_(kCollectorTypeNone), //最后一次运行的GC类型 last_gc_type_(collector::kGcTypeNone), //下一次将要运行的GC类型 next_gc_type_(collector::kGcTypePartial), //堆的容量 capacity_(capacity), //堆的增长上限 growth_limit_(growth_limit), //分配对象的上限数，一旦超过着搁置会引起一次GC max_allowed_footprint_(initial_size), //由registerNativeAllocation请求的一次concurrent GC需要的临界线, size_t native_footprint_gc_watermark_(initial_size), //bool, 是否需要在下一次的native allocation中运行finalizers native_need_to_run_finalization_(false), //当num_bytes_allocated_超过该值后,concurrent GC会启动 concurrent_start_bytes_(std::numeric_limits&lt;size_t&gt;::max()), //总共释放的bytes自从heap创建以来 total_bytes_freed_ever_(0), //总共释放的对象自从heap创建以来 total_objects_freed_ever_(0), //当前分配的bytes数量.每次释放和分配以后都会更新 num_bytes_allocated_(0), //native分配的bytes数量 native_bytes_allocated_(0), //Mutex native_histogram_lock_(\"Native allocation lock\"), //Histogram&lt;uint64_t&gt;,native分配的统计图 native_allocation_histogram_(\"Native allocation sizes\", 1U, kNativeAllocationHistogramBuckets), //native释放的统计图 native_free_histogram_(\"Native free sizes\", 1U, kNativeAllocationHistogramBuckets), num_bytes_freed_revoke_(0), verify_missing_card_marks_(false), verify_system_weaks_(false), //是否在开始GC前验证堆 verify_pre_gc_heap_(verify_pre_gc_heap), //是否在GC执行清扫前验证堆 verify_pre_sweeping_heap_(verify_pre_sweeping_heap), //是否在GC完成清扫后验证堆 verify_post_gc_heap_(verify_post_gc_heap), //是否验证ModUnionTable verify_mod_union_table_(false), //是否在开始GC前验证RosAllocSpace verify_pre_gc_rosalloc_(verify_pre_gc_rosalloc), //是否在GC执行清扫前验证RosAllocSpace verify_pre_sweeping_rosalloc_(verify_pre_sweeping_rosalloc), //是否在GC完成清扫后验证RosAllocSpace verify_post_gc_rosalloc_(verify_post_gc_rosalloc), /* For GC a lot mode, we limit the allocations stacks to be kGcAlotInterval allocations. This * causes a lot of GC since we do a GC for alloc whenever the stack is full. When heap * verification is enabled, we limit the size of allocation stacks to speed up their * searching. */ //分配栈最大数量 max_allocation_stack_size_(kGCALotMode ? kGcAlotAllocationStackSize : (kVerifyObjectSupport &gt; kVerifyObjectModeFast) ? kVerifyObjectAllocationStackSize : kDefaultAllocationStackSize), //当前分配器 current_allocator_(kAllocatorTypeDlMalloc), //当前不可移动对象分配器 current_non_moving_allocator_(kAllocatorTypeNonMoving), //阶跃型指针space bump_pointer_space_(nullptr), //临时space,Semispace回收器会将对象拷贝至这里 temp_space_(nullptr), //RegionSpace 有一系列大小相等的区域组成 region_space_(nullptr), //最小空余内存 min_free_(min_free), //最大空余内存 max_free_(max_free), //堆目标利用率 target_utilization_(target_utilization), //前台堆增长因子 foreground_heap_growth_multiplier_(foreground_heap_growth_multiplier), //mutators暂停等待GC的总共时间 total_wait_time_(0), //VerifyObjectMode, 目前heap verification的状态 verify_object_mode_(kVerifyObjectModeDisabled), //Compacting GC disable count disable_moving_gc_count_(0), is_running_on_memory_tool_(Runtime::Current()-&gt;IsRunningOnMemoryTool()), use_tlab_(use_tlab), //homogeneous space compaction时的新main space main_space_backup_(nullptr), //两次OOM引起homogeneous space compaction时间间隔 min_interval_homogeneous_space_compaction_by_oom_( min_interval_homogeneous_space_compaction_by_oom), //上一次由OOM引起的HomogeneousSpaceCompact的时间 last_time_homogeneous_space_compaction_by_oom_(NanoTime()), //CollectorTransitionTask* pending_collector_transition_(nullptr), //HeapTrimTask* pending_heap_trim_(nullptr), //是否使用homogeneous space compaction来避免OOM use_homogeneous_space_compaction_for_oom_(use_homogeneous_space_compaction_for_oom), //如果当前的回收工作导致一些线程暂停,则该值为true running_collection_is_blocking_(false), //blocking gc 数量 blocking_gc_count_(0U), //blocking gc总共持续时间 blocking_gc_time_(0U), //GC count rate统计图最后已更新时间 last_update_time_gc_count_rate_histograms_( // Round down by the window duration. (NanoTime() / kGcCountRateHistogramWindowDuration) * kGcCountRateHistogramWindowDuration), //在上一个window运行的GC数量 gc_count_last_window_(0U), //在上一个window运行的blocking GC数量 blocking_gc_count_last_window_(0U), //每一个window的GC调用统计图 gc_count_rate_histogram_(\"gc count rate histogram\", 1U, kGcCountRateMaxBucketCount), //每一个window的blocking GC调用统计图 blocking_gc_count_rate_histogram_(\"blocking gc count rate histogram\", 1U, kGcCountRateMaxBucketCount), //是否支持allocation tracking alloc_tracking_enabled_(false), //Mutex* backtrace_lock_(nullptr), seen_backtrace_count_(0u), unique_backtrace_count_(0u), gc_disabled_for_shutdown_(false) &#123; 2.2.2 具体创建逻辑Heap的构造函数的代码较多，不过整体逻辑比较清晰，整体逻辑可以分为以下几块: 判断当前是否在zygote进程,如果不在zygote，将background_collector_type_设为和foreground_collector_type_一样，并检查传入的desired_collector_type_和collector_type_是否一样，如果不一样，则将collector_type_设为desired_collector_type_ 1234567891011Runtime* const runtime = Runtime::Current(); //判断当前是否是zygote模式,如果不是判断后台回收器类型是否和前台回收器相等,不想等,则设为相等 const bool is_zygote = runtime-&gt;IsZygote(); if (!is_zygote) &#123; if (background_collector_type_ != foreground_collector_type_) &#123; ... background_collector_type_ = foreground_collector_type_; &#125; &#125; //检查collector_type_是否和desired_collector_type_相等,不等的话将collector_type_置为desired_collector_type_ ChangeCollector(desired_collector_type_); 创建两个HeapBitmap(live_bitmap_:用来记录上次GC之后还存活的对象;mark_bitmap_:用来记录当前GC中还存活的对象) 12live_bitmap_.reset(new accounting::HeapBitmap(this));mark_bitmap_.reset(new accounting::HeapBitmap(this)); 如果foreground_collector_type_是Concurrent-Copying,设置requested_alloc_space_begin即alloc space的起始地址为(如果前台回收器是CC则是300MB-non_moving_space_capacity，否则是nullptr) 1234if (foreground_collector_type_ == kCollectorTypeCC) &#123; ... requested_alloc_space_begin = reinterpret_cast&lt;uint8_t*&gt;(300 * MB) - non_moving_space_capacity;&#125; 根据传入的image文件路径(/system/framework/boot.art)创建ImageSpace,在ImageSpace后面紧跟的是/system/framework/boot.oat,如果创建成功，将requested_alloc_space_begin指向boot.oat地址的末尾；如果创建ImageSpace失败，删除已加载的Space，将requested_alloc_space_begin指回原来的(300MB-non_moving_space_capacity) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//创建ImageSpace, image_file_name是/system/framework/boot.artif (!image_file_name.empty()) &#123; std::vector&lt;std::string&gt; image_file_names; image_file_names.push_back(image_file_name); std::vector&lt;space::Space*&gt; added_image_spaces; uint8_t* const original_requested_alloc_space_begin = requested_alloc_space_begin; for (size_t index = 0; index &lt; image_file_names.size(); ++index) &#123; std::string&amp; image_name = image_file_names[index];///system/framework/boot.art std::string error_msg; //创建boot_image_space space::ImageSpace* boot_image_space = space::ImageSpace::CreateBootImage( image_name.c_str(), image_instruction_set, index &gt; 0, &amp;error_msg); //创建boot_image_space成功 if (boot_image_space != nullptr) &#123; /* 根据boot_image_space是否时连续空间，将boot_image_space添加到对应的Space列表，并在live_bitmap_和mark_bitmap_中添加对应的位图 */ AddSpace(boot_image_space); added_image_spaces.push_back(boot_image_space); //Oat文件即boot.oat紧跟在boot_image_space末尾 uint8_t* oat_file_end_addr = boot_image_space-&gt;GetImageHeader().GetOatFileEnd(); ... //将boot.oat的地址按页大小(pageSize)对齐 requested_alloc_space_begin = AlignUp(oat_file_end_addr, kPageSize); boot_image_spaces_.push_back(boot_image_space); if (index == 0) &#123; //如果是第一块Space,检查是否还有其他的oat文件需要加载 const OatFile* boot_oat_file = boot_image_space-&gt;GetOatFile(); if (boot_oat_file == nullptr) &#123; continue; &#125; //如果还有其他的oat文件，根据OatHeader获取boot_classpath,再根据boot_classpath生成 //oat文件完整路径，将完整路径添加进image文件列表，从而可以在下次循环中加载 const OatHeader&amp; boot_oat_header = boot_oat_file-&gt;GetOatHeader(); const char* boot_classpath = boot_oat_header.GetStoreValueByKey(OatHeader::kBootClassPathKey); if (boot_classpath == nullptr) &#123; continue; &#125; space::ImageSpace::CreateMultiImageLocations(image_file_name, boot_classpath, &amp;image_file_names); &#125; &#125; else &#123; //创建ImageSpace失败, 删除已加载的Space for (space::Space* loaded_space : added_image_spaces) &#123; RemoveSpace(loaded_space); delete loaded_space; &#125; boot_image_spaces_.clear(); requested_alloc_space_begin = original_requested_alloc_space_begin; break; &#125; &#125;&#125; 判断是否支持Homogeneous-Space-Compact.当background_collector_type_是Homogeneous-Space-Compact或者foreground_collector_type_不是GSS(Generational Semi-Space)和CC(Concurrent-Copying)时，支持Homogeneous-Space-Compact 12345678if (foreground_collector_type_ == kCollectorTypeGSS || foreground_collector_type_ == kCollectorTypeCC) &#123; use_homogeneous_space_compaction_for_oom_ = false;&#125;//如果后台回收器是homogeneous space compact或者前台回收器不是GSS和CC时，支持homogeneous space compactbool support_homogeneous_space_compaction = background_collector_type_ == gc::kCollectorTypeHomogeneousSpaceCompact || use_homogeneous_space_compaction_for_oom_; 判断是否给Non-Moving Space独立的地址.只要以下满足四个条件中的一项就会给Non-Moving Space独立地址(处于Zygote;支持Homogeneous-Space-Compact(foreground_collector_type_不是GSS或者不是CC);foreground_collector_type_可以移动对象;background_collector_type_可以移动对象), 之后再排除foreground_collector_type_是GSS的情况，即前台回收器是GSS时，不给Non-Moving Space独立地址 123456789//如果当前处于Zygote模式或者支持homogeneous space compact或者前台回收器是可以移动对象的或者后台回收器也可以移动对象时//给non_moving_space一个独立的地址bool separate_non_moving_space = is_zygote || support_homogeneous_space_compaction || IsMovingGc(foreground_collector_type_) || IsMovingGc(background_collector_type_);//再次检查前台进程是否是GSS,如果是，则不给non_moving_space_一个独立的地址if (foreground_collector_type_ == kCollectorTypeGSS) &#123; separate_non_moving_space = false;&#125; 只要传入的type是SS,GSS,CC,MC,Homogeneous-Space-Compact其中一个时,IsMovingGc返回的都是true 创建两个内存映射MemMap12std::unique_ptr&lt;MemMap&gt; main_mem_map_1;std::unique_ptr&lt;MemMap&gt; main_mem_map_2; 如果之前创建ImageSpace失败同时foreground_collector_type_是MarkSweep而且此时的Runtime由dex2oat创建即处于dex2oat进程中时，将requested_alloc_space_begin指向kAllocSpaceBeginForDeterministicAoT 12345678// 如果前台回收器是MS(MarkSweep)且requested_alloc_space_begin// 是null(即之前ImageSpace创建失败)同时当前是dex2oat程序// 将requested_alloc_space_begin设为kAllocSpaceBeginForDeterministicAoTif (foreground_collector_type_ == kCollectorTypeMS &amp;&amp; requested_alloc_space_begin == nullptr &amp;&amp; Runtime::Current()-&gt;IsAotCompiler()) &#123; requested_alloc_space_begin = reinterpret_cast&lt;uint8_t*&gt;(kAllocSpaceBeginForDeterministicAoT);&#125; 初始化request_begin.如果Non-Moving Space有独立地址，根据当前是否是zygote确定Non-Moving Space的名字,之后创建一块匿名内存映射，由non_moving_space_mem_map指向，non_moving_space_mem_map紧跟在requested_alloc_space_begin后面，如果ImageSpace创建成功，就是紧跟在ImageSpace+boot.oat后面，否则紧跟在kAllocSpaceBeginForDeterministicAoT后面,最后设置request_begin为300MB,即其他Space的起始地址为300MB 123456789101112131415161718192021uint8_t* request_begin = requested_alloc_space_begin;if (request_begin != nullptr &amp;&amp; separate_non_moving_space) &#123; request_begin += non_moving_space_capacity;&#125;std::string error_str;std::unique_ptr&lt;MemMap&gt; non_moving_space_mem_map;//如果确定给non moving space一块独立的地址if (separate_non_moving_space) &#123; ScopedTrace trace2(\"Create separate non moving space\"); // 如果当前正在Zygote当中，将non moving space设为zygote space const char* space_name = is_zygote ? kZygoteSpaceName: kNonMovingSpaceName; //创建匿名内存映射 //non moving sapce紧跟在requested_alloc_space_begin后面(即如果ImageSpace创建成功，紧跟在ImageSpace + boo.oat后面) non_moving_space_mem_map.reset( MemMap::MapAnonymous(space_name, requested_alloc_space_begin, non_moving_space_capacity, PROT_READ | PROT_WRITE, true, false, &amp;error_str)); ... // 如果要给non moving space一个独立的地址, 将其他Space的起始地址设为300MB,由request_begin指向 request_begin = reinterpret_cast&lt;uint8_t*&gt;(300 * MB);&#125; 如果foreground_collector_type_不是CC,初始化之前创造的main_mem_map_1,这块内存的作用是作为MarkSweep的Main Space或者Compact GC的From-Bump-Space.当Non-Moving Space有独立地址且当前不处于Zygote时，紧跟在300MB后面创建匿名内存映射;否则紧跟在ImageSpace+boot.oat后面创建匿名内存映射 1234567891011121314151617181920//如果前台回收器不是CC，创建第一块匿名共享内存,由main_mem_map_1指向，这块内存的作用是作为Compact GC的From Bump Space或者//MarkSweep的Main Spaceif (foreground_collector_type_ != kCollectorTypeCC) &#123; ScopedTrace trace2(\"Create main mem map\"); if (separate_non_moving_space || !is_zygote) &#123; //如果non moving space有独立地址或者当前不是zygote，则main_mem_map_1紧跟在 request_begin后面，即300MB后面 //名字是main space main_mem_map_1.reset(MapAnonymousPreferredAddress(kMemMapSpaceName[0], request_begin, capacity_, &amp;error_str)); &#125; else &#123; //如果non-moving space有独立地址且当前处于zygote或者non-moving space没有独立地址， //则main space必须紧跟在ImageSpace后面,这样zygote space就会临近ImageSpace main_mem_map_1.reset(MemMap::MapAnonymous(kMemMapSpaceName[0], request_begin, capacity_, PROT_READ | PROT_WRITE, true, false, &amp;error_str)); &#125; ...&#125; 如果支持Homogeneous-Space-Compact或者background_collector_type_和foreground_collector_type_其中一个是SS时，创建第二块匿名内存映射main_mem_map_2 12345678910//如果支持homogeneous space compact或者后台回收器和前台回收器中有一个为为SS(Semi Space)时，创建第二块匿名共享内存//由main_mem_map_2指向if (support_homogeneous_space_compaction || background_collector_type_ == kCollectorTypeSS || foreground_collector_type_ == kCollectorTypeSS) &#123; ScopedTrace trace2(\"Create main mem map 2\"); main_mem_map_2.reset(MapAnonymousPreferredAddress(kMemMapSpaceName[1], main_mem_map_1-&gt;End(), capacity_, &amp;error_str)); ...&#125; 如果Non-Moving Space有独立地址，则之前已经创建了匿名内存映射non_moving_space_mem_map，现在将这块内存封装成DlMallocSpace,由non-moving_space指向，并将这块Space添加至Space列表中 1234567891011121314//如果non moving space有独立的地址时，将non_moving_space_mem_map封装成Non-Moving Space(space::MallocSpace)if (separate_non_moving_space) &#123; ScopedTrace trace2(\"Add non moving space\"); //Non-Moving Space必须是dlmalloc，因为目前并不支持多个rosalloc spaces const size_t size = non_moving_space_mem_map-&gt;Size(); non_moving_space_ = space::DlMallocSpace::CreateFromMemMap( non_moving_space_mem_map.release(), \"zygote / non moving space\", kDefaultStartingSize, initial_size, size, size, false); //设置Non-Moving Space大小限制 non_moving_space_-&gt;SetFootprintLimit(non_moving_space_-&gt;Capacity()); ... //将non_moving_space_添加至space列表中 AddSpace(non_moving_space_);&#125; 根据条件处理之前创建的另外两块匿名内存映射main_mem_map_1和main_mem_map_2.因为在之前的逻辑中，当foreground_collector_type_是CC时，并没有创建main_mem_map_1匿名内存映射，所以如果foreground_collector_type_恰好是CC时，紧跟request_begin(如果Non-Moving Space有独立地址，则是300MB,否则是ImageSpace+boot.oat)创建一个RegionSpace，由region_space_指向; 如果foreground_collector_type_不是CC时，也要分两种情况：(1)foreground_collector_type_是SS,MC,Homogeneous-Space-Compact中的一个;(2)foreground_collector_type_是MarkSweep, Compact MarkSweep或者GSS. 对于第一种情况来说，将main_mem_map_1封装成BumpPointerSpace1并添加至space列表，由bump_pointer_space_指向，将main_mem_map_2封装成另一块BumpPointerSpace2同样添加至space列表,由temp_space_指向;对于第二种情况，首先将main_mem_map_1封装成MainSpace同时添加至space列表，之后如果Non-Moving Space没有独立地址，则将non_moving_space_指向MainSpace,即MainSpace和Non-Moving Space共用同一块内存，接着判断如果foreground_collectortype是GSS时，调用BumpPointerSpace::Craete直接创建BumpPointerSpace1(bump_pointer_space_)和BumpPointerSpace2(temp_space_)并依次添加至space列表;如果foreground_collector_type_不是GSS时，即MarkSweep或Compact MarkSweep,且main_mem_map_2不为空时(如果支持HomogeneousSpaceCompact),将main_mem_map_2封装成Backup Space,并添加至space列表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253if (foreground_collector_type_ == kCollectorTypeCC) &#123; // 如果前台回收器是CC(Concurrent Copying),创建RegionSpace,并将RegionSpace添加至space列表 region_space_ = space::RegionSpace::Create(\"Region space\", capacity_ * 2, request_begin); AddSpace(region_space_);&#125; else if (IsMovingGc(foreground_collector_type_) &amp;&amp; foreground_collector_type_ != kCollectorTypeGSS) &#123; //如果前台回收器是除了GSS(Generational Semi-Space)以外的Compact GC,将main_mem_map_1封装成BumpPointerSpace //并将bump_pointer_space_添加至space列表 // TODO: Place bump-pointer spaces somewhere to minimize size of card table. bump_pointer_space_ = space::BumpPointerSpace::CreateFromMemMap(\"Bump pointer space 1\", main_mem_map_1.release()); ... AddSpace(bump_pointer_space_); //将main_mem_map_2封装成第二块BumpPointerSpace，由temp_space_指向，同时将temp_space_添加至space列表 temp_space_ = space::BumpPointerSpace::CreateFromMemMap(\"Bump pointer space 2\", main_mem_map_2.release()); ... AddSpace(temp_space_); ...&#125; else &#123; //如果前台回收器不是Compact GC即MarkSweep或者是GSS,则在main_mem_map_1创建Main Space,并将Main Space添加至space列表 CreateMainMallocSpace(main_mem_map_1.release(), initial_size, growth_limit_, capacity_); ... AddSpace(main_space_); if (!separate_non_moving_space) &#123; //如果Non-Moving Space没有独立地址，则将non_moving_space_指向main_space_,即Non-Moving Space和Main Space是同一块Space non_moving_space_ = main_space_; ... &#125; if (foreground_collector_type_ == kCollectorTypeGSS) &#123; .... //如果前台回收器是GSS, 并创建BumpPointerSpace，由bump_pointer_space_指向 //同时将bump_pointer_space_添加至space列表 main_mem_map_2.release(); bump_pointer_space_ = space::BumpPointerSpace::Create(\"Bump pointer space 1\", kGSSBumpPointerSpaceCapacity, nullptr); ... AddSpace(bump_pointer_space_); //创建第二块BumpPointerSpace,由temp_space_指向,并将temp_space_添加至space列表 temp_space_ = space::BumpPointerSpace::Create(\"Bump pointer space 2\", kGSSBumpPointerSpaceCapacity, nullptr); ... AddSpace(temp_space_); &#125; else if (main_mem_map_2.get() != nullptr) &#123; //此时前台回收器根据排除法只剩MarkSweep了，将main_mem_map_2封装成Backup Space,由main_space_backup_指向 //同时将main_space_backup_添加至space列表,如果kUseRosAlloc为true,main_space_backup_为RosAllocSpace，否则为DlMallocSpace const char* name = kUseRosAlloc ? kRosAllocSpaceName[1] : kDlMallocSpaceName[1]; main_space_backup_.reset(CreateMallocSpaceFromMemMap(main_mem_map_2.release(), initial_size, growth_limit_, capacity_, name, true)); ... AddSpace(main_space_backup_.get()); &#125;&#125; 创建大对象存储空间. 123456789101112131415161718// 创建LargeObjectSpace(大对象存储空间)if (large_object_space_type == space::LargeObjectSpaceType::kFreeList) &#123; //如果LargeObjectSpace类型是FreeList，创建FreeList类型的LargeObjectSpace large_object_space_ = space::FreeListSpace::Create(\"free list large object space\", nullptr, capacity_); ...&#125; else if (large_object_space_type == space::LargeObjectSpaceType::kMap) &#123; //创建相互独立的内存快组成的LargeObjectSpace large_object_space_ = space::LargeObjectMapSpace::Create(\"mem map large object space\"); ...&#125; else &#123; large_object_threshold_ = std::numeric_limits&lt;size_t&gt;::max(); large_object_space_ = nullptr;&#125;//如果LargeObjectSpace不为空，则添加至Space列表if (large_object_space_ != nullptr) &#123; AddSpace(large_object_space_);&#125; 如果foreground_collector_type_是MarkSweep或Compact MarkSweep且创建了Backup Space时，由于Backup Space占用的额外的空间会降低GC速度,所以移除Backup Space;之后创建CardTable(Card Table是为了记录在垃圾收集过程中对象的引用情况的), ModUnionTable(来记录ImageSpace对ZygoteSpace引用情况的ModUnionTable), RememberSet(用来记录Non-moving Space对其他Space引用情况的RememberedSet, GSS时不会创建，CC, SS, MC, HomogeneousSpaceCompact时根据collector::SemiSpace::kUseRememberedSet == true判断, MS,CMS时根据Non-Moving Space有没有独立地址加collector::SemiSpace::kUseRememberedSet == true判断) 12345678910111213141516171819202122232425262728293031323334353637//获取连续空间的起始地址和结束地址uint8_t* heap_begin = continuous_spaces_.front()-&gt;Begin();uint8_t* heap_end = continuous_spaces_.back()-&gt;Limit();size_t heap_capacity = heap_end - heap_begin;//移除main_space_backup_,此时foreground_collector_type_是MarkSweep//因为Backup Space的额外的未使用的空间降低了GC速度if (main_space_backup_.get() != nullptr) &#123; RemoveSpace(main_space_backup_.get());&#125;...// 创建card table,因为不知道在low_4gb模式下,app image会在何处定位，// 所以card table将会从64KB开始覆盖整个4GB的低地址，64KB以前的地址预留给kernelstatic constexpr size_t kMinHeapAddress = 4 * KB;card_table_.reset(accounting::CardTable::Create(reinterpret_cast&lt;uint8_t*&gt;(kMinHeapAddress), 4 * GB - kMinHeapAddress));....//如果前台回收器是CC(Concurrent Copying)同时kUseTableLookupReadBarrier=true,创建ReadBarrierTableif (foreground_collector_type_ == kCollectorTypeCC &amp;&amp; kUseTableLookupReadBarrier) &#123; rb_table_.reset(new accounting::ReadBarrierTable()); ...&#125;if (HasBootImageSpace()) &#123; // 如果有ImageSpace,则创建用来记录ImageSpace对ZygoteSpace引用情况的ModUnionTable for (space::ImageSpace* image_space : GetBootImageSpaces()) &#123; accounting::ModUnionTable* mod_union_table = new accounting::ModUnionTableToZygoteAllocspace( \"Image mod-union table\", this, image_space); ... AddModUnionTable(mod_union_table); &#125;&#125;//如果Non-moving Space有独立地址而且kUseRememberedSet=true,//创建用来记录Non-moving Space对其他Space引用情况的RememberedSetif (collector::SemiSpace::kUseRememberedSet &amp;&amp; non_moving_space_ != main_space_) &#123; accounting::RememberedSet* non_moving_space_rem_set = new accounting::RememberedSet(\"Non-moving space remembered set\", this, non_moving_space_); ... AddRememberedSet(non_moving_space_rem_set);&#125; 创建Mark-Stack,Allocation-Stack,Live-Stack;创建之后GC需要用到的的锁;创建TaskProcessor,ReferenceProcessor;如果前后台回收器有一个是CMS,则创建一组包含三个支持并发的Collector:MarkSweep, PartialMarkSweep, StickyMarkSweep回收器; 如果前后台回收器有一个是MS,则创建一组包含三个不支持并发的Collector:MarkSweep, PartialMarkSweep, StickyMarkSweep回收器;之后再根据条件创建Semi-Space Collector(SS或GSS时创建),Concurrent-Copying Collector(CC时创建),Mark Compact Collector(MS,CMSshichu) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// TODO: Count objects in the image space here?num_bytes_allocated_.StoreRelaxed(0);// 创建Mark-Stack, Allocation-Stack, Live-Stackmark_stack_.reset(accounting::ObjectStack::Create(\"mark stack\", kDefaultMarkStackSize, kDefaultMarkStackSize));const size_t alloc_stack_capacity = max_allocation_stack_size_ + kAllocationStackReserveSize;allocation_stack_.reset(accounting::ObjectStack::Create(\"allocation stack\", max_allocation_stack_size_, alloc_stack_capacity));live_stack_.reset(accounting::ObjectStack::Create(\"live stack\", max_allocation_stack_size_, alloc_stack_capacity));// 创建gc_complete_lock_,thread_flip_lock_gc_complete_lock_ = new Mutex(\"GC complete lock\");gc_complete_cond_.reset(new ConditionVariable(\"GC complete condition variable\",*gc_complete_lock_));thread_flip_lock_ = new Mutex(\"GC thread flip lock\");thread_flip_cond_.reset(new ConditionVariable(\"GC thread flip condition variable\",*thread_flip_lock_));//创建TaskProcessor, ReferenceProcessor, pending_task_lock_task_processor_.reset(new TaskProcessor());reference_processor_.reset(new ReferenceProcessor());pending_task_lock_ = new Mutex(\"Pending task lock\");if (ignore_max_footprint_) &#123; //如果不限制堆的增长，则将堆的最大限制数设为最大 SetIdealFootprint(std::numeric_limits&lt;size_t&gt;::max()); //将concurrent gc的启动值也设为最大，即只有堆达到最大时，才开启concurrent gc concurrent_start_bytes_ = std::numeric_limits&lt;size_t&gt;::max();&#125;...// 如果前后台回收器有一个是CMS,则创建一组包含三个支持并发的Collector:MarkSweep, PartialMarkSweep, StickyMarkSweep回收器// 如果前后台回收器有一个是MS,则创建一组包含三个不支持并发的Collector:MarkSweep, PartialMarkSweep, StickyMarkSweep回收器for (size_t i = 0; i &lt; 2; ++i) &#123; const bool concurrent = i != 0; if ((MayUseCollector(kCollectorTypeCMS) &amp;&amp; concurrent) || (MayUseCollector(kCollectorTypeMS) &amp;&amp; !concurrent)) &#123; garbage_collectors_.push_back(new collector::MarkSweep(this, concurrent)); garbage_collectors_.push_back(new collector::PartialMarkSweep(this, concurrent)); garbage_collectors_.push_back(new collector::StickyMarkSweep(this, concurrent)); &#125;&#125;if (kMovingCollector) &#123;//kMovingCollector=true if (MayUseCollector(kCollectorTypeSS) || MayUseCollector(kCollectorTypeGSS) || MayUseCollector(kCollectorTypeHomogeneousSpaceCompact) || use_homogeneous_space_compaction_for_oom_) &#123; //如果前后台回收器中某一个是SS,GSS,HomogeneousSpaceCompact三者其中一个或者 //使用homogeneous space compaction来避免OOM时，再创键一个Semi-Space Collector const bool generational = foreground_collector_type_ == kCollectorTypeGSS; semi_space_collector_ = new collector::SemiSpace(this, generational, generational ? \"generational\" : \"\"); garbage_collectors_.push_back(semi_space_collector_); &#125; if (MayUseCollector(kCollectorTypeCC)) &#123; //如果前后台回收器中某一个是CC,再创建一个ConcurrentCopying Collector concurrent_copying_collector_ = new collector::ConcurrentCopying(this); garbage_collectors_.push_back(concurrent_copying_collector_); &#125; if (MayUseCollector(kCollectorTypeMC)) &#123; //如果前后台回收器中某一个是MarkCompact,再创建一个MarkCompact Collector mark_compact_collector_ = new collector::MarkCompact(this); garbage_collectors_.push_back(mark_compact_collector_); &#125;&#125; 如果有ImageSpace同时Non-Moving Space不为空同时满足三个条件(处于zygote，Non-Moving Space有独立地址，前台回收器是GSS)中的一个时，检查ImageSpace和Non-Moving Space之间没有内存空隙 12345678910111213141516171819202122232425if (!GetBootImageSpaces().empty() &amp;&amp; non_moving_space_ != nullptr &amp;&amp; (is_zygote || separate_non_moving_space || foreground_collector_type_ == kCollectorTypeGSS)) &#123; //如果有ImageSpace同时Non-Moving Space不为空同时满足三个条件 //(处于zygote，Non-Moving Space有独立地址，前台回收器是GSS)中的一个时, //检查ImageSpace和Non-Moving Space只见没有内存空隙 space::ImageSpace* first_space = nullptr; for (space::ImageSpace* space : boot_image_spaces_) &#123; if (first_space == nullptr || space-&gt;Begin() &lt; first_space-&gt;Begin()) &#123; first_space = space; &#125; &#125; bool no_gap = MemMap::CheckNoGaps(first_space-&gt;GetMemMap(), non_moving_space_-&gt;GetMemMap()); if (!no_gap) &#123; PrintFileToLog(\"/proc/self/maps\", LogSeverity::ERROR); MemMap::DumpMaps(LOG(ERROR), true); ... &#125; &#125;instrumentation::Instrumentation* const instrumentation = runtime-&gt;GetInstrumentation();if (gc_stress_mode_) &#123; backtrace_lock_ = new Mutex(\"GC complete lock\");&#125;if (is_running_on_memory_tool_ || gc_stress_mode_) &#123; instrumentation-&gt;InstrumentQuickAllocEntryPoints();&#125; 三. 总结3.1 前台回收器是ConcurrentCopying从代码逻辑看，如果foreground_collector_type_=kCollectorTypeCC时Heap的创建流程要跟其他回收器类型的创建流程不太相同： requested_alloc_space_begin = 300MB - non_moving_space_capacity 创建ImageSpace(只要image文件不为空，都会创建)，如果创建成功，requested_alloc_space_begin=ImageSpace+boo.oat 这一点所有回收器类型都一样，不同的是，如果创建失败，requested_alloc_space_begin = 300MB - non_moving_space_capacity, 其他回收器类型则是requested_alloc_space_begin = nullptr 如果background_collector_type_ != kCollectorTypeHomogeneousSpaceCompact,则不支持Homogeneous-Space-Compact 由于是CC回收器，所以必然会给Non-Moving Space独立的地址 由于是CC回收器，所以即使ImageSpace创建失败，requested_alloc_space_begin也不会为nullptr,又因为Non-Moving Space有独立的地址，所以最后request_begin=requested_alloc_space_begin + non_moving_space_capacity 如果ImageSpace创建成功，request_begin=ImageSpace+boot.oat+non_moving_space_capacity;如果创建失败，request_begin = 300MB-non_moving_space_capacity+non_moving_space_capacity-&gt;request_begin=300MB 紧跟着requested_alloc_space_begin创建用于Non-Moving Space的匿名内存映射non_moving_space_mem_map, 将request_begin固定在300MB的地址(request_begin=reinterpret_cast&lt;uint8_t*&gt;(300*MB))；之后将匿名内存映射封装成Non-Moving Space，如果在Zygote中，就叫ZygoteSpace,否则叫Non-Moving Space 由于是CC回收器,所以不会创建两块匿名内存main_mem_map_1,main_mem_map_2,而是紧跟着在request_begin后(即300MB,因为之前已经将request_begin固定在这个地址)直接创建RegionSpace 创建LargeObjectSpace 如果kUseTableLookupReadBarrier=true，创建ReadBarrierTable 创建CardTable,ModUnionTable(如果ImageSpace创建成功),如果collector::SemiSpace::kUseRememberedSet == true创建RememberedSet;创建allocation_stack_,mark_stack_,live_stack_;创建锁;创建TaskProcessor,ReferenceProcessor 由于是CC回收器,创建collector::ConcurrentCopying并添加至garbage_collectors_ 如果ImageSpace创建成功，且Non-Moving Space不为空，检查ImageSpace和Non-Moving Space之间有没有内存间隙 因为是CC,所以Non-Moving Space必然有独立地址，所以只需要判断ImageSpace创建成功和Non-Moving Space不为空 3.2 前台回收器是GSSGSS(Generational Semi-Space)是另一个较为特殊的回收器类型 requested_alloc_space_begin=nullptr 创建ImageSpace，如果成功，requested_alloc_space_begin=ImageSpace+boot.oat,如果创建失败,requested_alloc_space_begin=nullptr 如果background_collector_type_ != kCollectorTypeHomogeneousSpaceCompact，则肯定不支持Homogeneous-Space-Compact 由于是GSS回收器,所以不会给Non-Moving Space独立的地址(这一点很重要,即不会创建Non-Moving Space的匿名内存映射) 如果ImageSpace创建失败，则request_begin=requested_alloc_space_begin=nullptr;如果创建成功,则request_begin=reuqest_alloc_space_begin=ImageSpace+boo.oat 由于是GSS回收器,那么Non-Moving Space不会有独立地址，如果此时处于Zygote中，则紧跟ImageSpace+boo.oat创建匿名内存映射main_mem_map_1(因为Non-Moving Space没有独立地址，所以不会将request_begin固定在300MB,又因为如果ImageSpace创建成功此时request_begin=ImageSpace+boot.oat) 如果background_collector_type_ == kCollectorTypeHomogeneousSpaceCompact，则会紧跟着main_mem_map_1再创建第二块匿名内存映射main_mem_map_2,否则不会创建main_mem_map_2 将main_mem_map_1封装成Main Space,由于是GSS回收器，所以将non_moving_space_也指向Main Space 由于是GSS回收器,调用space::BumpPointerSpace::Create直接创建BumpPointerSpace1和BumpPointerSpace2 创建LargeObjectSpace 创建CardTable,ModUnionTable(如果ImageSpace创建成功),由于是GSS回收器，所以non_moving_space_ == main_space_,所以不会创建RememberedSet;创建allocation_stack_,mark_stack_,live_stack_;创建锁;创建TaskProcessor,ReferenceProcessor 由于是GSS,所以创建collector::SemiSpace,其中generational_ = true 如果ImageSpace创建成功，且MainSpace不为空，检查ImageSpace和Non-Moving Space之间有没有内存间隙 因为是GSS,所以non_moving_space_指向MainSpace,所以只需要判断ImageSpace创建成功和Non-Moving Space不为空 3.3 Moving GC(Semi-Space, MarkCompact, HomogeneousSpaceCompact) requested_alloc_space_begin=nullptr 创建ImageSpace，如果成功，requested_alloc_space_begin=ImageSpace+boot.oat,如果创建失败,requested_alloc_space_begin=nullptr 由于不是GSS和CC，所以只要传入的use_homogeneous_space_compaction==true或者background_collector_type_ == kCollectorTypeHomogeneousSpaceCompact时会支持Homogeneous-Space-Compact Non-Moving必然有独立的地址 如果ImageSpace创建成功，request_begin = requested_alloc_space_begin + non_moving_space_capacity,否则request_begin=nullptr 创建Non-Moving Space使用的匿名内存映射non_moving_space_mem_map,将request_begin固定在300MB的地址(request_begin=reinterpret_cast&lt;uint8_t*&gt;(300*MB)) 紧跟request_begin创建匿名内存映射main_mem_map_1 如果支持Homogeneous-Space-Compact或者前后台回收器有一个是Semi-Space,则紧跟main_mem_map_1创建第二块匿名内存映射main_mem_map_2 将non_moving_space_mem_map封装成Non-Moving Space,由non_moving_space_指向 将main_mem_map_1封装成BumpPointerSpace1，将main_mem_map_2封装成BumpPointerSpace2 创建LargeObjectSpace 创建CardTable,ModUnionTable(如果ImageSpace创建成功),如果collector::SemiSpace::kUseRememberedSet == true创建RememberedSet;创建allocation_stack_,mark_stack_,live_stack_;创建锁;创建TaskProcessor,ReferenceProcessor 如果前后台回收器中有一个是SS或Homogeneous-Space-Compact，创建collector::SemiSpace;如果前后台回收器有一个是MarkCompact,则创建collector::MarkCompact 如果ImageSpace创建成功，且Non-Moving Space不为空，检查ImageSpace和Non-Moving Space之间有没有内存间隙 因为Non-Moving必然有独立的地址,所以只需要判断ImageSpace创建成功和Non-Moving Space不为空 3.4 前台回收器MarkSweep或Concurrent MarkSweep requested_alloc_space_begin=nullptr 创建ImageSpace，如果成功，requested_alloc_space_begin=ImageSpace+boot.oat,如果创建失败,requested_alloc_space_begin=nullptr 由于不是GSS和CC，所以只要传入的use_homogeneous_space_compaction=true或者background_collector_type_ == kCollectorTypeHomogeneousSpaceCompact时会支持Homogeneous-Space-Compact 只要当前处于Zygote当中，则Non-Moving Space必然有独立地址，否则得看是否支持Homogeneous-Space-Compact,支持的话，就有独立地址，不支持就没有 如果ImageSpace创建失败且foreground_collector_type_=kCollectorTypeMS同时当前处于dex2oat,requested_alloc_space_begin=kAllocSpaceBeginForDeterministicAoT 如果ImageSpace创建成功且如果Non-Moving Space有独立地址的话，创建Non-Moving Space要用到的匿名内存映射non_moving_space_mem_map,将request_begin固定在300MB的地址(request_begin=reinterpret_cast&lt;uint8_t*&gt;(300*MB)) 如果Non-Moving Space有独立地址或者当前不在Zygote中,紧跟着request_begin(300MB)创建匿名内存映射main_mem_map_1;如果Non-Moving Space没有独立地址同时处于Zygote中，则紧跟着ImageSpace_boot.oat创建匿名内存映射main_mem_map_1 如果支持Homogeneous-Space-Compact,紧跟着main_mem_map_1创建第二块匿名内存映射main_mem_map_2,否则不创建main_mem_map_2 如果Non-Moving Space有独立地址，将non_moving_space_mem_map封装成Non-Moving Space 将main_mem_map_1封装成Main Space,如果Non-Moving Space没有独立地址，则将non_moving_space_也指向MainSpace 如果之前创建了main_mem_map_2,则将main_mem_map_2封装成Main Backup Space 创建LargeObjectSpace 移除Main Backup Space 创建CardTable,ModUnionTable(如果ImageSpace创建成功),如果Non-Moving Space有独立地址，创建RememberedSet，否则不创建；创建allocation_stack_,mark_stack_,live_stack_;创建锁;创建TaskProcessor,ReferenceProcessor 创建一组回收器，里面有三个回收器分别是MarkSweep, PartialMarkSweep, StickyMarkSweep,如果是Concurrent Mark Compact，则这一组回收器是支持并行GC的；如果是MarkSweep,则这一组不支持并行GC 如果ImageSpace创建成功且Non-Moving Space不为空同时满足：处于Zygote或者Non-Moving Space有独立地址时，检查ImageSpace和Non-Moving Space之间有没有内存间隙 因为Non-Moving Space有没有独立地址不确定，需要视条件而定 四. 参考资料 ART运行时垃圾收集机制简要介绍和学习计划 Debugging ART Garbage Collection","tags":[{"name":"ART","slug":"ART","permalink":"https://wangyun137.github.io/tags/ART/"},{"name":"源码分析","slug":"源码分析","permalink":"https://wangyun137.github.io/tags/源码分析/"}]},{"title":"ART Runtime 创建(二)--启动参数","date":"2017-07-24T06:53:34.000Z","path":"2017/07/24/ART-Runtime-创建-二-启动参数/","text":"Android 7.0 aosp_shamu-userdebug 一. 启动时获取的参数AndroidRuntime::startVm(/framework/bae/cpre/jni/AndroidRuntime.cpp)方法会首先获取大量系统属性,并将这些系统属性转化为实际的启动参数,下面是获取的系统属性以及对应的启动参数: dalvik.vm.checkjni(ro.kernel.android.checkjni) 真实值:无默认为false, 如果为true, 则添加参数-Xcheck:jni dalvik.vm.execution-mode 真实值:无默认为KEMDefault, 有四个取值:KEMDefault, kEMIntPortable, kEMIntFast, kEMJitCompiler. 如果不是kEMDefault,则相应的参数为:-Xint:portable, -Xint:fast, -Xint:jit dalvik.vm.stack-trace-file 真实值:/data/anr/traces.txt参数的形式为:-Xstacktracefile:/data/anr/traces.txt dalvik.vm.jniopts 真实值:没有设置如果有设置的话,参数形式为:Xjnipots:... {exit, runtime_exit} Hook Runtime的exit()为runtime_exit(int code)函数 {vfprintf, runtime_vfprintf} Hook Runtime的fprintf()为runtime_vfprintf(FILE* fp, const char* format, va_list ap)函数 {sensitiveThread, runtime_isSensitiveThread()} Hook Runtime的sensitiveThread()为runtime_isSensitiveThread()函数 直接添加参数-verbose:gc dalvik.vm.heapstartsize 真实值:8m参数的形式为:-Xms8m dalvik.vm.heapsize 真实值:512m参数的形式为:-Xmx512m dalvik.vm.heapgrowthlimit 真实值:256m参数形式为:-XX:HeapGrowthLimit=256m dalvik.vm.heapminfree 真实值:512k,参数形式为:-XX:HeapMinFree=512k dalvik.vm.heapmaxfree 真实值:8m参数形式为:-XX:HeapMaxFree=8m dalvik.vm.heaputilization 真实值:0.75参数形式为:-XX:HeapTargetUtilization=0.75 dalvik.vm.usejit 真实值:true参数形式为:-Xusejit:true dalvik.vm.jitmaxsize 真实值是:无如果设置则参数形式为:-Xjitmaxsize:${dalvik.vm.jitmaxsize} dalvik.vm.jitinitialize 真实值:无,如果设置参数形式为:-Xjitinitialize:${dalvik.vm.jitinitialize} dalvik.vm.jitthreshold 真实值:无如果设置参数形式为:-Xjitthreshold:.. dalvik.vm.usejitprofiles 真实值:true,参数形式为:-Xjitsaveprofilinginfo dalvik.vm.jitprithreadweight 真实值:无如果设置,参数的形式为:-Xjitprithreadweight dalvik.vm.jittransitionweight 真实值:无如果设置,参数的形式为:-Xjittransitionweight:${dalvik.vm.jittransitionweight} ro.config.low_ram 真实值:无如果设置,参数形式为:-XXLowMemoryMode dalvik.vm.gctype 真实值:无如果设置,参数形式为:-Xgc:${dalvik.vm.gctype} dalvik.vm.backgroundgctype 真实值:无如果设置,参数形式为:-XX:BackgroundGC=${dalvik.vm.backgroundgctype} 直接添加参数-agentlib:jdwp=transport=dt_android_adb,suspend=n,server=y dalvik.vm.lockprof.threshold 真实值:500参数形式为:-Xlockprofthreshold:500 vold.decrypt trigger_restart_framework因为不等于trigfer_restart_min_framework和1,所以还要获取属性dalvik.vm.image-dex2oat-filter, 系统中并未设置该值,如果设置了,参数的形式为:--compiler-filter=${dalvik.vm.image-dex2oat-filter}, -Ximage-compiler-option 直接添加参数Ximage-compiler-option 直接添加参数--compiled-classes=/system/etc/preloaded-classes 如果文件/system/etc/compiled-classes存在(实际存在),则添加参数:-Ximage-compiler-option, --compiled-classes=/system/etc/compiled-classes dalvik.vm.imgae-dex2oat-flags 真实值:无如果设置,参数形式为:-Ximage-compile-option, ${image-dex2oat-flags} dalvik.vm.dex2oat-Xms 真实值:64m参数形式为:-Xcompiler-option, --runtime-arg, -Xcompiler-option, -Xms64m dalvik.vm.dex2oat-Xmx 真实值:512m参数形式为:-Xcompiler-option, --runtime-arg, -Xcompiler-option, -Xms512m dalvik.vm.dex2oat-filter 真实值:无如果设置了,参数的形式为:-Xcompiler-option, --runtime-arg, -Xcompiler-option, --compiler-filter=${dalvik.vm.dex2oat-filter} dalvik.vm.dex2oat-threads 真实值:无如果设置了,参数形式为:-Xcompiler-option, --runtime-arg, -Xcompiler-option, -j${dalvik.vm.dex2oat-threads} dalvik.vm.image-dex2oat-threads 真实值:无如果设置了,参数形式为:-Ximage-compiler-option, --runtime-arg, -Ximage-compiler-option, -j${dalvik.vm.image-dex2oat-threads} dalvik.vm.isa.arm.variant 真实值:krait参数最终形式为:-Ximage-compiler-option, --runtime-arg, -Ximage-compiler-option, --instruction-set-variant=krait , -Xcompiler-option, --runtime-arg, -Xcompiler-option, --instruction-set-variant=krait dalvik.vm.isa.arm.features 真实值:default参数形式为:-Ximage-compiler-option, --runtime-arg, -Ximage-compiler-option, --instruction-set-features=default, -Xcompiler-option, --runtime-arg, -Xcompiler-option, instruction-set-variant-features=default dalvik.vm.dex2oat-flags 真实值:无如果设置,参数形式为:-Xcompiler-option, [dex2oat-flags] dalvik.vm.extra-opts 真实值:无如果设置,参数形式为:[extra-opts] 读取Locale,然后添加参数-Duser.locale=zh-Hans-CN ro.debuggable 真实值:1,如果ro.debuggable=1同时dalvik.vm.method-trace=true(实际为false),则添加参数-Xmethod-trace, -Xmethod-trace-file:[dalvik.vm.method-trace-file], -Xmethod-trace-file-size:[dalvik.vm.method-trace-file-siz], 如果dalvik.vm.method-trace-stream=true, 添加参数-Xmethod-trace-stream(实际都没有添加) ro.dalvik.vm.native.bridge 真实值:0如果值不为0, 则参数为:-XX:NativeBridge=[ro.dalvik.vm.native.bridge] ro.product.cpu.abilist32 真实值:[armeabi-v7a,armeabi]参数形式为:--cpu-abilist=[armeabi-v7a,armeabi] dalvik.vm.zygote.max-boot-retry 真实值:无如果设置, 最终形式为:-Xzygote-max-boot-retry=[dalvik.vm.zygote.max-boot-retry] debug.generate-debug-info 真实值:无如果值为true, 添加参数:-Xcompiler-option, --generate-debug-info, -Ximage-compiler-option, --generate-debug-info ro.build.fingerprint 真实值:Android/aosp_shamu/shamu:7.0/NBD91U/xx12231922:userdebug/test-keys参数形式为:-Xfingerprint:Android/aosp_shamu/shamu:7.0/NBD91U/xx12231922:userdebug/test-keys 二. 实际传入的参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; &#123;`-Xstacktracefile:/data/anr/traces.txt`, NULL&#125;, //&#123;optionString, extraInfo&#125; &#123;`exit`, runtime_exit&#125;, &#123;`vfprintf`, `runtime_vfprintf`&#125;, &#123;`sensitiveThread`, `runtime_isSensitiveThread`&#125;, &#123;`-verbose:gc`, NULL&#125;, &#123;`-Xms8m`, NULL&#125;, &#123;`-Xmx512m`, NULL&#125;, &#123;`-XX:HeapGrowthLimit=256m`,NULL&#125;, &#123;`-XX:HeapMinFree=512k`, NULL&#125;, &#123;`-XX:HeapMaxFree=8m`,NULL&#125;, &#123;`-XX:HeapTargetUtilization=0.75`,NULL&#125;, &#123;`-Xusejit:true`, NULL&#125;, &#123;`-Xjitsaveprofilinginfo`,NULL&#125;, &#123;`-agentlib:jdwp=transport=dt_android_adb,suspend=n,server=y`, NULL&#125;, &#123;`-Xlockprofthreshold:500`,NULL&#125;, &#123;`-Ximage-compiler-option`,NULL&#125;, &#123;`--compiled-classes=/system/etc/preloaded-classes`,NULL&#125;, &#123;`-Ximage-compiler-option`,NULL&#125;, &#123;`--compiled-classes=/system/etc/compiled-classes`,NULL&#125;, &#123;`-Xcompiler-option`,NULL&#125;, &#123;`--runtime-arg`,NULL&#125;, &#123;`-Xcompiler-option`,NULL&#125;, &#123;`-Xms64m`,NULL&#125;, &#123;`-Xcompiler-option`,NULL&#125;, &#123;`--runtime-arg`,NULL&#125;, &#123;`-Xcompiler-option`,NULL&#125;, &#123;`-Xmx512m`,NULL&#125;, &#123;`-Ximage-compiler-option`,NULL&#125;, &#123;`--runtime-arg`,NULL&#125;, &#123;`-Ximage-compiler-option`,NULL&#125;, &#123;`--instruction-set-variant=krait`,NULL&#125;, &#123;`-Xcompiler-option`,NULL&#125;, &#123;`--runtime-arg`,NULL&#125;, &#123;`-Xcompiler-option`,NULL&#125;, &#123;`--instruction-set-variant=krait`,NULL&#125;, &#123;`-Ximage-compiler-option`,NULL&#125;, &#123;`--runtime-arg`,NULL&#125;, &#123;`-Ximage-compiler-option`,NULL&#125;, &#123;`--instruction-set-features=default`,NULL&#125;, &#123;`-Xcompiler-option`,NULL&#125;, &#123;`--runtime-arg`,NULL&#125;, &#123;`-Xcompiler-option`,NULL&#125;, &#123;`--instruction-set-features=default`,NULL&#125;, &#123;`-Duser.locale=zh-Hans-CN`,NULL&#125;, &#123;`--cpu-abilist=[armeabi-v7a,armeabi]`,NULL&#125;, &#123;`-Xfingerprint:Android/aosp_shamu/shamu:7.0/NBD91U/xx12231922:userdebug/test-keys`, NULL&#125;&#125; 三. 存储参数的数据结构和方法3.1 存储参数的数据结构12345678910111213typedef struct JavaVMInitArgs &#123; jint version; jint nOptions; JavaVMOption* options; jboolean ignoreUnrecognized&#125;typedef struct JavaVMOption &#123; const char* optionString; void* extractInfo;&#125;typedef std::vector&lt;std::pair&lt;std::string, const void*&gt;&gt; RuntimeOptions 3.2 最终传入的数据结构12345JavaVMInitArgs initArgs;initArgs.version = JNI_VERSION_1_4;initArgs.options = mOptions.editArray();initArgs.nOptions = mOptions.size();initArgs.ignoreUnrecognized = JNI_FALSE; 3.3 添加参数的方法1234567void AndroidRuntime::addOption(const char* optionString, void* extraInfo)&#123; JavaVMOption opt; opt.optionString = optionString; opt.extraInfo = extraInfo; mOptions.add(opt);&#125; 四. 解析参数流程4.1 JNI_CreateJavaVM1234567891011121314extern \"C\" jint JNI_CreateJavaVM(JavaVM** p_vm, JNIEnv** p_env, void* vm_args) &#123; const JavaVMInitArgs* args = static_cast&lt;JavaVMInitArgs*&gt;(vm_args); ... RuntimeOptions options; for (int i = 0; i &lt; args-&gt;nOptions; ++i) &#123; JavaVMOption* option = &amp;args-&gt;options[i]; options.push_back(std::make_pair(std::string(option-&gt;optionString), option-&gt;extraInfo)); &#125; bool ignore_unrecognized = args-&gt;ignoreUnrecognized; if (!Runtime::Create(options, ignore_unrecognized)) &#123; return JNI_ERR; &#125; ...&#125; 4.2 Runtime::Create()123456bool Runtime::Create(const RuntimeOptions&amp; raw_options, bool ignore_unrecognized) &#123; RuntimeArgumentMap runtime_options; return ParseOptions(raw_options, ignore_unrecognized, &amp;runtime_options) &amp;&amp; Create(std::move(runtime_options));&#125; 4.3 Runtime::ParseOptions1234567891011bool Runtime::ParseOptions(const RuntimeOptions&amp; raw_options, bool ignore_unrecognized, RuntimeArgumentMap* runtime_options) &#123; InitLogging(/* argv */ nullptr); bool parsed = ParsedOptions::Parse(raw_options, ignore_unrecognized, runtime_options); if (!parsed) &#123; LOG(ERROR) &lt;&lt; \"Failed to parse options\"; return false; &#125; return true;&#125; 4.4 ParsedOptions::Parse位于/art/runtime/parsed_options.cc1234567bool ParsedOptions::Parse(const RuntimeOptions&amp; options, bool ignore_unrecognized, RuntimeArgumentMap* runtime_options) &#123; CHECK(runtime_options != nullptr); ParsedOptions parser; return parser.DoParse(options, ignore_unrecognized, runtime_options);&#125; 4.5 ParsedOptions::DoParse123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150bool ParsedOptions::DoParse(const RuntimeOptions&amp; options, bool ignore_unrecognized, RuntimeArgumentMap* runtime_options) &#123; ... //将字符串参数生成对应的M::key结构 auto parser = MakeParser(ignore_unrecognized); std::vector&lt;std::string&gt; argv_list; //解析带有extraOption的参数, [5.2] if (!ProcessSpecialOptions(options, nullptr, &amp;argv_list)) &#123; return false; &#125; CmdlineResult parse_result = parser-&gt;Parse(argv_list); // 处理parse errors if (parse_result.IsError()) &#123; ... &#125; using M = RuntimeArgumentMap; RuntimeArgumentMap args = parser-&gt;ReleaseArgumentsMap(); if (args.Exists(M::Help)) &#123; //-help Usage(nullptr); return false; &#125; else if (args.Exists(M::ShowVersion)) &#123; //-showversion UsageMessage(stdout, \"ART version %s\\n\", Runtime::GetVersion()); Exit(0); &#125; else if (args.Exists(M::BootClassPath)) &#123; //-Xbootclasspath LOG(INFO) &lt;&lt; \"setting boot class path to \" &lt;&lt; *args.Get(M::BootClassPath); &#125; //-Xusejit和-Xint不能同时使用 if (args.GetOrDefault(M::UseJitCompilation) &amp;&amp; args.GetOrDefault(M::Interpret)) &#123; Usage(\"-Xusejit:true and -Xint cannot be specified together\"); Exit(0); &#125; //获取默认的bootclasspath if (getenv(\"BOOTCLASSPATH\") != nullptr) &#123; args.SetIfMissing(M::BootClassPath, std::string(getenv(\"BOOTCLASSPATH\"))); &#125; //获取默认的classpath if (getenv(\"CLASSPATH\") != nullptr) &#123; args.SetIfMissing(M::ClassPath, std::string(getenv(\"CLASSPATH\"))); &#125; //设置参数-XX:ParallelGCThreads=0u //kDefaultEnableParallelGC=false args.SetIfMissing(M::ParallelGCThreads, gc::Heap::kDefaultEnableParallelGC ? static_cast&lt;unsigned int&gt;(sysconf(_SC_NPROCESSORS_CONF) - 1u) : 0u); // -verbose:gc &#123; LogVerbosity *log_verbosity = args.Get(M::Verbose); if (log_verbosity != nullptr) &#123; gLogVerbosity = *log_verbosity; &#125; &#125; MaybeOverrideVerbosity(); // 设置-Xprofile:,由于在启动时没有指定这个参数,所以使用默认值: Trace::SetDefaultClockSource(args.GetOrDefault(M::ProfileClock)); //再次检查extraInfo if (!ProcessSpecialOptions(options, &amp;args, nullptr)) &#123; return false; &#125; &#123; // 如果没有设置,background回收器是默认的homogeneous compaction // 如果foreground回收器是GSS, 则background也是GSS // 如果是low memory模式, 则使用semispace gc::CollectorType background_collector_type_; gc::CollectorType collector_type_ = (XGcOption&#123;&#125;).collector_type_; // NOLINT [whitespace/braces] [5] //查看是否存在-XX:LowMemoryMode,实际上是没有的 bool low_memory_mode_ = args.Exists(M::LowMemoryMode); //获取参数-XX:BackgroundGC,实际上并未指定,所以使用默认值 background_collector_type_ = args.GetOrDefault(M::BackgroundGc); &#123; //获取参数-Xgc,实际上参数中并没有指定 ... &#125; if (background_collector_type_ == gc::kCollectorTypeNone) &#123; if (collector_type_ != gc::kCollectorTypeGSS) &#123; //如果foreground回收器不是GSS,且当前是low_memory_mode,则使用SS, 否则指定为homogeneous compact background_collector_type_ = low_memory_mode_ ? gc::kCollectorTypeSS : gc::kCollectorTypeHomogeneousSpaceCompact; &#125; else &#123; background_collector_type_ = collector_type_; &#125; &#125; args.Set(M::BackgroundGc, BackgroundGcOption &#123; background_collector_type_ &#125;); &#125;#if defined(ART_TARGET) std::string core_jar(\"/core.jar\"); std::string core_libart_jar(\"/core-libart.jar\");#else // The host uses hostdex files. std::string core_jar(\"/core-hostdex.jar\"); std::string core_libart_jar(\"/core-libart-hostdex.jar\");#endif //获取-Xbootclasspath,之前已经通过getenv(\"BOOTCLASSPATH\")设置 auto boot_class_path_string = args.GetOrDefault(M::BootClassPath); //在bootclasspath中查找/core.jar, 如果找到的话,则用/core-libart.jar替换 size_t core_jar_pos = boot_class_path_string.find(core_jar); if (core_jar_pos != std::string::npos) &#123; boot_class_path_string.replace(core_jar_pos, core_jar.size(), core_libart_jar); args.Set(M::BootClassPath, boot_class_path_string); &#125; &#123; //获取-Xbootclasspath和-Xbootclasspath-location: auto&amp;&amp; boot_class_path = args.GetOrDefault(M::BootClassPath); auto&amp;&amp; boot_class_path_locations = args.GetOrDefault(M::BootClassPathLocations); //实际并未指定-Xbootclasspath-location if (args.Exists(M::BootClassPathLocations)) &#123; //如果boot_class_path_locations的path数量不等于boot_class_path中的path路径,打印Usage并返回 ... &#125; &#125; //如果没有指定compilercallbacks回调函数(实际参数中并没有指定)以及没有指定-Ximage(实际参数也并未指定) //指定image文件路径是/system/framework/boot.art if (!args.Exists(M::CompilerCallbacksPtr) &amp;&amp; !args.Exists(M::Image)) &#123; std::string image = GetAndroidRoot(); image += \"/framework/boot.art\"; args.Set(M::Image, image); &#125; //获取-XX:HeapGrowthLimit(实际参数中为256m),判断是否小于0或者大于-Xmx(实际为512m) //如果小于0或者大于-Xmx,则将-XX:HeapGrowthLimit设为-Xmx的值 if (args.GetOrDefault(M::HeapGrowthLimit) &lt;= 0u || args.GetOrDefault(M::HeapGrowthLimit) &gt; args.GetOrDefault(M::MemoryMaximumSize)) &#123; args.Set(M::HeapGrowthLimit, args.GetOrDefault(M::MemoryMaximumSize)); &#125; //实际参数中并没有指定-Xexperimental if (args.GetOrDefault(M::Experimental) &amp; ExperimentalFlags::kLambdas) &#123; ... &#125; *runtime_options = std::move(args); return true;&#125; DoParse方法主要做了以下几件事: 先将所有的字符串参数名称集中生成对应的RuntimeArgumentMap::[KEY]结构 从实际传入的参数中解析extra_info,extra_info用来hook函数,实际传入的参数中hook的是下面三个函数:exit,vfprintf,sensitiveThread 判断传入的参数中是否有-help,-showversion,如果存在,则打印对应的帮助信息并返回 确保-Xusejit和-Xint不能共同使用 getenv(BOOTCLASSPATH)并设置-Xbootclasspath getenv(CLASSPATH)并设置-Xclasspath 设置-XX:ParallelGCThreads=0u 根据实际传入的参数设置LogVerbosity 获取Xprofile,由于实际参数中没有设置,所以使用默认值,并设置Trace::SetDefaultClockSource 再次检索extra_info 根据kuseReadBarrier的值确定foreground GC, 如果kuseReadBarrier=true,foregroundGC=CC,否则foregroundGC=default;查看实际参数中是否指定-Xgc,如果指定了则将参数指定的GC设为background GC(实际参数中并未指定);如果foreground GC是GSS,则background GC也是GSS;如果foreground GC不是GSS,则如果实际参数中指定了-XX:LowMemoryMode(实际参数中并未指定), 即低内存模式下backgroundGC=GSS, 否则backgroundGC=homogeneous Space Compact 如果bootclasspath中包含/core.jar,则用/core-libart.jar替换 如果指定了-Xbootclasspath-location,检查-Xbootclasspath-location锁指定的path数量是否和-Xbootclasspath中的path数量一样,不一样输出Usage并返回 由于实际参数中并没有指定-Ximage:和名为compilercallbacks的extra_info,指定Runtime的Image文件是/system/framework/boot.art 确保-XX:HeapGrowthLimit大于0同时小于-Xmx 4.5.1 ParsedOptions::ProcessSpecialOptions1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253bool ParsedOptions::ProcessSpecialOptions(const RuntimeOptions&amp; options, RuntimeArgumentMap* runtime_options, std::vector&lt;std::string&gt;* out_options) &#123; using M = RuntimeArgumentMap; for (size_t i = 0; i &lt; options.size(); ++i) &#123; const std::string option(options[i].first); if (option == \"bootclasspath\") &#123; ... //实际并没有设置 &#125; else if (option == \"compilercallbacks\") &#123; ... //实际并没有设置 &#125; else if (option == \"imageinstructionset\") &#123; ... //实际并没有设置 &#125; else if (option == \"sensitiveThread\") &#123; const void* hook = options[i].second; bool (*hook_is_sensitive_thread)() = reinterpret_cast&lt;bool (*)()&gt;(const_cast&lt;void*&gt;(hook)); if (runtime_options != nullptr) &#123; runtime_options-&gt;Set(M::HookIsSensitiveThread, hook_is_sensitive_thread); &#125; &#125; else if (option == \"vfprintf\") &#123; const void* hook = options[i].second; if (hook == nullptr) &#123; Usage(\"vfprintf argument was nullptr\"); return false; &#125; int (*hook_vfprintf)(FILE *, const char*, va_list) = reinterpret_cast&lt;int (*)(FILE *, const char*, va_list)&gt;(const_cast&lt;void*&gt;(hook)); if (runtime_options != nullptr) &#123; runtime_options-&gt;Set(M::HookVfprintf, hook_vfprintf); &#125; hook_vfprintf_ = hook_vfprintf; &#125; else if (option == \"exit\") &#123; const void* hook = options[i].second; if (hook == nullptr) &#123; Usage(\"exit argument was nullptr\"); return false; &#125; void(*hook_exit)(jint) = reinterpret_cast&lt;void(*)(jint)&gt;(const_cast&lt;void*&gt;(hook)); if (runtime_options != nullptr) &#123; runtime_options-&gt;Set(M::HookExit, hook_exit); &#125; hook_exit_ = hook_exit; &#125; else if (option == \"abort\") &#123; ... //实际并没有设置 &#125; else &#123; ... //实际并没有设置 &#125; &#125; return true;&#125;","tags":[{"name":"ART","slug":"ART","permalink":"https://wangyun137.github.io/tags/ART/"},{"name":"源码分析","slug":"源码分析","permalink":"https://wangyun137.github.io/tags/源码分析/"}]},{"title":"ART Runtime创建(一)--整体流程","date":"2017-07-24T06:44:11.000Z","path":"2017/07/24/ART-Runtime创建-一-整体流程/","text":"一. Zygote启动过程中的创建虚拟机过程Zygote的代码位于/framework/base/cmds/app_process/app_main.cpp 1234567891011121314151617181920int main(int argc, char* const argv[])&#123; ... //[1.1] AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv)); ... // handle args if (zygote) &#123; //[1.2] runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote); &#125; else if (className) &#123; runtime.start(\"com.android.internal.os.RuntimeInit\", args, zygote); &#125; else &#123; fprintf(stderr, \"Error: no class name or --zygote supplied.\\n\"); app_usage(); LOG_ALWAYS_FATAL(\"app_process: no class name or --zygote supplied.\"); return 10; &#125;&#125; main方法中省略的代码中主要在处理传入的参数, 从而确定当前是否要执行zygote的逻辑以及启动zygote时是否需要启动system_server, 这里主要两个关键调用: AppRuntime runtime(...)这行代码创建了一个AppRuntime对象,AppRuntime继承自AndroidRuntime runtime.start(...)调用AppRuntime的start方法,由于AppRuntime并没有重写父类的start方法,所以这里实际调用的是AndroidRuntime::start(...) 1.1 AndroidRuntimeAppRuntime的定义就在app_main.cpp中,其构造函数为:123AppRuntime(char* argBlockStart, const size_t argBlockLength) : AndroidRuntime(argBlockStart, argBlockLength) , mClass(NULL)&#123;&#125; 可以看到AppRuntime的构造函数没做任何事,主要就是调用父类AndroidRuntime的构造函数, AndroidRuntime定义在/framework/base/include/android_runtime/AndroidRuntime.h,对应的源文件在/framework/base/core/jni/AndroidRuntime.cpp 12345678910111213141516//全局变量static AndroidRuntime* gCurRuntime = NULL;AndroidRuntime::AndroidRuntime(char* argBlockStart, const size_t argBlockLength) : mExitWithoutCleanup(false), mArgBlockStart(argBlockStart), mArgBlockLength(argBlockLength)&#123; SkGraphics::Init(); // mOptions的类型是:Vector&lt;JavaVMOption&gt; mOptions.setCapacity(20); assert(gCurRuntime == NULL); // one per process gCurRuntime = this;&#125; 1.2 AndroidRuntime::start12345678910111213141516171819202122232425262728293031void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote)&#123; ... //设置ANDROID_ROOT /* 启动虚拟机 */ //[1.3] JniInvocation jni_invocation; //[1.4] jni_invocation.Init(NULL); JNIEnv* env; //[1.5], mJavaVM是AndroidRuntime的static变量,初始化为NULL if (startVm(&amp;mJavaVM, &amp;env, zygote) != 0) &#123; return; &#125; //[1.6] onVmCreated(env); /* 注册android相关的jni方法 */ if (startReg(env) &lt; 0) &#123; ALOGE(\"Unable to register all android natives\\n\"); return; &#125; ... //调用com.android.internal.os.ZygoteInit或者RuntimeInit的main方法 if (mJavaVM-&gt;DetachCurrentThread() != JNI_OK) ALOGW(\"Warning: unable to detach main thread\\n\"); if (mJavaVM-&gt;DestroyJavaVM() != 0) ALOGW(\"Warning: VM did not shut down cleanly\\n\");&#125; 1.3 JniInvocation::JniInvocation123456789JniInvocation::JniInvocation() : handle_(NULL), JNI_GetDefaultJavaVMInitArgs_(NULL), JNI_CreateJavaVM_(NULL), JNI_GetCreatedJavaVMs_(NULL) &#123; LOG_ALWAYS_FATAL_IF(jni_invocation_ != NULL, \"JniInvocation instance already initialized\"); jni_invocation_ = this;&#125; JniInvocation类的头文件和源文件分别在/libnativehelper/include/nativehelper/JniInvocation.h,/libnativehelper/JniInvocation.cpp.JniInvocation中有三个重要的变量: JNI_CreateJavaVM_(创建虚拟机实例) JNI_GetCreatedJavaVMs_(获取创建的虚拟机实例) JNI_GetDefaultJavaVMInitArgs_(获取虚拟机的默认初始化参数) 这三个变量是标准的Java虚拟机的接口,也就是说实现了这个三个接口,就可以实现一个Java虚拟机,具体可参考罗升阳的博客.JniInvocation的构造函数中初始化这三个变量为NULL 1.4 JniInvocation::Init123456789101112131415161718192021222324252627282930313233343536bool JniInvocation::Init(const char* library) &#123;#ifdef __ANDROID__ char buffer[PROP_VALUE_MAX];#else char* buffer = NULL;#endif //由于传入的library是NULL,所以最后实际获取到的library是libart.so library = GetLibrary(library, buffer); const int kDlopenFlags = RTLD_NOW | RTLD_NODELETE; handle_ = dlopen(library, kDlopenFlags); if (handle_ == NULL) &#123; ... //打开libart.so失败,直接返回;如果打开其他library失败,则尝试打开libart.so &#125; //寻找并导出JNI_GetDefaultJavaVMInitArgs_ if (!FindSymbol(reinterpret_cast&lt;void**&gt;(&amp;JNI_GetDefaultJavaVMInitArgs_), \"JNI_GetDefaultJavaVMInitArgs\")) &#123; return false; &#125; //寻找并导出JNI_CreateJavaVM_ if (!FindSymbol(reinterpret_cast&lt;void**&gt;(&amp;JNI_CreateJavaVM_), \"JNI_CreateJavaVM\")) &#123; return false; &#125; //寻找并导出JNI_GetCreatedJavaVMs_ if (!FindSymbol(reinterpret_cast&lt;void**&gt;(&amp;JNI_GetCreatedJavaVMs_), \"JNI_GetCreatedJavaVMs\")) &#123; return false; &#125; return true;&#125;bool JniInvocation::FindSymbol(void** pointer, const char* symbol) &#123; *pointer = dlsym(handle_, symbol); ... // handle error return true;&#125; JniInvocation::Init的主要工作就是通过dlopen函数打开libart.so,之后利用dlsym函数寻找并导出Java虚拟机的三个接口,这样就可以通过这三个接口创建并访问虚拟机 1.5 AndroidRuntime::startVm1234567891011121314151617181920int AndroidRuntime::startVm(JavaVM** pJavaVM, JNIEnv** pEnv, bool zygote)&#123; ... //解析启动参数 initArgs.version = JNI_VERSION_1_4; initArgs.options = mOptions.editArray(); initArgs.nOptions = mOptions.size(); initArgs.ignoreUnrecognized = JNI_FALSE; /** * 创建虚拟机, 每一个进程有一个JavaVM*, 每一个线程有一个JNIEnv* */ //[1.5.1] if (JNI_CreateJavaVM(pJavaVM, pEnv, &amp;initArgs) &lt; 0) &#123; ALOGE(\"JNI_CreateJavaVM failed\\n\"); return -1; &#125; return 0;&#125; Android::startVm主要做了两项工作: 解析虚拟机启动参数 调用JNI_CreateJavaVM创建虚拟机.源码的注释中清楚地说明了创建虚拟机后每一个进程都应该具有一个JavaVM指针,而每一个线程都具有一个JNIEnv指针.JNI_CreateJavaVM实现在/libnativehelper/JniInvocation.cpp中,其主要逻辑就是返回之前从libart.so中导出的JNI_CreateJavaVM_接口,即JNI_CreateJavaVM的真正实现是由libart.so完成的 1.5.1 JniInvocation::JNI_CreateJavaVM1234567extern \"C\" jint JNI_CreateJavaVM(JavaVM** p_vm, JNIEnv** p_env, void* vm_args) &#123; return JniInvocation::GetJniInvocation().JNI_CreateJavaVM(p_vm, p_env, vm_args);&#125;jint JniInvocation::JNI_CreateJavaVM(JavaVM** p_vm, JNIEnv** p_env, void* vm_args) &#123; return JNI_CreateJavaVM_(p_vm, p_env, vm_args);&#125; JNI_CreateJavaVM_就是之前在JniInvocation::Init中导出的函数指针 1.6 AppRuntime::onVmCreatedAndroidRuntime::onVmCreated是一个虚方法,AndroidRuntime类并没有实现这个方法,具体实现是由子类AppRuntime实现1234567891011121314virtual void onVmCreated(JNIEnv* env)&#123; if (mClassName.isEmpty()) &#123; return; // Zygote. Nothing to do here. &#125; char* slashClassName = toSlashClassName(mClassName.string()); mClass = env-&gt;FindClass(slashClassName); if (mClass == NULL) &#123; ALOGE(\"ERROR: could not find class '%s'\\n\", mClassName.string()); &#125; free(slashClassName); mClass = reinterpret_cast&lt;jclass&gt;(env-&gt;NewGlobalRef(mClass));&#125; 从代码中可以看出,如果是Zygote的启动,则onVmCreated实际什么也没有做 二. libart.so中的JNI_CreateJavaVMlibart.so的代码都位于/art目录下,而JNI_CreateJavaVM定义在/art/runtime/java_vm_ext.cc中:12345678910111213141516171819202122232425262728293031323334353637extern \"C\" jint JNI_CreateJavaVM(JavaVM** p_vm, JNIEnv** p_env, void* vm_args) &#123; ScopedTrace trace(__FUNCTION__); const JavaVMInitArgs* args = static_cast&lt;JavaVMInitArgs*&gt;(vm_args); //检查Jni版本号 if (IsBadJniVersion(args-&gt;version)) &#123; LOG(ERROR) &lt;&lt; \"Bad JNI version passed to CreateJavaVM: \" &lt;&lt; args-&gt;version; return JNI_EVERSION; &#125; RuntimeOptions options; for (int i = 0; i &lt; args-&gt;nOptions; ++i) &#123; JavaVMOption* option = &amp;args-&gt;options[i]; options.push_back(std::make_pair(std::string(option-&gt;optionString), option-&gt;extraInfo)); &#125; bool ignore_unrecognized = args-&gt;ignoreUnrecognized; //[2.1] 创建Runtime if (!Runtime::Create(options, ignore_unrecognized)) &#123; return JNI_ERR; &#125; //初始化native loader, 确保在使用JNI之前所需的环境都已经设置好 android::InitializeNativeLoader(); Runtime* runtime = Runtime::Current(); //[2.2] 启动Runtime bool started = runtime-&gt;Start(); if (!started) &#123; delete Thread::Current()-&gt;GetJniEnv(); delete runtime-&gt;GetJavaVM(); LOG(WARNING) &lt;&lt; \"CreateJavaVM failed\"; return JNI_ERR; &#125; //获取JNIEnv和JavaVM,返回给上层 *p_env = Thread::Current()-&gt;GetJniEnv(); *p_vm = runtime-&gt;GetJavaVM(); return JNI_OK;&#125; 2.1 Runtime::Create代码位于/art/runtime/runtime.cc12345678910111213141516171819202122bool Runtime::Create(const RuntimeOptions&amp; raw_options, bool ignore_unrecognized) &#123; RuntimeArgumentMap runtime_options; //首先调用ParseOptions,之后再调用另一个重载版本的Create return ParseOptions(raw_options, ignore_unrecognized, &amp;runtime_options) &amp;&amp; Create(std::move(runtime_options));&#125;bool Runtime::Create(RuntimeArgumentMap&amp;&amp; runtime_options) &#123; if (Runtime::instance_ != nullptr) &#123; return false; &#125; instance_ = new Runtime; //调用Runtime::Init(), [2.1.1] if (!instance_-&gt;Init(std::move(runtime_options))) &#123; // TODO: Currently deleting the instance will abort the runtime on destruction. Now This will // leak memory, instead. Fix the destructor. b/19100793. // delete instance_; instance_ = nullptr; return false; &#125; return true;&#125; ParseOptions()最终会调用ParsedOptions::DoParse方法(/art/runtime/parsed_options.cc),主要就是用来解析传入的启动参数,这里暂时先不分析其主要逻辑.从代码中可以看到Create函数主要操作视调用Runtime::Init函数 2.1.1 Runtime::Init123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113bool Runtime::Init(RuntimeArgumentMap&amp;&amp; runtime_options_in) &#123; RuntimeArgumentMap runtime_options(std::move(runtime_options_in)); ScopedTrace trace(__FUNCTION__); MemMap::Init(); using Opt = RuntimeArgumentMap; QuasiAtomic::Startup(); //创建OatFileManager, OatFileManager主要用来加载oat文件 oat_file_manager_ = new OatFileManager; Thread::SetSensitiveThreadHook(runtime_options.GetOrDefault(Opt::HookIsSensitiveThread)); Monitor::Init(runtime_options.GetOrDefault(Opt::LockProfThreshold)); //从传入的参数中初始化boot_class_path_string_, class_path_string_, patchoat_executable_等变量 //创建monitor_list_, monitor_pool_, thread_list_, intern_table_ //继续获取一些基本变量 ... //查看参数中是否指定了解释执行,如果指定,则告知虚拟机所有代码都是解释执行 if (runtime_options.GetOrDefault(Opt::Interpret)) &#123; GetInstrumentation()-&gt;ForceInterpretOnly(); &#125; //仍然是从传入的参数中初始化一些基础变量, 并获取CompilerFilter ... //创建堆Heap heap_ = new gc::Heap(...); if (!heap_-&gt;HasBootImageSpace() &amp;&amp; !allow_dex_file_fallback_) &#123; LOG(ERROR) &lt;&lt; \"Dex file fallback disabled, cannot continue without image.\"; return false; &#125; ... //获取dump_gc_performance_on_shutdown_, 配置Jdwp //创建JIT选项,JIT是7.0中新增的,用来提升代码执行效率 jit_options_.reset(jit::JitOptions::CreateFromRuntimeArguments(runtime_options)); //如果此时是dex2oat程序,dex2oat执行时也会创建一个Runtime用来编译dex文件,此时不需要开启JIT选项 if (IsAotCompiler()) &#123; jit_options_-&gt;SetUseJitCompilation(false); jit_options_-&gt;SetSaveProfilingInfo(false); &#125; //创建lamba_box_table, arena_pool_, jit_arena_pool_, 如果是64位架构且当前是dex2oat, 获取low_4gb_arena_pool_ ... //创建线性分配器linear_alloc_,LinearAlloc创建时会用到上面创建的low_4gb_arena_pool_(64位架构且是dex2oat时)或者arena_pool_ linear_alloc_.reset(CreateLinearAlloc()); BlockSignals(); //初始化SIGSEGV信号处理函数为HandleUnexpectedSignal InitPlatformSignalHandlers(); //arm, arm64, x86, mips, mips64, thumb2, x86_64架构下, //implicit_null_checks_ = true //implicit_so_checks_ !(RUNNING_ON_MEMORY_TOOL &amp;&amp; kMemoryToolIsValgrind) .... ... //处理no_sig_chain = false时的情况(no_sig_chain在之前根据传入的参数获取) //创建JavaVMExt java_vm_ = new JavaVMExt(this, runtime_options); //创建线程TLS Thread::Startup(); //attach线程, 创建Thread对象,初始化Thread对象 Thread* self = Thread::Attach(\"main\", false, nullptr, false); // Set us to runnable so tools using a runtime can allocate and GC by default self-&gt;TransitionFromSuspendedToRunnable(); // 验证heap GetHeap()-&gt;EnableObjectValidation(); //创建ClassLinker class_linker_ = new ClassLinker(intern_table_); if (GetHeap()-&gt;HasBootImageSpace()) &#123; ... bool result = class_linker_-&gt;InitFromBootImage(&amp;error_msg); ... if (boot_class_path_string_.empty()) &#123; // 如果bootclasspath没有显示指定,则从加载的dex文件列表中进行构造,这里的dex文件列表是系统构建时已经创建好的众多预加载的文件 ... &#125; // 在intern_table_中添加boot image space;将boo image space添加到当前ClassLinker的ClassTable中 ... &#125; else &#123; .... if (!class_linker_-&gt;InitWithoutImage(std::move(boot_class_path), &amp;error_msg)) &#123; return false; &#125; ... &#125; ... //MethodTrace, ProfilerOptions, Trace //提前分配一个OutOfMemoryError self-&gt;ThrowNewException(\"Ljava/lang/OutOfMemoryError;\", \"OutOfMemoryError thrown while trying to throw OutOfMemoryError; \" \"no stack trace available\"); pre_allocated_OutOfMemoryError_ = GcRoot&lt;mirror::Throwable&gt;(self-&gt;GetException()); self-&gt;ClearException(); //提前分配一个NoClassDefFoundError self-&gt;ThrowNewException(\"Ljava/lang/NoClassDefFoundError;\", \"Class not found using the boot class loader; no stack trace available\"); pre_allocated_NoClassDefFoundError_ = GcRoot&lt;mirror::Throwable&gt;(self-&gt;GetException()); self-&gt;ClearException(); ... //从传入的参数中获取native_bridge_file_name return true;&#125; Runtime::Init方法代码量较大,整个过程中创建或者初始化了很多工具组件如MemMap, QuasiAtomic等,并且从传入的参数依次获取了一些基础变量如boot_class_path_string_, class_path_string_等,之后还设置信号处理函数等,不过整体来看Init方法的主要逻辑很清楚,分别做了以下几件事: 创建OatFileManager对象,OatFileManager是在7.0中新增的工具类,Runtime在解析读取oat文件都是通过这个工具类完成 创建了Heap(整个创建过程比较冗长,复杂) 根据传入参数配置JIT选项,如果当前是dex2oat则不配置JIT 创建LinearAlloc 创建JavaVMExt 创建一个线程,同时attach线程(attach的过程实际就是创建Thread对象并初始化Thread对象的过程) 创建ClassLinker,如果有BootImageSpace则调用ClassLinker::InitFromBootImage完成ClassLinker的初始化;如果没有BootImageSpace,则调用ClassLinker::InitWithoutImage来完成初始化 提前分配一个OutOfMemoryError和NoClassDefFoundError Heap的创建过程比较复杂,个人觉得需要单独整理一个篇幅来学习, OatFileManager和LinearAlloc的构造函数都很简单, 另外ClassLinker的初始化过程也较为繁琐,加上ClassLinker类比较重要,同样需要单独的篇幅来学习 2.1.2 JavaVMExt::JavaVMExtJavaVMExt的源文件是/art/runtime/java_vm_ext.cc,JavaVMExt继承自JavaVM:123class JavaVMExt : public JavaVM &#123; ...&#125;; JavaVM定义在/libnativehelper/include/nativehelper/jni.h中 1234567891011121314151617181920JavaVMExt::JavaVMExt(Runtime* runtime, const RuntimeArgumentMap&amp; runtime_options) : runtime_(runtime), check_jni_abort_hook_(nullptr), check_jni_abort_hook_data_(nullptr), check_jni_(false), // Initialized properly in the constructor body below. force_copy_(runtime_options.Exists(RuntimeArgumentMap::JniOptsForceCopy)), tracing_enabled_(runtime_options.Exists(RuntimeArgumentMap::JniTrace) || VLOG_IS_ON(third_party_jni)), trace_(runtime_options.GetOrDefault(RuntimeArgumentMap::JniTrace)), globals_lock_(\"JNI global reference table lock\"), globals_(gGlobalsInitial, gGlobalsMax, kGlobal), libraries_(new Libraries), unchecked_functions_(&amp;gJniInvokeInterface), weak_globals_lock_(\"JNI weak global reference table lock\", kJniWeakGlobalsLock), weak_globals_(kWeakGlobalsInitial, kWeakGlobalsMax, kWeakGlobal), allow_accessing_weak_globals_(true), weak_globals_add_condition_(\"weak globals add condition\", weak_globals_lock_) &#123; functions = unchecked_functions_; SetCheckJniEnabled(runtime_options.Exists(RuntimeArgumentMap::CheckJni));&#125; 可以看到,JavaVMExt的构造函数存储了Runtme指针,之后初始化了自身变量 2.1.3 Thread::Startup1234567void Thread::Startup() &#123; ... //调用pthread_key_create来创建线程私有数据TLS CHECK_PTHREAD_CALL(pthread_key_create, (&amp;Thread::pthread_key_self_, Thread::ThreadExitCallback), \"self key\"); ...&#125; 2.1.4 Thread::Attach123456789101112131415161718192021222324252627282930313233343536Thread* Thread::Attach(const char* thread_name, bool as_daemon, jobject thread_group, bool create_peer) &#123; Runtime* runtime = Runtime::Current(); ... Thread* self; &#123; MutexLock mu(nullptr, *Locks::runtime_shutdown_lock_); if (runtime-&gt;IsShuttingDownLocked()) &#123; ... return nullptr; &#125; else &#123; Runtime::Current()-&gt;StartThreadBirth(); //创建Thread对象 self = new Thread(as_daemon); //初始化Thread对象 bool init_success = self-&gt;Init(runtime-&gt;GetThreadList(), runtime-&gt;GetJavaVM()); Runtime::Current()-&gt;EndThreadBirth(); if (!init_success) &#123; delete self; return nullptr; &#125; &#125; &#125; //设置创建String对象的entry point为StringFactory self-&gt;InitStringEntryPoints(); self-&gt;SetState(kNative); ... //传入的create_peer为false &#123; ScopedObjectAccess soa(self); Dbg::PostThreadStart(self); &#125; return self;&#125; 2.2 Runtime::Start123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778bool Runtime::Start() &#123; .. Thread* self = Thread::Current(); self-&gt;TransitionFromRunnableToSuspended(kNative); started_ = true; // 创建JIT if (jit_options_-&gt;UseJitCompilation() || jit_options_-&gt;GetSaveProfilingInfo()) &#123; std::string error_msg; if (!IsZygote()) &#123; // If we are the zygote then we need to wait until after forking to create the code cache // due to SELinux restrictions on r/w/x memory regions. CreateJit(); &#125; else if (jit_options_-&gt;UseJitCompilation()) &#123; if (!jit::Jit::LoadCompilerLibrary(&amp;error_msg)) &#123; // Try to load compiler pre zygote to reduce PSS. b/27744947 LOG(WARNING) &lt;&lt; \"Failed to load JIT compiler with error \" &lt;&lt; error_msg; &#125; &#125; &#125; ... &#123; ScopedTrace trace2(\"InitNativeMethods\"); //初始化JniConstants的常量,JniConstants定义在/libnativehelper/include/native/JniConstants.h //注册runtime中的native method,主要对应于Java层的java.lang,dalvik.system这些包下的类 InitNativeMethods(); &#125; //创建main_thread_group和system_thread_group InitThreadGroups(self); //创建一个java.lang.Thread对象,并将Thread.nativePeer变量设为ART中的Thread对象self Thread::FinishStartup(); //调用ClassLoader.getSystemClassLoader创建系统ClassLoader system_class_loader_ = CreateSystemClassLoader(this); //如果当前处于Zygote模式, 利用unshare,以及mount的SLAVE模式创建外部存储文件系统 if (is_zygote_) &#123; if (!InitZygote()) &#123; return false; &#125; &#125; else &#123; if (is_native_bridge_loaded_) &#123; PreInitializeNativeBridge(\".\"); &#125; NativeBridgeAction action = force_native_bridge_ ? NativeBridgeAction::kInitialize : NativeBridgeAction::kUnload; InitNonZygoteOrPostFork(self-&gt;GetJniEnv(), /* is_system_server */ false, action, GetInstructionSetString(kRuntimeISA)); &#125; //启动java.lang.Daemon中定义的后台线程 StartDaemonThreads(); &#123; ScopedObjectAccess soa(self); self-&gt;GetJniEnv()-&gt;locals.AssertEmpty(); &#125; finished_starting_ = true; //如果ProfilerOptions开启且存在profile文件,打开profile文件 if (profiler_options_.IsEnabled() &amp;&amp; !profile_output_filename_.empty()) &#123; int fd = open(profile_output_filename_.c_str(), O_RDWR|O_CREAT|O_EXCL, 0660); if (fd &gt;= 0) &#123; close(fd); &#125; else if (errno != EEXIST) &#123; LOG(WARNING) &lt;&lt; \"Failed to access the profile file. Profiler disabled.\"; &#125; &#125; ... //Trace相关 return true;&#125; Runtime::Start主要操作是: 如果当前不是Zygote,则创建JIT 初始化libnativehelper.so中定义的JniConstants,注册java.lang,dalvik.system包下的本地方法 创建main_thread_group和system_thread_group 创建一个java.lang.Thread对象,并将Thread.nativePeer变量设为ART中的Thread对象self 调用ClassLoader.getSystemClassLoader创建系统ClassLoader 如果当前处于Zygote模式, 利用unshare,以及mount的SLAVE模式创建外部存储文件系统;如果不是,则初始化native bridge 启动java.lang.Daemon中定义的后台线程 判断ProfilerOptions是否开启,如果开启且profile文件不为空,则打开profile文件(Profile文件是在7.0中跟JIT一起加入的, 主要为了提升运行效率) 查看Trace相关配置,如果不为空,则开启Trace 三.总结Java虚拟机有三个标准接口,只要实现这三个接口,就可以实现一个自定义的虚拟机,这三个接口分别是:JNI_CreateJavaVM_, JNI_GetCreatedJavaVMs_, JNI_GetDefaultJavaVMInitArgs_,这三个接口的具体实现都位于libart.so动态库中,Zygote进程是通过dlopen打开libart.so,之后通过dlsym分别导出这三个接口,并调用JNI_CreateJavaVM_创建虚拟机Runtime实例,并将Runtime实例保存在JavaVM结构,JavaVM代表的就是虚拟机执行环境(在libart.so中实际返回的是其子类JavaVMExt). 需要留意的是,源码的注释中写的很清楚,每一个进程都必须有一个JavaVM,而每一个线程都有一个JNIEnv JNI_CreateJavaVM_创建虚拟机Runtime的过程可以总结为: 解析传入的参数,将参数以key-value的形式组合在一起 调用Runtime::Create创建Runtime实例,创建的过程中还会依次创建OatFileManager, Heap, LinearAlloc, JavaVMExt, Thread, ClassLinker,同时初始化线程和ClassLinker 调用Runtime::Start完成最后的初始化工作","tags":[{"name":"ART","slug":"ART","permalink":"https://wangyun137.github.io/tags/ART/"},{"name":"源码分析","slug":"源码分析","permalink":"https://wangyun137.github.io/tags/源码分析/"}]},{"title":"ART的反射调用(二)--创建对象实例","date":"2017-07-24T06:38:58.000Z","path":"2017/07/24/ART的反射调用-二-创建对象实例/","text":"通过反射创建实例的用法是：123Class&lt;?&gt; clz = Class.forName(\"com.xx.xx\");Constructor&lt;?&gt; constructor = clz.getConstructor(String.Class);Object obj = constructor.newInstance(\"xx\"); 通过Class.forName在上一篇ART的反射调用(一)中已经分析 一. Class.getConstructor12345678910111213141516171819202122232425public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) throws NoSuchMethodException, SecurityException &#123; return getConstructor0(parameterTypes, Member.PUBLIC);&#125;private Constructor&lt;T&gt; getConstructor0(Class&lt;?&gt;[] parameterTypes, int which) throws NoSuchMethodException&#123; if (parameterTypes == null) &#123; parameterTypes = EmptyArray.CLASS; &#125; for (Class&lt;?&gt; c : parameterTypes) &#123; if (c == null) &#123; throw new NoSuchMethodException(\"parameter type is null\"); &#125; &#125; //核心调用 Constructor&lt;T&gt; result = getDeclaredConstructorInternal(parameterTypes); if (result == null || which == Member.PUBLIC &amp;&amp; !Modifier.isPublic(result.getAccessFlags())) &#123; throw new NoSuchMethodException(\"&lt;init&gt; \" + Arrays.toString(parameterTypes)); &#125; return result;&#125;private native Constructor&lt;T&gt; getDeclaredConstructorInternal(Class&lt;?&gt;[] args); 1.1 getDeclaredConstructorInternalgetDeclaredConstructorInternal的实现在/art/runtime/native/java_lang_Class.cc中 123456789101112static jobject Class_getDeclaredConstructorInternal( JNIEnv* env, jobject javaThis, jobjectArray args) &#123; ScopedFastNativeObjectAccess soa(env); //核心调用,[1.2] mirror::Constructor* result = mirror::Class::GetDeclaredConstructorInternal( soa.Self(), //将Java层的Class对象转换为mirror::Class指针 DecodeClass(soa, javaThis), //将Java层的数组转换为存放mirror::Class指针的数组 soa.Decode&lt;mirror::ObjectArray&lt;mirror::Class&gt;*&gt;(args)); return soa.AddLocalReference&lt;jobject&gt;(result);&#125; 1.2 mirror::Class::GetDeclaredConstructorInternalGetDeclaredConstructorInternal声明在/art/runtime/mirror/class.h12345template &lt;bool kTransactionActive = false&gt;static Constructor* GetDeclaredConstructorInternal(Thread* self, mirror::Class* klass, mirror::ObjectArray&lt;mirror::Class&gt;* args) SHARED_REQUIRES(Locks::mutator_lock_); NOTE:kTransactionActive默认为false 这个方法的实现在/art/runtime/mirror/class.cc1234567891011121314151617template &lt;bool kTransactionActive&gt;mirror::Constructor* Class::GetDeclaredConstructorInternal( Thread* self, mirror::Class* klass, mirror::ObjectArray&lt;mirror::Class&gt;* args) &#123; StackHandleScope&lt;1&gt; hs(self); //kTransactionActive默认为false const size_t pointer_size = kTransactionActive ? Runtime::Current()-&gt;GetClassLinker()-&gt;GetImagePointerSize() : sizeof(void*); //[1.3] ArtMethod* result = klass-&gt;GetDeclaredConstructor(self, hs.NewHandle(args), pointer_size); //[1.4] return result != nullptr ? mirror::Constructor::CreateFromArtMethod&lt;kTransactionActive&gt;(self, result) : nullptr;&#125; 1.3 mirror::Class::GetDeclaredConstructor123456789101112131415161718192021ArtMethod* Class::GetDeclaredConstructor(Thread* self, Handle&lt;mirror::ObjectArray&lt;mirror::Class&gt;&gt; args, size_t pointer_size) &#123; //迭代每一个Direct Method, [1.3.1] //m是ArtMethod for (auto&amp; m : GetDirectMethods(pointer_size)) &#123; // 跳过&lt;clinit&gt;方法, &lt;clinit&gt;是类的初始化方法,不是构造函数,所以跳过 if (m.IsStatic() || !m.IsConstructor()) &#123; continue; &#125; // May cause thread suspension and exceptions. // GetInterfaceMethodIfProxy方法一般情况下都是直接返回m的this引用 // EqualParameters方法用来判断传入的参数是否与方法本身的参数相同 if (m.GetInterfaceMethodIfProxy(sizeof(void*))-&gt;EqualParameters(args)) &#123; return &amp;m; &#125; if (UNLIKELY(self-&gt;IsExceptionPending())) &#123; return nullptr; &#125; &#125; return nullptr;&#125; 1.3.1 mirror::Class::GetDirectMethods1234inline IterationRange&lt;StrideIterator&lt;ArtMethod&gt;&gt; Class::GetDirectMethods(size_t pointer_size) &#123; CheckPointerSize(pointer_size); return GetDirectMethodsSliceUnchecked(pointer_size).AsRange();&#125; 可以看到,GetDirectMethods实质上就是封装调用了GetDirectMethodsSliceUnchecked,GetDirectMethodsSliceUnchecked定义在/art/runtime/mirror/class-inl.h 12345678///art/runtime/mirror/class-inl.hinline ArraySlice&lt;ArtMethod&gt; Class::GetDirectMethodsSliceUnchecked(size_t pointer_size) &#123; return ArraySlice&lt;ArtMethod&gt;(GetMethodsPtr(), //返回LengthPrefixedArray&lt;ArtMethod&gt;*,实质上封装的是当前类的Method数组指针 GetDirectMethodsStartOffset(),//返回Direct Method的起始偏移地址 GetVirtualMethodsStartOffset(),//返回Virtual Method的起始偏移地址 ArtMethod::Size(pointer_size),//pointer_size实质上是sizeof(void *) ArtMethod::Alignment(pointer_size));&#125; ArraySlice定义在/art/runtime/base/array_slice.h 12345678910111213141516171819202122232425262728293031323334353637// /art/runtime/base/array_slice.hArraySlice(LengthPrefixedArray&lt;T&gt;* array, uint32_t start_offset, uint32_t end_offset, size_t element_size = sizeof(T), size_t alignment = alignof(T)) : array_(nullptr), size_(end_offset - start_offset),//Virtual Method的起始地址减去Direct Method的起始地址,这一段存储的全部是Direct Method element_size_(element_size) &#123;//每一个element的大小都是sizeof(void *) ... if (size_ != 0) &#123; ... //T实质上是ArtMethod, 而array_的声明是T* array_,所以array_实质是ArtMethod* //实际就是将array_指向ArtMethod数组 array_ = &amp;array-&gt;At(start_offset, element_size_, alignment); &#125;&#125;//AsRange的作用是获取所有Direct MethodIterationRange&lt;StrideIterator&lt;T&gt;&gt; AsRange() &#123; return size() != 0 ? MakeIterationRange(begin(), end()) : MakeEmptyIterationRange(StrideIterator&lt;T&gt;(nullptr, 0));&#125;//指向ArtMethod数组的起始StrideIterator&lt;T&gt; begin() &#123; return StrideIterator&lt;T&gt;(&amp;AtUnchecked(0), element_size_);&#125;//size_是DirectMethods的长度StrideIterator&lt;T&gt; end() &#123; return StrideIterator&lt;T&gt;(&amp;AtUnchecked(size_), element_size_);&#125;T&amp; AtUnchecked(size_t index) &#123; return *reinterpret_cast&lt;T*&gt;(reinterpret_cast&lt;uintptr_t&gt;(array_) + index * element_size_);&#125; StrideIterator定义在/art/runtime/stride_iterator.h, StrideIterator继承自std::iterator,并且重写了操作符++: 12345678910111213template&lt;typename T&gt;class StrideIterator : public std::iterator&lt;std::forward_iterator_tag, T&gt; &#123; ... StrideIterator(T* ptr, size_t stride): ptr_(reinterpret_cast&lt;uintptr_t&gt;(ptr)), stride_(stride) &#123;&#125; StrideIterator operator++() &#123; // Value after modification. ptr_ += stride_; return *this; &#125; ...&#125; 从上面的代码中可以看出,mirror::Class::GetDirectMethods方法简单来说执行了以下几步: 获取Direct Method的数组 根据获取到的数组,封装得到Direct Method数组的iterator,这样就可以通过for循环迭代Direct Method数组 1.4 mirror::Constructor::CreateFromArtMethodmirror::Constructor类定义在/art/runtime/mirror/method.h123456789101112131415161718192021222324252627282930//继承自AbstractMethod, AbstractMethod定义在/art/runtime/mirror/abstract_method.hclass MANAGED Constructor: public AbstractMethod &#123; public: template &lt;bool kTransactionActive = false&gt; static Constructor* CreateFromArtMethod(Thread* self, ArtMethod* method) SHARED_REQUIRES(Locks::mutator_lock_) REQUIRES(!Roles::uninterruptible_); static mirror::Class* StaticClass() SHARED_REQUIRES(Locks::mutator_lock_) &#123; return static_class_.Read(); &#125; static void SetClass(Class* klass) SHARED_REQUIRES(Locks::mutator_lock_); static void ResetClass() SHARED_REQUIRES(Locks::mutator_lock_); static mirror::Class* ArrayClass() SHARED_REQUIRES(Locks::mutator_lock_) &#123; return array_class_.Read(); &#125; static void SetArrayClass(Class* klass) SHARED_REQUIRES(Locks::mutator_lock_); static void ResetArrayClass() SHARED_REQUIRES(Locks::mutator_lock_); static void VisitRoots(RootVisitor* visitor) SHARED_REQUIRES(Locks::mutator_lock_); private: static GcRoot&lt;Class&gt; static_class_; // java.lang.reflect.Constructor.class. static GcRoot&lt;Class&gt; array_class_; // [java.lang.reflect.Constructor.class.&#125;; CreateFromArtMethod的实现在/art/runtime/mirror/method.cc 1234567891011121314151617181920212223242526template &lt;bool kTransactionActive&gt; //kTransactionActive默认为falseConstructor* Constructor::CreateFromArtMethod(Thread* self, ArtMethod* method) &#123; ... //生成java.lang.reflect.Constructor对象并转换为Constructor*指针 auto* ret = down_cast&lt;Constructor*&gt;(StaticClass()-&gt;AllocObject(self)); if (LIKELY(ret != nullptr)) &#123; //将Constructor*指针向上转型为AbstractMethod*指针,并调用AbstractMethod的CreateFromArtMethod static_cast&lt;AbstractMethod*&gt;(ret)-&gt;CreateFromArtMethod&lt;kTransactionActive&gt;(method); &#125; return ret;&#125;//设置构造函数的基本信息,如accessFlag,methodIndex等template &lt;bool kTransactionActive&gt; //kTransactionActive默认为falsebool AbstractMethod::CreateFromArtMethod(ArtMethod* method) &#123; auto* interface_method = method-&gt;GetInterfaceMethodIfProxy( kTransactionActive ? Runtime::Current()-&gt;GetClassLinker()-&gt;GetImagePointerSize() : sizeof(void*)); SetArtMethod&lt;kTransactionActive&gt;(method); SetFieldObject&lt;kTransactionActive&gt;(DeclaringClassOffset(), method-&gt;GetDeclaringClass()); SetFieldObject&lt;kTransactionActive&gt;( DeclaringClassOfOverriddenMethodOffset(), interface_method-&gt;GetDeclaringClass()); SetField32&lt;kTransactionActive&gt;(AccessFlagsOffset(), method-&gt;GetAccessFlags()); SetField32&lt;kTransactionActive&gt;(DexMethodIndexOffset(), method-&gt;GetDexMethodIndex()); return true;&#125; 二. Constructor.newInstance123456789101112public T newInstance(Object... args) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123; //一般情况下,serializationClass为null if (serializationClass == null) &#123; return newInstance0(args); &#125; else &#123; return (T) newInstanceFromSerialization(serializationCtor, serializationClass); &#125;&#125;private native T newInstance0(Object... args) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException; 2.1 newInstance0newInstance0的实现在/art/runtime/native/java_lang_refrect_Constructor1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556static jobject Constructor_newInstance0(JNIEnv* env, jobject javaMethod, jobjectArray javaArgs) &#123; ScopedFastNativeObjectAccess soa(env); mirror::Constructor* m = soa.Decode&lt;mirror::Constructor*&gt;(javaMethod); StackHandleScope&lt;1&gt; hs(soa.Self()); Handle&lt;mirror::Class&gt; c(hs.NewHandle(m-&gt;GetDeclaringClass())); //抽象类不允许创建对象 if (UNLIKELY(c-&gt;IsAbstract())) &#123; soa.Self()-&gt;ThrowNewExceptionF(\"Ljava/lang/InstantiationException;\", \"Can't instantiate %s %s\", c-&gt;IsInterface() ? \"interface\" : \"abstract class\", PrettyDescriptor(c.Get()).c_str()); return nullptr; &#125; // 如果构造函数不可访问且Class不是public if (!m-&gt;IsAccessible() &amp;&amp; !c-&gt;IsPublic()) &#123; //回退两个栈帧,newInstance0一般都是通过Constructor.newInstance(Object... arg0)调用 auto* caller = GetCallingClass(soa.Self(), 2); if (caller != nullptr &amp;&amp; !caller-&gt;CanAccess(c.Get())) &#123; if (PrettyDescriptor(c.Get()) == \"dalvik.system.DexPathList$Element\") &#123; LOG(WARNING) &lt;&lt; \"The dalvik.system.DexPathList$Element constructor\" is not accessible by default. This is a temporary \" \"workaround for backwards compatibility with class-loader hacks.\" \"Please update your application.\"; &#125; else &#123; soa.Self()-&gt;ThrowNewExceptionF( \"Ljava/lang/IllegalAccessException;\", \"%s is not accessible from %s\", PrettyClass(c.Get()).c_str(), PrettyClass(caller).c_str()); return nullptr; &#125; &#125; &#125; //确保类已经被解析完成 if (!Runtime::Current()-&gt;GetClassLinker()-&gt;EnsureInitialized(soa.Self(), c, true, true)) &#123; DCHECK(soa.Self()-&gt;IsExceptionPending()); return nullptr; &#125; bool movable = true; //如果当前要创建对象的类是java.lang.Class if (!kMovingClasses &amp;&amp; c-&gt;IsClassClass()) &#123; movable = false; &#125; // String constructor is replaced by a StringFactory method in InvokeMethod. if (c-&gt;IsStringClass()) &#123; return InvokeMethod(soa, javaMethod, nullptr, javaArgs, 2); &#125; //如果类是java.lang.Class,则调用Class::AllocNonMovableObject创建对象 mirror::Object* receiver = movable ? c-&gt;AllocObject(soa.Self()) : c-&gt;AllocNonMovableObject(soa.Self()); if (receiver == nullptr) &#123; return nullptr; &#125; jobject javaReceiver = soa.AddLocalReference&lt;jobject&gt;(receiver); InvokeMethod(soa, javaMethod, javaReceiver, javaArgs, 2); // Constructors are ()V methods, so we shouldn't touch the result of InvokeMethod. return javaReceiver;&#125; 从上述代码中可以得出: 如果类是抽象类,则不允许创建对象 如果要创建的类不是public且构造函数不可访问,则抛出IllegalAccessException(dalvik.system.DexPathList$Element除外) 创建对象之前,要确保类已经完成了解析 如果要创建对象的类是java.lang.String,则特别对待,最终要调用java.lang.StringFactory来创建String对象 2.2 InvokeMethodInvokeMethod的实现在/art/runtime/reflection.cc12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879jobject InvokeMethod(const ScopedObjectAccessAlreadyRunnable&amp; soa, jobject javaMethod, jobject javaReceiver, jobject javaArgs, size_t num_frames) &#123; //如果函数调用栈不对,则抛出StackOverFlowError ... //将javaMethod即java层的Constructor对象转换为mirror::AbstractMethod* //java层的Constructor类对应mirror::Constructor,而mirror::Constructor继承自mirror::AbstractMethod auto* abstract_method = soa.Decode&lt;mirror::AbstractMethod*&gt;(javaMethod); const bool accessible = abstract_method-&gt;IsAccessible(); ArtMethod* m = abstract_method-&gt;GetArtMethod(); mirror::Class* declaring_class = m-&gt;GetDeclaringClass(); //一般情况下,要创建对象的类已经被解析过 if (UNLIKELY(!declaring_class-&gt;IsInitialized())) &#123; ... &#125; mirror::Object* receiver = nullptr; if (!m-&gt;IsStatic()) &#123; //如果要创建对象的类是String,则用StringFactory来创建String对象 if (declaring_class-&gt;IsStringClass() &amp;&amp; m-&gt;IsConstructor()) &#123; jmethodID mid = soa.EncodeMethod(m); //根据methodId获取对应的StringFactory的方法 m = soa.DecodeMethod(WellKnownClasses::StringInitToStringFactoryMethodID(mid)); &#125; else &#123; receiver = soa.Decode&lt;mirror::Object*&gt;(javaReceiver); if (!VerifyObjectIsClass(receiver, declaring_class)) &#123; return nullptr; &#125; // 查找虚拟方法的真正实现 m = receiver-&gt;GetClass()-&gt;FindVirtualMethodForVirtualOrInterface(m, sizeof(void*)); &#125; &#125; // 将java层的参数转换为mirror::ObjectArray数组 auto* objects = soa.Decode&lt;mirror::ObjectArray&lt;mirror::Object&gt;*&gt;(javaArgs); auto* np_method = m-&gt;GetInterfaceMethodIfProxy(sizeof(void*)); //获取要调用的方法在dex文件中记录的参数列表 const DexFile::TypeList* classes = np_method-&gt;GetParameterTypeList(); uint32_t classes_size = (classes == nullptr) ? 0 : classes-&gt;Size(); uint32_t arg_count = (objects != nullptr) ? objects-&gt;GetLength() : 0; //判断传入的参数与dex文件中记录的参数是否一致,不一致抛出IllegalArgumentException if (arg_count != classes_size) &#123; ...//throw IllegalArgumentException return nullptr; &#125; // 验证类的accessible mirror::Class* calling_class = nullptr; if (!accessible &amp;&amp; !VerifyAccess(soa.Self(), receiver, declaring_class, m-&gt;GetAccessFlags(), &amp;calling_class, num_frames)) &#123; ...//throw IllegalAccessException return nullptr; &#125; JValue result; uint32_t shorty_len = 0; //获取method的方法声明字符串 const char* shorty = np_method-&gt;GetShorty(&amp;shorty_len); ArgArray arg_array(shorty, shorty_len); //创建参数数组 if (!arg_array.BuildArgArrayFromObjectArray(receiver, objects, np_method)) &#123; CHECK(soa.Self()-&gt;IsExceptionPending()); return nullptr; &#125; //核心调用,执行方法, [2.3] InvokeWithArgArray(soa, m, &amp;arg_array, &amp;result, shorty); // 如果有异常发生,则抛出InvocationTargetException if (soa.Self()-&gt;IsExceptionPending()) &#123; ... //创建InvocationTargetException对象实例,并抛出 return nullptr; &#125; // 如果是基础类型,则自动装箱并返回 return soa.AddLocalReference&lt;jobject&gt;(BoxPrimitive(Primitive::GetType(shorty[0]), result));&#125; 2.3 InvokeWithArgArray123456789static void InvokeWithArgArray(const ScopedObjectAccessAlreadyRunnable&amp; soa, ArtMethod* method, ArgArray* arg_array, JValue* result, const char* shorty) SHARED_REQUIRES(Locks::mutator_lock_) &#123; uint32_t* args = arg_array-&gt;GetArray(); ... //最后实际调用ArtMethod::Invoke method-&gt;Invoke(soa.Self(), args, arg_array-&gt;GetNumBytes(), result, shorty);&#125; 2.4 总结可以看到最后Constructor.newInstance最后实际调用的是ArtMethod::Invoke方法,在执行ArtMethod::Invoke之前的所有工作主要是确保类已经被解析,以及生成参数,另外如果要创建对象的类是String类,则都转而调用相应的StringFactory的方法,由此可以看出创建String对象都是由StringFactory完成. ArtMethod::Invoke方法涉及到了方法具体的执行逻辑(执行本地机器指令还是解释执行,以及调用到其他方法是entryPoint等),另外Android 7.0还加入了JIT机制,这些需要花时间慢慢掌握.下面这张图是官网的JIT的工作流程图","tags":[{"name":"ART","slug":"ART","permalink":"https://wangyun137.github.io/tags/ART/"},{"name":"源码分析","slug":"源码分析","permalink":"https://wangyun137.github.io/tags/源码分析/"}]},{"title":"ART的反射调用(一)-获取Class对象","date":"2017-07-24T06:24:25.000Z","path":"2017/07/24/ART的反射调用-一-获取Class对象/","text":"典型的反射调用形式为：12345678910private static void classForName() &#123; try &#123; // 获取 Class 对象 Class&lt;?&gt; clz = Class.forName(\"com.xx.xx.XX\"); ... &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 1. Class.forName12345678910111213141516171819202122232425public static Class&lt;?&gt; forName(String className) throws ClassNotFoundException &#123; return forName(className, true, VMStack.getCallingClassLoader());&#125;public static Class&lt;?&gt; forName(String name, boolean initialize,ClassLoader loader) throws ClassNotFoundException&#123; if (loader == null) &#123; loader = BootClassLoader.getInstance(); &#125; Class&lt;?&gt; result; try &#123; result = classForName(name, initialize, loader); &#125; catch (ClassNotFoundException e) &#123; Throwable cause = e.getCause(); if (cause instanceof LinkageError) &#123; throw (LinkageError) cause; &#125; throw e; &#125; return result;&#125;static native Class&lt;?&gt; classForName(String className, boolean shouldInitialize, ClassLoader classLoader) throws ClassNotFoundException; Class.forName(String)函数实际是封装调用另一个重载版本的Class.forName(String,boolean,ClassLoader), 在传入第三个参数时首先调用VMStack.getCallingClassLoader方法，这个方法从函数名中大致可以判断出它的作用是获取当前调用者ClassLoader，最后再调用本地方法classForName 1.1 VMStack.getCallingClassLoader1native public static ClassLoader getCallingClassLoader(); 1234567891011// 定义在art/runtime/native/dalvik_system_VMStack.ccstatic jobject VMStack_getCallingClassLoader(JNIEnv* env, jclass) &#123; ScopedFastNativeObjectAccess soa(env); NthCallerVisitor visitor(soa.Self(), 2); visitor.WalkStack(); if (UNLIKELY(visitor.caller == nullptr)) &#123; // The caller is an attached native thread. return nullptr; &#125; return soa.AddLocalReference&lt;jobject&gt;(visitor.caller-&gt;GetDeclaringClass()-&gt;GetClassLoader());&#125; 这个方法的核心调用是visitor.WalkStack()，WalkStack()的实现在art/runtime/stack.cc,具体的实现这里先不深究(由于时间原因，这块内容还未理解透彻)，不过从代码中可以大致看出WalkStack()方法是根据函数调用栈帧获取到当前调用者，继而获取对应的ClassLoader 2. Class_classForName12345678910111213141516171819202122232425262728293031323334353637383940static jclass Class_classForName(JNIEnv* env, jclass, jstring javaName, jboolean initialize, jobject javaLoader) &#123; ScopedFastNativeObjectAccess soa(env); ScopedUtfChars name(env, javaName); if (name.c_str() == nullptr) &#123; return nullptr; &#125; // 将com.xx.xx转换为com/xx/xx if (!IsValidBinaryClassName(name.c_str())) &#123; soa.Self()-&gt;ThrowNewExceptionF(\"Ljava/lang/ClassNotFoundException;\", \"Invalid name: %s\", name.c_str()); return nullptr; &#125; std::string descriptor(DotToDescriptor(name.c_str())); StackHandleScope&lt;2&gt; hs(soa.Self()); Handle&lt;mirror::ClassLoader&gt; class_loader(hs.NewHandle(soa.Decode&lt;mirror::ClassLoader*&gt;(javaLoader))); ClassLinker* class_linker = Runtime::Current()-&gt;GetClassLinker(); //核心调用，调用ClassLinker::FindClass() Handle&lt;mirror::Class&gt; c( hs.NewHandle(class_linker-&gt;FindClass(soa.Self(), descriptor.c_str(), class_loader))); if (c.Get() == nullptr) &#123; ScopedLocalRef&lt;jthrowable&gt; cause(env, env-&gt;ExceptionOccurred()); env-&gt;ExceptionClear(); jthrowable cnfe = reinterpret_cast&lt;jthrowable&gt;(env-&gt;NewObject(WellKnownClasses::java_lang_ClassNotFoundException, WellKnownClasses::java_lang_ClassNotFoundException_init, javaName, cause.get())); if (cnfe != nullptr) &#123; // Make sure allocation didn't fail with an OOME. env-&gt;Throw(cnfe); &#125; return nullptr; &#125; if (initialize) &#123; //确保类已经完成解析 class_linker-&gt;EnsureInitialized(soa.Self(), c, true, true); &#125; return soa.AddLocalReference&lt;jclass&gt;(c.Get());&#125; 从代码中可以看出核心调用是class_linker-&gt;FindClass(...) 3. ClassLinker::FindClass123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687mirror::Class* ClassLinker::FindClass(Thread* self, const char* descriptor, Handle&lt;mirror::ClassLoader&gt; class_loader) &#123; ... self-&gt;AssertNoPendingException(); if (descriptor[1] == &apos;\\0&apos;) &#123; // 只有基础类型的descriptor是1个字符 return FindPrimitiveClass(descriptor[0]); &#125; const size_t hash = ComputeModifiedUtf8Hash(descriptor); // 在传入的ClassLoader的已加载表中查找类, [3.1] mirror::Class* klass = LookupClass(self, descriptor, hash, class_loader.Get()); if (klass != nullptr) &#123; //确保类已经被解析 return EnsureResolved(self, descriptor, klass); &#125; // 执行到这里，意味着没有找到类 if (descriptor[0] == &apos;[&apos;) &#123; return CreateArrayClass(self, descriptor, hash, class_loader); &#125; else if (class_loader.Get() == nullptr) &#123; // 如果ClassLoader是nullptr，则在boot_class_path_中查找 ClassPathEntry pair = FindInClassPath(descriptor, hash, boot_class_path_); if (pair.second != nullptr) &#123; return DefineClass(self, descriptor, hash, ScopedNullHandle&lt;mirror::ClassLoader&gt;(), *pair.first, *pair.second); &#125; else &#123; //仍然没有找到的话，创建一个ClassNoDefFoundError mirror::Throwable* pre_allocated = Runtime::Current()-&gt;GetPreAllocatedNoClassDefFoundError(); self-&gt;SetException(pre_allocated); return nullptr; &#125; &#125; else &#123; ScopedObjectAccessUnchecked soa(self); mirror::Class* cp_klass; //递归的在传入的ClassLoader以及它的各级parent中查找类, [3.2] if (FindClassInPathClassLoader(soa, self, descriptor, hash, class_loader, &amp;cp_klass)) &#123; if (cp_klass != nullptr) &#123; //找到，直接返回 return cp_klass; &#125; &#125; //如果Runtime是编译器，则直接创建ClassNoDefFoundError,只有在dex2oat中创建的Runtime会是编译器 if (Runtime::Current()-&gt;IsAotCompiler()) &#123; mirror::Throwable* pre_allocated = Runtime::Current()-&gt;GetPreAllocatedNoClassDefFoundError(); self-&gt;SetException(pre_allocated); return nullptr; &#125; //执行到意味着仍然没有找到相应的类 ScopedLocalRef&lt;jobject&gt; class_loader_object(soa.Env(), soa.AddLocalReference&lt;jobject&gt;(class_loader.Get())); std::string class_name_string(DescriptorToDot(descriptor)); ScopedLocalRef&lt;jobject&gt; result(soa.Env(), nullptr); &#123; ScopedThreadStateChange tsc(self, kNative); ScopedLocalRef&lt;jobject&gt; class_name_object(soa.Env(), soa.Env()-&gt;NewStringUTF(class_name_string.c_str())); if (class_name_object.get() == nullptr) &#123; return nullptr; &#125; //调用ClassLoader的loadClass在传入的ClassLoader中查找 result.reset(soa.Env()-&gt;CallObjectMethod(class_loader_object.get(), WellKnownClasses::java_lang_ClassLoader_loadClass, class_name_object.get())); &#125; if (self-&gt;IsExceptionPending()) &#123; // If the ClassLoader threw, pass that exception up. return nullptr; &#125; else if (result.get() == nullptr) &#123; // 抛出NullPointerException ThrowNullPointerException(StringPrintf(&quot;ClassLoader.loadClass returned null for %s&quot;, class_name_string.c_str()).c_str()); return nullptr; &#125; else &#123; // 终于找到 return soa.Decode&lt;mirror::Class*&gt;(result.get()); &#125; &#125; UNREACHABLE();&#125; ClassLinker::FindClass的逻辑可以总结为： 如果要找的类是基础类型，则直接调用FindPrimitiveClass查找基础类型；如果不是则在传入的ClassLoader的已加载类表中查找类(首先会判断ClassLaoder是否为null，如果为null,就在boot_class_table_中查找，否则就在ClassLoader自己的ClassTable中查找)，如果找到，确保类已经被解析并返回 如果在传入的ClassLoader的已加载类表中没有找到类,则首先判断ClassLoader是否为空，如果为空，在boot_class_path_中查找，如果不为空，则调用FindClassInPathClassLoader在传入的ClassLoader以及它的各级parent中查找类 如果仍然没有找到，则调用传入的ClassLoader的loadClass在传入的ClassLoader中查找，找到返回，否则抛出异常 3.1 ClassLinker::LookupClass1234567891011121314151617181920212223242526272829303132333435mirror::Class* ClassLinker::LookupClass(Thread* self, const char* descriptor, size_t hash, mirror::ClassLoader* class_loader) &#123; &#123; ReaderMutexLock mu(self, *Locks::classlinker_classes_lock_); //获取ClassLoader对应的ClassTable，如果ClassLoader为null,则则返回boot_class_table_ ClassTable* const class_table = ClassTableForClassLoader(class_loader); if (class_table != nullptr) &#123; mirror::Class* result = class_table-&gt;Lookup(descriptor, hash); if (result != nullptr) &#123; return result; &#125; &#125; &#125; if (class_loader != nullptr || !dex_cache_boot_image_class_lookup_required_) &#123; return nullptr; &#125; //在Image Space中查找类，Image Space映射的是boot.art和boot.oat mirror::Class* result = LookupClassFromBootImage(descriptor); if (result != nullptr) &#123; result = InsertClass(descriptor, result, hash); &#125; else &#123; constexpr uint32_t kMaxFailedDexCacheLookups = 1000; if (++failed_dex_cache_class_lookups_ &gt; kMaxFailedDexCacheLookups) &#123; AddBootImageClassesToClassTable(); &#125; &#125; return result;&#125;ClassTable* ClassLinker::ClassTableForClassLoader(mirror::ClassLoader* class_loader) &#123; return class_loader == nullptr ? &amp;boot_class_table_ : class_loader-&gt;GetClassTable();&#125; 3.2 ClassLinker::FindClassInPathClassLoader123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118bool ClassLinker::FindClassInPathClassLoader(ScopedObjectAccessAlreadyRunnable&amp; soa, Thread* self, const char* descriptor, size_t hash, Handle&lt;mirror::ClassLoader&gt; class_loader, mirror::Class** result) &#123; //递归调用的终止条件 //如果是BootClassLoader,在boot_class_path_中查找类，并完成类的解析 if (IsBootClassLoader(soa, class_loader.Get())) &#123; ClassPathEntry pair = FindInClassPath(descriptor, hash, boot_class_path_); if (pair.second != nullptr) &#123; mirror::Class* klass = LookupClass(self, descriptor, hash, nullptr); if (klass != nullptr) &#123; *result = EnsureResolved(self, descriptor, klass); &#125; else &#123; *result = DefineClass(self,descriptor,hash, ScopedNullHandle&lt;mirror::ClassLoader&gt;(), *pair.first, *pair.second); &#125; if (*result == nullptr) &#123; self-&gt;ClearException(); &#125; &#125; else &#123; *result = nullptr; &#125; return true; &#125; //递归调用的终止条件 //确保传入的ClassLoader必须是PathClassLoader if (class_loader-&gt;GetClass() != soa.Decode&lt;mirror::Class*&gt;( WellKnownClasses::dalvik_system_PathClassLoader)) &#123; *result = nullptr; return false; &#125; // Handles as RegisterDexFile may allocate dex caches (and cause thread suspension). StackHandleScope&lt;4&gt; hs(self); Handle&lt;mirror::ClassLoader&gt; h_parent(hs.NewHandle(class_loader-&gt;GetParent())); //递归调用,在parent中查找,一般情况下，一个应用的PathClassLoader的parent层级为： //PathClassLoader(apk)--&gt;PathClassLoader(system)-&gt;BootClassLoader //所以一般情况下，传入的ClassLoader的parent就是系统的PathClassLoader, 从而递归调用只会调用两次，即 //h_parent第一次等于PathClassLoader(system),第二次h_parent等于BootClassLoader bool recursive_result = FindClassInPathClassLoader(soa, self, descriptor, hash, h_parent, result); if (!recursive_result) &#123; // Something wrong up the chain. return false; &#125; if (*result != nullptr) &#123; // Found the class up the chain. return true; &#125; //获取DexFile的mCookie变量，mCookie指向的是已加载的dex文件列表 ArtField* const cookie_field = soa.DecodeField(WellKnownClasses::dalvik_system_DexFile_cookie); //获取DexPathList的dexElements ArtField* const dex_file_field = soa.DecodeField(WellKnownClasses::dalvik_system_DexPathList__Element_dexFile); //获取PathClassLoader的pathList属性 mirror::Object* dex_path_list = soa.DecodeField(WellKnownClasses::dalvik_system_PathClassLoader_pathList)-&gt; GetObject(class_loader.Get()); if (dex_path_list != nullptr &amp;&amp; dex_file_field != nullptr &amp;&amp; cookie_field != nullptr) &#123; mirror::Object* dex_elements_obj = soa.DecodeField(WellKnownClasses::dalvik_system_DexPathList_dexElements)-&gt; GetObject(dex_path_list); if (dex_elements_obj != nullptr) &#123; Handle&lt;mirror::ObjectArray&lt;mirror::Object&gt;&gt; dex_elements = hs.NewHandle(dex_elements_obj-&gt;AsObjectArray&lt;mirror::Object&gt;()); for (int32_t i = 0; i &lt; dex_elements-&gt;GetLength(); ++i) &#123; mirror::Object* element = dex_elements-&gt;GetWithoutChecks(i); if (element == nullptr) &#123; // Should never happen, fall back to java code to throw a NPE. break; &#125; mirror::Object* dex_file = dex_file_field-&gt;GetObject(element); if (dex_file != nullptr) &#123; //将mCookie转换为LongArray*类型 mirror::LongArray* long_array = cookie_field-&gt;GetObject(dex_file)-&gt;AsLongArray(); if (long_array == nullptr) &#123; break; &#125; int32_t long_array_size = long_array-&gt;GetLength(); for (int32_t j = kDexFileIndexStart; j &lt; long_array_size; ++j) &#123; //将LongArray转换为DexFile*类型 const DexFile* cp_dex_file = reinterpret_cast&lt;const DexFile*&gt;(static_cast&lt;uintptr_t&gt;( long_array-&gt;GetWithoutChecks(j))); //查找ClassDef const DexFile::ClassDef* dex_class_def = cp_dex_file-&gt;FindClassDef(descriptor, hash); if (dex_class_def != nullptr) &#123; //解析类，加载属性，方法 mirror::Class* klass = DefineClass(self, descriptor, hash, class_loader, *cp_dex_file, *dex_class_def); if (klass == nullptr) &#123; self-&gt;ClearException(); return true; &#125; *result = klass; return true; &#125; &#125; &#125; &#125; &#125; self-&gt;AssertNoPendingException(); &#125; // Result is still null from the parent call, no need to set it again... return true;&#125; FindClassInPathClassLoader主要逻辑是递归的在传入的ClassLoader的各级parent中依次查找类(典型的双亲委派模式) , 一般情况下，一个应用的PathClassLoader的parent层级为：｀PathClassLoader(apk)–&gt;PathClassLoader(system)-&gt;BootClassLoader｀所以一般情况下，传入的ClassLoader的parent就是系统的PathClassLoader, 从而递归调用只会调用两次，即h_parent第一次等于PathClassLoader(system),第二次h_parent等于BootClassLoader. 在双亲中如果找到类，则直接返回，如果没有找到，则依次获取几个重要的变量BaseDexClassLoader.pathList, DexPathList.dexElement, DexFile.mCookie,根据这几个变量在传入的ClassLoader所加载的dex文件列表中查找类 4. 总结一般而言，反射获取一个类时会调用Class.forName(String)，获取类的过程可以总结为以下几步： 根据函数调用栈帧获取调用者的ClassLoader(如果调用的是Class.forName(String, boolean, ClassLoader),就没有根据栈帧获取ClassLoader这一步) 每一个ClassLoader都有一个ClassTable,用来缓存已经加载的类．如果传入的ClassLoader为null,就在BootClassLoader对应的boot_class_table_中查找，如果ClassLaoder不为null,就在ClassLoader对应的ClassTable中查找；如果找到Class，确保Class已经解析后,返回，否则进入下一步 如果没有在缓存的ClassTable中找到类，首先判断传入的ClassLoader是否为null,如果是，就在boot_class_path_中查找，如果不是，则递归的依次在传入的ClassLoader各级parent以及自身当中查找类(除了BootClassLoader,其余parent以及自身ClassLoader都必须是PathClassLoader,查找类主要是通过在Java层的几个重要变量完成:BaseDexClassLoader.pathList, DexPathList.dexElement, DexFile.mCookie),如果找到则返回(查找的过程中，如果找到了类，会完成对类的解析过程)，如果没找到则再进入下一步 以上几步都没有找到的话，再调用传入的ClassLoader的loadClass进行最后一次查找(loadClass的过程中如果找到类，也会完成对类的解析)，找到则返回，没找到则抛出异常","tags":[{"name":"ART","slug":"ART","permalink":"https://wangyun137.github.io/tags/ART/"},{"name":"源码分析","slug":"源码分析","permalink":"https://wangyun137.github.io/tags/源码分析/"}]},{"title":"ART加载类","date":"2017-07-24T06:19:26.000Z","path":"2017/07/24/ART加载类/","text":"一．创建Activity对象ART在加载完dex文件后，会通过Instrumentation创建Activity对象123456789101112131415161718192021222324private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ... Activity activity = null; try &#123; //加载dex文件 java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); //创建Activity对象 activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( \"Unable to instantiate activity \" + component + \": \" + e.toString(), e); &#125; &#125; ...&#125; 1. Instrumentation.newActivity()123456public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; return (Activity)cl.loadClass(className).newInstance();&#125; 从之前的加载dex文件的过程中可以知道这里传入的ClassLoader是PathClassLoader 以我自己写的demo为例，PathClassLoader是:12dalvik.system.PathClassLoader[DexPathList[[zip file \"/data/app/com.singuloid.myapplication-1/base.apk\"],nativeLibraryDirectories=[/data/app/com.singuloid.myapplication-1/lib/arm, /system/lib, /vendor/lib]]] PathClassLoader继承自BaseDexClassLoader,而BaseDexClassLoader又是继承自ClassLoader,PathClassLoader和BaseDexClassLoader两个类都没有重写loadClass()，所以这里实际调用的基类ClassLoader.loadClass 2. ClassLoader.loadClass()12345678910111213141516171819202122232425protected Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException &#123; //先查找之前是否已经过要加载的类, [2.1] Class c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; //在parent中查找类 c = parent.loadClass(name, false); &#125; else &#123; //如果parent为null，则代表当前ClassLoader是BootClassLoader c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; long t1 = System.nanoTime(); c = findClass(name); &#125; &#125; return c;&#125; 从代码中可以看出，ART的类加载机制也同样采用双亲委派模式，即先由父ClassLoader进行加载，如果没有加载成功，再交由子ClassLoader加载，依照此顺序，依次向下进行．如果查找的是应用自己的类，如果没有加载过，最后都会在应用自己的ClassLoader中查找 如果父类加载器没有加载到类，则调用当前类加载器的findClass方法，在创建Activity对象这个场景下，当前的类加载器是PathClassLoader,而PathClassLoader并没有重写findClass,查看其父类BaseDexClassLoader，发现BaseDexClassLoader重写了findClass这个方法 2.1 ClassLoader.findLoadedClass12345678protected final Class&lt;?&gt; findLoadedClass(String name) &#123; ClassLoader loader; if (this == BootClassLoader.getInstance()) loader = null; else loader = this; return VMClassLoader.findLoadedClass(loader, name);&#125; VMClassLoader.findLoadedClass是一个native方法，其实现在art/runtime/native/lava_lang_VMClassLoader： 1234567891011121314151617181920212223242526272829303132333435static jclass VMClassLoader_findLoadedClass(JNIEnv* env, jclass, jobject javaLoader, jstring javaName) &#123; ScopedFastNativeObjectAccess soa(env); mirror::ClassLoader* loader = soa.Decode&lt;mirror::ClassLoader*&gt;(javaLoader); ScopedUtfChars name(env, javaName); if (name.c_str() == nullptr) &#123; return nullptr; &#125; ClassLinker* cl = Runtime::Current()-&gt;GetClassLinker(); std::string descriptor(DotToDescriptor(name.c_str())); const size_t descriptor_hash = ComputeModifiedUtf8Hash(descriptor.c_str()); //在传入的ClassLoader中查找类，每一个ClassLoader都有一个ClassTable，用来记录已经加载的类 mirror::Class* c = cl-&gt;LookupClass(soa.Self(), descriptor.c_str(), descriptor_hash, loader); //如果找到类，且类已经被正确解析，则直接返回 if (c != nullptr &amp;&amp; c-&gt;IsResolved()) &#123; return soa.AddLocalReference&lt;jclass&gt;(c); &#125; //如果类是错误的，则抛出相应异常 if (c != nullptr &amp;&amp; c-&gt;IsErroneous()) &#123; ... return nullptr; &#125; //执行到这里，意味着没有在缓存的ClassTable中找到类，需要进一步到dex文件中进行查找 if (loader != nullptr) &#123; StackHandleScope&lt;1&gt; hs(soa.Self()); cl-&gt;FindClassInPathClassLoader(soa, soa.Self(), descriptor.c_str(), descriptor_hash, hs.NewHandle(loader), &amp;c); if (c != nullptr) &#123; return soa.AddLocalReference&lt;jclass&gt;(c); &#125; &#125; // Class wasn't resolved so it may be erroneous or not yet ready, force the caller to go into // the regular loadClass code. return nullptr;&#125; 3. BaseDexClassLoader.findClass()12345678910111213@Overrideprotected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; List&lt;Throwable&gt; suppressedExceptions = new ArrayList&lt;Throwable&gt;(); Class c = pathList.findClass(name, suppressedExceptions); if (c == null) &#123; ClassNotFoundException cnfe = new ClassNotFoundException(\"Didn't find class \\\"\" + name + \"\\\" on path: \" + pathList); for (Throwable t : suppressedExceptions) &#123; cnfe.addSuppressed(t); &#125; throw cnfe; &#125; return c;&#125; 由之前的ART 加载dex文件可知，BaseDexClassLoader的pathList变量指向的是一个DexPathList,而DexPathList是用来保存加载的dex文件列表，从这里我们知道BaseDexClassLoader又将加载类的过程委派给了DexPathList 4. DexPathList.findClass()1234567891011121314151617public Class findClass(String name, List&lt;Throwable&gt; suppressed) &#123; //迭代dexElements for (Element element : dexElements) &#123; DexFile dex = element.dexFile; if (dex != null) &#123; Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed); if (clazz != null) &#123; return clazz; &#125; &#125; &#125; if (dexElementsSuppressedExceptions != null) &#123; suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions)); &#125; return null;&#125; 从代码中可知,其主要逻辑是遍历之前加载过得dex文件列表，依次在每个dex文件中查找，直到加载到相应的类 5. DexFile.loadClassBinaryName()123456789101112131415161718192021222324public Class loadClassBinaryName(String name, ClassLoader loader, List&lt;Throwable&gt; suppressed) &#123; //mCookie保存的是加载的dex文件列表 return defineClass(name, loader, mCookie, suppressed);&#125;private static Class defineClass(String name, ClassLoader loader, Object cookie, List&lt;Throwable&gt; suppressed) &#123; Class result = null; try &#123; result = defineClassNative(name, loader, cookie); &#125; catch (NoClassDefFoundError e) &#123; if (suppressed != null) &#123; suppressed.add(e); &#125; &#125; catch (ClassNotFoundException e) &#123; if (suppressed != null) &#123; suppressed.add(e); &#125; &#125; return result;&#125;private static native Class defineClassNative(String name, ClassLoader loader, Object cookie) throws ClassNotFoundException, NoClassDefFoundError; loadClassBinaryName实际就是封装调用了defineClass（从代码中可以看出，传入的参数中有一个是mCookie，这个变量保存的正是之前加载的dex文件列表）,而defineClass实际调用的是native方法defineClassNative,只是额外做了异常处理．defineClassNative的实现在art/runtime/native/dalvik_system_DexFile.cc 6. DexFile_defineClassNative()1234567891011121314151617181920212223242526272829303132333435363738394041static jclass DexFile_defineClassNative(JNIEnv* env, jclass, jstring javaName, jobject javaLoader, jobject cookie) &#123; //将Java层传入的mCookie变量转换为vector类型的dex文件列表 std::unique_ptr&lt;std::vector&lt;const DexFile*&gt;&gt; dex_files = ConvertJavaArrayToNative(env, cookie); ... ScopedUtfChars class_name(env, javaName); ... //将com.xx.xx转换为com/xx/xx const std::string descriptor(DotToDescriptor(class_name.c_str())); const size_t hash(ComputeModifiedUtf8Hash(descriptor.c_str())); for (auto&amp; dex_file : *dex_files) &#123; //首先获取ClassDef const DexFile::ClassDef* dex_class_def = dex_file-&gt;FindClassDef(descriptor.c_str(), hash); if (dex_class_def != nullptr) &#123; ScopedObjectAccess soa(env); ClassLinker* class_linker = Runtime::Current()-&gt;GetClassLinker(); StackHandleScope&lt;1&gt; hs(soa.Self()); Handle&lt;mirror::ClassLoader&gt; class_loader( hs.NewHandle(soa.Decode&lt;mirror::ClassLoader*&gt;(javaLoader))); //生成dex_cache，并放入缓存队列, [6.1] class_linker-&gt;RegisterDexFile(*dex_file, class_loader.Get()); //加载类，[7] mirror::Class* result = class_linker-&gt;DefineClass(soa.Self(), descriptor.c_str(), hash, class_loader, *dex_file, *dex_class_def); // Add the used dex file. This only required for the DexFile.loadClass API since normal // class loaders already keep their dex files live. class_linker-&gt;InsertDexFileInToClassLoader(soa.Decode&lt;mirror::Object*&gt;(dexFile), class_loader.Get()); if (result != nullptr) &#123; ... return soa.AddLocalReference&lt;jclass&gt;(result); &#125; &#125; &#125; return nullptr;&#125; defineClassNative第一个关键步骤是将Java层传入的mCookie变量转换为Native的vector类型的dex文件列表 在Native层,每个dex文件有一个对应的DexCache结构，该结构缓存了dex文件中一些基本的信息 遍历dex文件列表时，首先从dex文件中获取ClassDef结构，之后再根据这个ClassDef来加载相应的类 6.1 ClassLinker::RegisterDexFile()123456789101112131415161718192021222324252627282930313233343536373839404142mirror::DexCache* ClassLinker::RegisterDexFile(const DexFile&amp; dex_file, mirror::ClassLoader* class_loader) &#123; Thread* self = Thread::Current(); &#123; ReaderMutexLock mu(self, dex_lock_); //查找是由已经有对应的dex_cache，有则直接返回 mirror::DexCache* dex_cache = FindDexCacheLocked(self, dex_file, true); if (dex_cache != nullptr) &#123; return dex_cache; &#125; &#125; //获取ClassLoader对应的LinearAlloc LinearAlloc* const linear_alloc = GetOrCreateAllocatorForClassLoader(class_loader); DCHECK(linear_alloc != nullptr); ClassTable* table; &#123; WriterMutexLock mu(self, *Locks::classlinker_classes_lock_); //获取ClassLoader的ClassTable table = InsertClassTableForClassLoader(class_loader); &#125; StackHandleScope&lt;1&gt; hs(self); //在LinearAlloc创建一个dex_cache结构，此时不要持有dex_lock_锁，因为分配时可能会挂起所有线程而且可能存在线程需要 //dex_lock_ Handle&lt;mirror::DexCache&gt; h_dex_cache(hs.NewHandle(AllocDexCache(self, dex_file, linear_alloc))); &#123; WriterMutexLock mu(self, dex_lock_); mirror::DexCache* dex_cache = FindDexCacheLocked(self, dex_file, true); if (dex_cache != nullptr) &#123; return dex_cache; &#125; //如果分配dex_cache结构失败，则一定是发生了OOM if (h_dex_cache.Get() == nullptr) &#123; self-&gt;AssertPendingOOMException(); return nullptr; &#125; //根据dex_file生成dex_cache,并注册dex_cache RegisterDexFileLocked(dex_file, h_dex_cache); &#125; table-&gt;InsertStrongRoot(h_dex_cache.Get()); return h_dex_cache.Get();&#125; 7. ClassLinker::DefineClass123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960mirror::Class* ClassLinker::DefineClass(Thread* self, const char* descriptor, size_t hash, Handle&lt;mirror::ClassLoader&gt; class_loader, const DexFile&amp; dex_file, const DexFile::ClassDef&amp; dex_class_def) &#123; StackHandleScope&lt;3&gt; hs(self); auto klass = hs.NewHandle&lt;mirror::Class&gt;(nullptr); //如果ClassLinker还未初始化完成，且要加载的正好是几个指定的系统类，将kclass指向系统类 ... if (klass.Get() == nullptr) &#123; //创建Class对象 klass.Assign(AllocClass(self, SizeOfClassWithoutEmbeddedTables(dex_file, dex_class_def))); &#125; ... //获取dex_cache结构，如果未获取到则创建 mirror::DexCache* dex_cache = RegisterDexFile(dex_file, class_loader.Get()); if (dex_cache == nullptr) &#123; self-&gt;AssertPendingOOMException(); return nullptr; &#125; klass-&gt;SetDexCache(dex_cache); //设置klass基本属性, [7.1] SetupClass(dex_file, dex_class_def, klass, class_loader.Get()); ... ObjectLock&lt;mirror::Class&gt; lock(self, klass); klass-&gt;SetClinitThreadId(self-&gt;GetTid()); // 将要加载的类添加到ClassLinker的已加载类列表 mirror::Class* existing = InsertClass(descriptor, klass.Get(), hash); if (existing != nullptr) &#123; //如果插入失败，则表明类已经被加载过 return EnsureResolved(self, descriptor, existing); &#125; //加载类，[7.2] LoadClass(self, dex_file, dex_class_def, klass); ... CHECK(!klass-&gt;IsLoaded()); if (!LoadSuperAndInterfaces(klass, dex_file)) &#123; ... &#125; //正常情况下,此时klass-&gt;IsLoaded ＝ true CHECK(klass-&gt;IsLoaded()); //正常情况下，此时klass-&gt;isResolved = false CHECK(!klass-&gt;IsResolved()); auto interfaces = hs.NewHandle&lt;mirror::ObjectArray&lt;mirror::Class&gt;&gt;(nullptr); MutableHandle&lt;mirror::Class&gt; h_new_class = hs.NewHandle&lt;mirror::Class&gt;(nullptr); //对加载后的类进行链接解析，[7.3] if (!LinkClass(self, descriptor, klass, interfaces, &amp;h_new_class)) &#123; ... &#125; ... return h_new_class.Get();&#125; DefineClass中的关键步骤可以总结为:SetupClass–&gt;InsertClass–&gt;LoadClass–&gt;LoadSuperAndInterfaces–&gt;LinkClass 7.1 ClassLinker::SetupClass12345678910111213141516171819202122void ClassLinker::SetupClass(const DexFile&amp; dex_file, const DexFile::ClassDef&amp; dex_class_def, Handle&lt;mirror::Class&gt; klass, mirror::ClassLoader* class_loader) &#123; ... //Check(...) const char* descriptor = dex_file.GetClassDescriptor(dex_class_def); ... //Check(...) klass-&gt;SetClass(GetClassRoot(kJavaLangClass)); uint32_t access_flags = dex_class_def.GetJavaAccessFlags(); ... //Check(...) klass-&gt;SetAccessFlags(access_flags); klass-&gt;SetClassLoader(class_loader); ... //Check(...) mirror::Class::SetStatus(klass, mirror::Class::kStatusIdx, nullptr); klass-&gt;SetDexClassDefIndex(dex_file.GetIndexForClassDef(dex_class_def)); klass-&gt;SetDexTypeIndex(dex_class_def.class_idx_); ... //Check(...)&#125; 可以看到，SetupClass方法主要是给Class对象设置基本属性如access_flags,ClassLoader 7.2 ClassLinker::LoadClass()123456789101112131415161718192021222324void ClassLinker::LoadClass(Thread* self, const DexFile&amp; dex_file, const DexFile::ClassDef&amp; dex_class_def, Handle&lt;mirror::Class&gt; klass) &#123; //获取ClassData const uint8_t* class_data = dex_file.GetClassData(dex_class_def); if (class_data == nullptr) &#123; return; // no fields or methods - for example a marker interface &#125; bool has_oat_class = false; if (Runtime::Current()-&gt;IsStarted() &amp;&amp; !Runtime::Current()-&gt;IsAotCompiler()) &#123; //获取OatClass,通过OatClass可以获取类方法的本地机器指令 //klass-&gt;GetDexClassDefIndex()获取相应ClassDef结构在dex文件内的索引号，这个索引号是在之前的 //SetupClass()函数中获取并设置 OatFile::OatClass oat_class = FindOatClass(dex_file, klass-&gt;GetDexClassDefIndex(), &amp;has_oat_class); if (has_oat_class) &#123; //加载类成员, [7.2.1] LoadClassMembers(self, dex_file, class_data, klass, &amp;oat_class); &#125; &#125; if (!has_oat_class) &#123; LoadClassMembers(self, dex_file, class_data, klass, nullptr); &#125;&#125; 从dex文件内部获取ClassData结构 根据ClassDef的索引位置获取相应OatClass结构，通过OatClass结构可以获取类方法的本地机器指令 如果找到OatClass则根据OatClass来加载类成员 dex文件中每一个类在oat文件中都由一个对应的OatClass结构，根据OatClass可以找到每一个类方法的本地机器指令 7.2.1 ClassLinker::LoadClassMembers()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283void ClassLinker::LoadClassMembers(Thread* self, const DexFile&amp; dex_file, const uint8_t* class_data, Handle&lt;mirror::Class&gt; klass, const OatFile::OatClass* oat_class) &#123; &#123; //在没有加载完类成员之前，不允许当前线程挂起 ScopedAssertNoThreadSuspension nts(self, __FUNCTION__); //加载静态属性 LinearAlloc* const allocator = GetAllocatorForClassLoader(klass-&gt;GetClassLoader()); ClassDataItemIterator it(dex_file, class_data); LengthPrefixedArray&lt;ArtField&gt;* sfields = AllocArtFieldArray(self, allocator, it.NumStaticFields()); size_t num_sfields = 0; uint32_t last_field_idx = 0u; for (; it.HasNextStaticField(); it.Next()) &#123; uint32_t field_idx = it.GetMemberIndex(); if (num_sfields == 0 || LIKELY(field_idx &gt; last_field_idx)) &#123; //加载属性,[7.2.1.1] LoadField(it, klass, &amp;sfields-&gt;At(num_sfields)); ++num_sfields; last_field_idx = field_idx; &#125; &#125; //加载实例属性 LengthPrefixedArray&lt;ArtField&gt;* ifields = AllocArtFieldArray(self, allocator, it.NumInstanceFields()); size_t num_ifields = 0u; last_field_idx = 0u; for (; it.HasNextInstanceField(); it.Next()) &#123; uint32_t field_idx = it.GetMemberIndex(); if (num_ifields == 0 || LIKELY(field_idx &gt; last_field_idx)) &#123; LoadField(it, klass, &amp;ifields-&gt;At(num_ifields)); ++num_ifields; last_field_idx = field_idx; &#125; &#125; .... // Set the field arrays. klass-&gt;SetSFieldsPtr(sfields); klass-&gt;SetIFieldsPtr(ifields); // 加载方法 klass-&gt;SetMethodsPtr( AllocArtMethodArray(self, allocator, it.NumDirectMethods() + it.NumVirtualMethods()), it.NumDirectMethods(), it.NumVirtualMethods()); size_t class_def_method_index = 0; uint32_t last_dex_method_index = DexFile::kDexNoIndex; size_t last_class_def_method_index = 0; //首先加载直接方法 for (size_t i = 0; it.HasNextDirectMethod(); i++, it.Next()) &#123; ArtMethod* method = klass-&gt;GetDirectMethodUnchecked(i, image_pointer_size_); //加载方法，[7.2.1.2] LoadMethod(self, dex_file, it, klass, method); //将方法同对应的本地机器指令关联，这样在方法执行时就可以知道该如何执行, [7.2.1.3] LinkCode(method, oat_class, class_def_method_index); uint32_t it_method_index = it.GetMemberIndex(); if (last_dex_method_index == it_method_index) &#123; method-&gt;SetMethodIndex(last_class_def_method_index); &#125; else &#123; method-&gt;SetMethodIndex(class_def_method_index); last_dex_method_index = it_method_index; last_class_def_method_index = class_def_method_index; &#125; class_def_method_index++; &#125; //加载虚拟方法 for (size_t i = 0; it.HasNextVirtualMethod(); i++, it.Next()) &#123; ArtMethod* method = klass-&gt;GetVirtualMethodUnchecked(i, image_pointer_size_); LoadMethod(self, dex_file, it, klass, method); LinkCode(method, oat_class, class_def_method_index); class_def_method_index++; &#125; &#125; // Ensure that the card is marked so that remembered sets pick up native roots. Runtime::Current()-&gt;GetHeap()-&gt;WriteBarrierEveryFieldOf(klass.Get()); self-&gt;AllowThreadSuspension();&#125; 首先便是设置当前线程在没有完成加载类成员工作之前不能被挂起 之后依次加载Static Field，Instance Field,所有Field都用ArtField表示 加载完Field后，再依次加载Direct Method和Virtual Method并关联Method对应的机器指令，所有Method都用ArtMethod表示 当所有加载工作完成之后，告知线程加载工作完成，允许被挂起 7.2.1.1 ClassLinker::LoadField()1234567void ClassLinker::LoadField(const ClassDataItemIterator&amp; it, Handle&lt;mirror::Class&gt; klass, ArtField* dst) &#123; const uint32_t field_idx = it.GetMemberIndex(); dst-&gt;SetDexFieldIndex(field_idx); dst-&gt;SetDeclaringClass(klass.Get()); dst-&gt;SetAccessFlags(it.GetFieldAccessFlags());&#125; 7.2.1.2 ClassLinker::LoadMethod()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void ClassLinker::LoadMethod(Thread* self, const DexFile&amp; dex_file, const ClassDataItemIterator&amp; it, Handle&lt;mirror::Class&gt; klass, ArtMethod* dst) &#123; //从dex文件的ClassData结构种获取对应Method的索引 uint32_t dex_method_idx = it.GetMemberIndex(); //获取MethodId结构 const DexFile::MethodId&amp; method_id = dex_file.GetMethodId(dex_method_idx); const char* method_name = dex_file.StringDataByIdx(method_id.name_idx_); ScopedAssertNoThreadSuspension ants(self, \"LoadMethod\"); dst-&gt;SetDexMethodIndex(dex_method_idx); dst-&gt;SetDeclaringClass(klass.Get()); dst-&gt;SetCodeItemOffset(it.GetMethodCodeItemOffset()); dst-&gt;SetDexCacheResolvedMethods(klass-&gt;GetDexCache()-&gt;GetResolvedMethods()); dst-&gt;SetDexCacheResolvedTypes(klass-&gt;GetDexCache()-&gt;GetResolvedTypes()); uint32_t access_flags = it.GetMethodAccessFlags(); //一般情况下，方法名不会是finalize if (UNLIKELY(strcmp(\"finalize\", method_name) == 0)) &#123; // Set finalizable flag on declaring class. if (strcmp(\"V\", dex_file.GetShorty(method_id.proto_idx_)) == 0) &#123; // Void return type. if (klass-&gt;GetClassLoader() != nullptr) &#123; // All non-boot finalizer methods are flagged. klass-&gt;SetFinalizable(); &#125; else &#123; std::string temp; const char* klass_descriptor = klass-&gt;GetDescriptor(&amp;temp); //Enum枚举类不设置finalizable,因为枚举类已经声明了一个final finalize() if (strcmp(klass_descriptor, \"Ljava/lang/Object;\") != 0 &amp;&amp; strcmp(klass_descriptor, \"Ljava/lang/Enum;\") != 0) &#123; klass-&gt;SetFinalizable(); &#125; &#125; &#125; &#125; else if (method_name[0] == '&lt;') &#123; //判断是不是实例化构造函数 bool is_init = (strcmp(\"&lt;init&gt;\", method_name) == 0); //判断是不是类初始化方法 bool is_clinit = !is_init &amp;&amp; (strcmp(\"&lt;clinit&gt;\", method_name) == 0); if (UNLIKELY(!is_init &amp;&amp; !is_clinit)) &#123; ... //LOG &#125; else &#123; if (UNLIKELY((access_flags &amp; kAccConstructor) == 0)) &#123; access_flags |= kAccConstructor; &#125; &#125; &#125; dst-&gt;SetAccessFlags(access_flags);&#125; 7.2.1.3 ClassLinker::LinkCode()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960void ClassLinker::LinkCode(ArtMethod* method, const OatFile::OatClass* oat_class, uint32_t class_def_method_index) &#123; Runtime* const runtime = Runtime::Current(); if (runtime-&gt;IsAotCompiler()) &#123; return; &#125; ... if (oat_class != nullptr) &#123; //从OatClass中获取对应的OatMethod,OatMethod中记录了方法的本地机器指令的偏移地址 //通过OatMethod::LinkMethod将OatMethod中记录的信息设置到ArtMethod当中 const OatFile::OatMethod oat_method = oat_class-&gt;GetOatMethod(class_def_method_index); oat_method.LinkMethod(method); &#125; //之后设置方法执行的entry point //判断是否需要解释执行： //1.当没有本地机器指令 //2.Runtime指定以Interpreter方式运行且方法不是native同时也不是proxy //JNI方法是没有对应的DEX字节码的，因此即使ART虚拟机运行在解释模式中，JNI方法也不能通过解释器来执行 bool enter_interpreter = NeedsInterpreter(method, method-&gt;GetEntryPointFromQuickCompiledCode()); if (enter_interpreter &amp;&amp; !method-&gt;IsNative()) &#123; method-&gt;SetEntryPointFromInterpreter(artInterpreterToInterpreterBridge); &#125; else &#123; //有两种情况会进入这一分支 //不需要解释执行的方法 //没有本地机器指令或者Runtime以Interpreter方式运行，但该方法是native method-&gt;SetEntryPointFromInterpreter(artInterpreterToCompiledCodeBridge); &#125; if (method-&gt;IsAbstract()) &#123; //抽象方法没有机器指令，当有机器指令的方法调用抽象方法时，需要设置一个桥接函数，从而转到 //解释器，由解释器解释执行抽象方法 method-&gt;SetEntryPointFromQuickCompiledCode(GetQuickToInterpreterBridge()); return; &#125; if (method-&gt;IsStatic() &amp;&amp; !method-&gt;IsConstructor()) &#123; method-&gt;SetEntryPointFromQuickCompiledCode(GetQuickResolutionStub()); &#125; else if (enter_interpreter) &#123; if (!method-&gt;IsNative()) &#123; method-&gt;SetEntryPointFromQuickCompiledCode(GetQuickToInterpreterBridge()); &#125; else &#123; //只有当native方法没有本地机器指令时，会执行这一分支 method-&gt;SetEntryPointFromQuickCompiledCode(GetQuickGenericJniStub()); &#125; &#125; if (method-&gt;IsNative()) &#123; // Unregistering restores the dlsym lookup stub. method-&gt;UnregisterNative(); if (enter_interpreter) &#123; //native方法且没有对应的机器指令，则该方法如果是non-static,则entry point是generic JNI trampoline //如果是static, 则entry point是resolution trampoline const void* entry_point = method-&gt;GetEntryPointFromQuickCompiledCode(); DCHECK(IsQuickGenericJniStub(entry_point) || IsQuickResolutionStub(entry_point)); &#125; &#125;&#125; LinkCode方法主要作用是根据方法属性来设置entry point 对于需要解释的方法，该方法需要由解释器解释执行，当另一个解释方法调用了这个需要解释执行的方法时，该方法的入口函数是artInterpreterToInterpreterBridge,从而继续在解释器中解释执行；如果当前方法是执行本地机器指令，当另一个解释执行的方法调用了这个执行本地机器指令的方法，该方法的入口函数是artInterpreterToCompiledCodeBridge，artInterpreterToCompiledCodeBridge会去调用相应的机器指令 抽象方法需要由被子类实现，所以抽象类是没有本地机器指令的，需要由解释器解释执行，当有机器指令的方法调用抽象方法时, 需要设置一个桥接函数，从而转到解释器，由解释器解释执行抽象方法, 这个桥接函数是GetQuickToInterpreterBridge() 对于静态非构造函数，当有执行机器指令的方法调用这类函数时，入口函数是GetQuickResolutionStub()．因为静态方法不需要创建对象便可执行，着就有可能出现类还未初始化，方法就要执行，所以此时就需要现将类初始化，再执行静态方法，GetQuickResolutionStub完成的正是这项工作 对于需要解释执行且不是native的方法，当执行本地机器指令的方法调用该方法时，入口函数是GetQuickToInterpreterBridge(),该函数会转到解释器，由解释器执行这个需要解释执行的方法；当一个执行本地机器指令的方法调用没有机器指令的native方法时，入口函数是GetQuickGenericJniStub() 如果一个方法是native方法，设置本地方法的入口是通过GetJniDlsymLookupStub获得的一个Stub 以上内容参考老罗的Android运行时ART加载类和方法的过程分析 8. ClassLinker::InsertDexFileInToClassLoader1234567891011void ClassLinker::InsertDexFileInToClassLoader(mirror::Object* dex_file, mirror::ClassLoader* class_loader) &#123; Thread* const self = Thread::Current(); WriterMutexLock mu(self, *Locks::classlinker_classes_lock_); ClassTable* const table = ClassTableForClassLoader(class_loader); //InsertStrongRoot方法将dex_file对象放入ClassTable的strong_table_队列中 if (table-&gt;InsertStrongRoot(dex_file) &amp;&amp; class_loader != nullptr) &#123; //执行write barrier从而让GC知道ClassLoader的ClassTable发生了改变 Runtime::Current()-&gt;GetHeap()-&gt;WriteBarrierEveryFieldOf(class_loader); &#125;&#125;","tags":[{"name":"ART","slug":"ART","permalink":"https://wangyun137.github.io/tags/ART/"},{"name":"源码分析","slug":"源码分析","permalink":"https://wangyun137.github.io/tags/源码分析/"}]},{"title":"ART加载dex文件","date":"2017-07-24T05:53:05.000Z","path":"2017/07/24/ART加载dex文件/","text":"一．Java层调用链1.1 ActivityThread.performLaunchActivity一般应用程序的启动都是由点击Launcher上的图标来启动，而点击图标时所执行的操作是startActivity(Intent intent)，经过一系列复杂的调用链后，最终会初始化Activity实例并回调onCreate，而执行初始化实例并回调onCreate的方法是ActivityThread.performLaunchActivity, 核心代码为： 12345678910111213141516171819202122232425private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ... Activity activity = null; try &#123; //获取ClassLoader同时加载相应的dex文件 //r.packageInfo是LoadApk的实例 java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); //初始化Activity实例 activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( \"Unable to instantiate activity \" + component + \": \" + e.toString(), e); &#125; &#125;...&#125; 1.2 LoadApk.getClassLoader1234567891011121314public ClassLoader getClassLoader() &#123; synchronized (this) &#123; //如果已经加载过dex文件则直接返回ClassLoader if (mClassLoader != null) &#123; return mClassLoader; &#125; ... //如果还没有加载dex，则初始化相应的ClassLoader并加载dex文件 //mBaseClassLoader = null，在performLaunchActivity中初始化LoadApk的时候设置 mClassLoader = ApplicationLoaders.getDefault().getClassLoader(zip, lib, mBaseClassLoader); &#125; return mClassLoader;&#125; 1.3 ApplicationLoaders.getClassLoader1234567891011121314151617181920212223242526272829303132public ClassLoader getClassLoader(String zip, String libPath, ClassLoader parent)&#123; //Class.getSystemClassLoader返回的是一个PathClassLoader //baseParent是BootClassLoader ClassLoader baseParent = ClassLoader.getSystemClassLoader().getParent(); synchronized (mLoaders) &#123; if (parent == null) &#123; parent = baseParent; &#125; if (parent == baseParent) &#123; ClassLoader loader = mLoaders.get(zip); if (loader != null) &#123; return loader; &#125; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, zip); //创建一个PathClassLoader,并放入缓存，方便以后直接获取 PathClassLoader pathClassloader = new PathClassLoader(zip, libPath, parent); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); mLoaders.put(zip, pathClassloader); return pathClassloader; &#125; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, zip); PathClassLoader pathClassloader = new PathClassLoader(zip, parent); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); return pathClassloader; &#125;&#125; 1.4 PathClassLoader()123456public PathClassLoader(String dexPath, String libraryPath, ClassLoader parent) &#123; //PathClassLoader继承自BaseDexClassLoader，所以会调用 //BaseDexClassLoader的构造函数 super(dexPath, null, libraryPath, parent);&#125; 1.5 BaseDexClassLoader()123456//由PathClassLoader传入的参数可以知道第二个参数optimizedDirectory=nullpublic BaseDexClassLoader(String dexPath, File optimizedDirectory, String libraryPath, ClassLoader parent) &#123; super(parent); this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory);&#125; 1.6 DexPathList()12345678910111213141516171819202122public DexPathList(ClassLoader definingContext, String dexPath, String libraryPath, File optimizedDirectory) &#123; ... this.definingContext = definingContext; ArrayList&lt;IOException&gt; suppressedExceptions = new ArrayList&lt;IOException&gt;(); //加载dex文件 this.dexElements = makePathElements(splitDexPath(dexPath), optimizedDirectory, suppressedExceptions); this.nativeLibraryDirectories = splitPaths(libraryPath, false); this.systemNativeLibraryDirectories = splitPaths(System.getProperty(\"java.library.path\"), true); List&lt;File&gt; allNativeLibraryDirectories = new ArrayList&lt;&gt;(nativeLibraryDirectories); allNativeLibraryDirectories.addAll(systemNativeLibraryDirectories); //加载library文件 this.nativeLibraryPathElements = makePathElements(allNativeLibraryDirectories, null, suppressedExceptions); ... 1.7 DexPathList.makePathElements()123456789101112131415161718192021222324252627282930313233343536373839404142434445private static Element[] makePathElements(List&lt;File&gt; files, File optimizedDirectory, List&lt;IOException&gt; suppressedExceptions) &#123; List&lt;Element&gt; elements = new ArrayList&lt;&gt;(); for (File file : files) &#123; File zip = null; File dir = new File(\"\"); DexFile dex = null; String path = file.getPath(); String name = file.getName(); if (path.contains(zipSeparator)) &#123; String split[] = path.split(zipSeparator, 2); zip = new File(split[0]); dir = new File(split[1]); &#125; else if (file.isDirectory()) &#123; //如果file是library会执行这一分支 elements.add(new Element(file, true, null, null)); &#125; else if (file.isFile()) &#123; if (name.endsWith(DEX_SUFFIX)) &#123; //如果文件以.dex结尾，直接加载 try &#123; dex = loadDexFile(file, optimizedDirectory); &#125; catch (IOException ex) &#123; System.logE(\"Unable to load dex file: \" + file, ex); &#125; &#125; else &#123; zip = file; //加载位于.zip或者.apk文件内的dex文件 try &#123; dex = loadDexFile(file, optimizedDirectory); &#125; catch (IOException suppressed) &#123; suppressedExceptions.add(suppressed); &#125; &#125; &#125; else &#123; System.logW(\"ClassLoader referenced unknown path: \" + file); &#125; if ((zip != null) || (dex != null)) &#123; elements.add(new Element(dir, false, zip, dex)); &#125; &#125; return elements.toArray(new Element[elements.size()]);&#125; 1.8 DexPathList.loadDexFile()1234567891011private static DexFile loadDexFile(File file, File optimizedDirectory) throws IOException &#123; if (optimizedDirectory == null) &#123; //如果是PathClassLoader,则执行这一步 return new DexFile(file); &#125; else &#123; //首先确保输出后的文件是以.dex结尾 String optimizedPath = optimizedPathFor(file, optimizedDirectory); return DexFile.loadDex(file.getPath(), optimizedPath, 0); &#125;&#125; 1.8.1 DexFile(String fileName)1234567public DexFile(String fileName) throws IOException &#123; //mCookie是一个Object类型的对象，用这个对象来保存dex文件也可能是dex文件列表 //之后在加载class的时候，会把这个对象传入，从而加载相应的class mCookie = openDexFile(fileName, null, 0); mFileName = fileName; guard.open(\"close\");&#125; 1.8.2 DexFile.loadDex()12345static public DexFile loadDex(String sourcePathName, String outputPathName, int flags) throws IOException &#123; return new DexFile(sourcePathName, outputPathName, flags);&#125; 1.8.3 DexFile()12345678910111213141516171819private DexFile(String sourceName, String outputName, int flags) throws IOException &#123; if (outputName != null) &#123; try &#123; String parent = new File(outputName).getParent(); //确保输出目录属于当前应用，即输出目录是应用的私有目录/data/data/package_name/xxx if (Libcore.os.getuid() != Libcore.os.stat(parent).st_uid) &#123; throw new IllegalArgumentException(\"Optimized data directory \" + parent + \" is not owned by the current user. Shared storage cannot protect\" + \" your application from code injection attacks.\"); &#125; &#125; catch (ErrnoException ignored) &#123; &#125; &#125; //mCookie是一个Object类型的对象，用这个对象来保存dex文件也可能是dex文件列表 //之后在加载class的时候，会把这个对象传入，从而加载相应的class mCookie = openDexFile(sourceName, outputName, flags); mFileName = sourceName; guard.open(\"close\");&#125; 从以上代码片段中可以看出，最后加载dex文件都是调用DexFile.openDexFile这个方法 1.9. DexFile.openDexFile()12345private static Object openDexFile(String sourceName, String outputName, int flags) throws IOException &#123; return openDexFileNative(new File(sourceName).getAbsolutePath(), (outputName == null) ? null : new File(outputName).getAbsolutePath(), flags);&#125; openDexFileNative是一个native方法，之后的调用进入native层 二．Native调用链2.1 DexFile_openDexFileNative()123456789101112131415161718192021static jobject DexFile_openDexFileNative( JNIEnv* env, jclass, jstring javaSourceName, jstring javaOutputName, jint) &#123; ... ClassLinker* linker = Runtime::Current()-&gt;GetClassLinker(); std::vector&lt;std::unique_ptr&lt;const DexFile&gt;&gt; dex_files; std::vector&lt;std::string&gt; error_msgs; dex_files = linker-&gt;OpenDexFilesFromOat(sourceName.c_str(), outputName.c_str(), &amp;error_msgs); if (!dex_files.empty()) &#123; jlongArray array = ConvertNativeToJavaArray(env, dex_files); ... //错误处理，释放相应资源 //返回给Java层，由DexFile的mCookie指向 return array; &#125; else &#123; ... //抛出异常 return nullptr; &#125;&#125; 2.2 ClassLinker::OpenDexFilesFromOat()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586std::vector&lt;std::unique_ptr&lt;const DexFile&gt;&gt; ClassLinker::OpenDexFilesFromOat( const char* dex_location, const char* oat_location, std::vector&lt;std::string&gt;* error_msgs) &#123; CHECK(error_msgs != nullptr); // Verify we aren't holding the mutator lock, which could starve GC if we // have to generate or relocate an oat file. Locks::mutator_lock_-&gt;AssertNotHeld(Thread::Current()); //Runtime::Current()-&gt;IsAotCompiler用来判断Runtime是否用于dex2oat,dex2oat程序 //也会创建一个Runtime,专门用来Compile OatFileAssistant oat_file_assistant(dex_location, oat_location, kRuntimeISA, !Runtime::Current()-&gt;IsAotCompiler()); // Lock the target oat location to avoid races generating and loading the // oat file. std::string error_msg; if (!oat_file_assistant.Lock(&amp;error_msg)) &#123; ... &#125; // Check if we already have an up-to-date oat file open. const OatFile* source_oat_file = nullptr; &#123; ReaderMutexLock mu(Thread::Current(), dex_lock_); //oat_file_变量属于ClassLinker，用来存放oat文件 for (const OatFile* oat_file : oat_files_) &#123; ... // 判断oat文件是否正确 if (oat_file_assistant.GivenOatFileIsUpToDate(*oat_file)) &#123; source_oat_file = oat_file; break; &#125; &#125; &#125; // If we didn't have an up-to-date oat file open, try to load one from disk. if (source_oat_file == nullptr) &#123; // Update the oat file on disk if we can. This may fail, but that's okay. // Best effort is all that matters here. // 根据dex文件产生对应的oat文件 if (!oat_file_assistant.MakeUpToDate(&amp;error_msg)) &#123; ... &#125; // Get the oat file on disk. std::unique_ptr&lt;OatFile&gt; oat_file = oat_file_assistant.GetBestOatFile(); if (oat_file.get() != nullptr) &#123; // Take the file only if it has no collisions, or we must take it because of preopting. bool accept_oat_file = !HasCollisions(oat_file.get(), &amp;error_msg); if (!accept_oat_file) &#123; ... // However, if the app was part of /system and preopted, there is no original dex file // available. In that case grudgingly accept the oat file. if (!DexFile::MaybeDex(dex_location)) &#123; accept_oat_file = true; ... &#125; &#125; if (accept_oat_file) &#123; source_oat_file = oat_file.release(); //将oat_file添加至oat_file_ RegisterOatFile(source_oat_file); &#125; &#125; &#125; std::vector&lt;std::unique_ptr&lt;const DexFile&gt;&gt; dex_files; // Load the dex files from the oat file. if (source_oat_file != nullptr) &#123; //通过OatFileAssistant加载dex文件 dex_files = oat_file_assistant.LoadDexFiles(*source_oat_file, dex_location); if (dex_files.empty()) &#123; ... &#125; &#125; // Fall back to running out of the original dex file if we couldn't load any // dex_files from the oat file. if (dex_files.empty()) &#123; ... &#125; return dex_files;&#125; 2.3 OatFileAssistant::LoadDexFiles()12345678910111213141516171819202122232425262728293031323334353637383940414243std::vector&lt;std::unique_ptr&lt;const DexFile&gt;&gt; OatFileAssistant::LoadDexFiles( const OatFile&amp; oat_file, const char* dex_location) &#123; std::vector&lt;std::unique_ptr&lt;const DexFile&gt;&gt; dex_files; //先加载主dex文件. //先从OatFile中获取OatDexFile, 在oat文件中每一个OatDexFile记录了相应的 //dex文件的文件名，文件偏移地址等关键信息 std::string error_msg; const OatFile::OatDexFile* oat_dex_file = oat_file.GetOatDexFile( dex_location, nullptr, false); if (oat_dex_file == nullptr) &#123; ... return std::vector&lt;std::unique_ptr&lt;const DexFile&gt;&gt;(); &#125; //通过OatDexFile加载主dex, [2.4] std::unique_ptr&lt;const DexFile&gt; dex_file = oat_dex_file-&gt;OpenDexFile(&amp;error_msg); if (dex_file.get() == nullptr) &#123; LOG(WARNING) &lt;&lt; \"Failed to open dex file from oat dex file: \" &lt;&lt; error_msg; return std::vector&lt;std::unique_ptr&lt;const DexFile&gt;&gt;(); &#125; dex_files.push_back(std::move(dex_file)); //加载其余的次级dex文件 for (size_t i = 1; ; i++) &#123; //先获取次级dex文件的索引位置 std::string secondary_dex_location = DexFile::GetMultiDexLocation(i, dex_location); //根据索引位置获取对应的OatDexFile结构 oat_dex_file = oat_file.GetOatDexFile(secondary_dex_location.c_str(), nullptr, false); if (oat_dex_file == nullptr) &#123; // There are no more secondary dex files to load. break; &#125; //加载次级dex文件 dex_file = oat_dex_file-&gt;OpenDexFile(&amp;error_msg); if (dex_file.get() == nullptr) &#123; LOG(WARNING) &lt;&lt; \"Failed to open dex file from oat dex file: \" &lt;&lt; error_msg; return std::vector&lt;std::unique_ptr&lt;const DexFile&gt;&gt;(); &#125; dex_files.push_back(std::move(dex_file)); &#125; return dex_files;&#125; 每一个dex文件的信息都被封装在一个OatDexFile中OatDexFile数据结构：const OatFile* const oat_file_:指向oat文件的指针const std::string dex_file_location_：dex文件名const std::string_canonical_dex_file_location_：dex文件绝对路径const uint32_t dex_file_location_cheksum_:dex文件名的校验和const uint8_t* const dex_file_pointer_:指向对应dex文件在oat文件中相对于oatdata的偏移地址const uint32_t* const oat_class_offsets_pointer_:指向属于该dex文件的OatClass相对于oatdata的偏移地址 2.4 OatDexFile::OpenDexFile()1234std::unique_ptr&lt;const DexFile&gt; OatFile::OatDexFile::OpenDexFile(std::string* error_msg) const &#123; return DexFile::Open(dex_file_pointer_, FileSize(), dex_file_location_, dex_file_location_checksum_, this, error_msg);&#125; 2.5 DexFile::Open()1234567static std::unique_ptr&lt;const DexFile&gt; Open(const uint8_t* base, size_t size, const std::string&amp; location, uint32_t location_checksum, const OatDexFile* oat_dex_file, std::string* error_msg) &#123; return OpenMemory(base, size, location, location_checksum, nullptr, oat_dex_file, error_msg);&#125; 2.6 DexFile::OpenMemory()123456789101112131415161718std::unique_ptr&lt;const DexFile&gt; DexFile::OpenMemory(const uint8_t* base, size_t size, const std::string&amp; location, uint32_t location_checksum, MemMap* mem_map,//nullptr const OatDexFile* oat_dex_file, std::string* error_msg) &#123; //确保以４字节对齐 CHECK_ALIGNED(base, 4); // various dex file structures must be word aligned //初始化一个DexFile对象 std::unique_ptr&lt;DexFile&gt; dex_file( new DexFile(base, size, location, location_checksum, mem_map, oat_dex_file)); //检查dex的magic和version是否正确 if (!dex_file-&gt;Init(error_msg)) &#123; dex_file.reset(); &#125; return std::unique_ptr&lt;const DexFile&gt;(dex_file.release());&#125; 2.7 DexFile()1234567891011121314151617181920212223DexFile::DexFile(const uint8_t* base, size_t size, const std::string&amp; location, uint32_t location_checksum, MemMap* mem_map, const OatDexFile* oat_dex_file) : begin_(base), size_(size), location_(location), location_checksum_(location_checksum), mem_map_(mem_map),//nullptr header_(reinterpret_cast&lt;const Header*&gt;(base)), string_ids_(reinterpret_cast&lt;const StringId*&gt;(base + header_-&gt;string_ids_off_)), type_ids_(reinterpret_cast&lt;const TypeId*&gt;(base + header_-&gt;type_ids_off_)), field_ids_(reinterpret_cast&lt;const FieldId*&gt;(base + header_-&gt;field_ids_off_)), method_ids_(reinterpret_cast&lt;const MethodId*&gt;(base + header_-&gt;method_ids_off_)), proto_ids_(reinterpret_cast&lt;const ProtoId*&gt;(base + header_-&gt;proto_ids_off_)), class_defs_(reinterpret_cast&lt;const ClassDef*&gt;(base + header_-&gt;class_defs_off_)), find_class_def_misses_(0), class_def_index_(nullptr), oat_dex_file_(oat_dex_file) &#123; CHECK(begin_ != nullptr) &lt;&lt; GetLocation(); CHECK_GT(size_, 0U) &lt;&lt; GetLocation();&#125; DexFile数据结构const uint8_t* const begin_;dex文件的起始地址const size_t size_: dex文件的大小，以字节为单位const std::string location_:dex文件的文件名const uint32_t location_checksum_:dex文件名的校验和std::unique_ptr&lt;MemMap&gt; mem_map_:const Header* const header_:指向dex文件的头部const StringId* const string_ids_:指向dex文件StringId列表const TypeId* const type_ids:指向dex文件TypeId列表const FieldId* const field_ids_:指向dex文件FieldId列表const MethodId* const method_ids_:指向dex文件MethodId列表const ProtoId* const proto_ids_:指向dex文件ProtoID列表const ClassDef* const class_defs_:指向dex文件ClassDef列表 三．总结应用程序启动时，系统会创建属于该应用进程的PathClassLoader,创建PathClassLoader的过程就是加载dex文件的过程．ART内部支持加载多个dex文件，这是因为ART采用AOT方式，在应用安装的时候会将apk文件的所有dex文件统一编译到一个oat文件中．其实加载过程就是根据oat文件在Java层和Native层生成相应的数据结构，从而方便之后加载类和方法","tags":[{"name":"ART","slug":"ART","permalink":"https://wangyun137.github.io/tags/ART/"},{"name":"源码分析","slug":"源码分析","permalink":"https://wangyun137.github.io/tags/源码分析/"}]}]